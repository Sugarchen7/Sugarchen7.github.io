<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>STM32学习（中级篇） | Carl's blog</title><meta name="author" content="Carl"><meta name="copyright" content="Carl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="接着入门篇的内容，中级篇中，学习了RCC配置时钟，中断，外部中断的使用，系统计时器systick，串口通信，DNA存储器，以及关于I2C协议，以及EEPROM存储器的收发数据。">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32学习（中级篇）">
<meta property="og:url" content="http://carl.github.io/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/index.html">
<meta property="og:site_name" content="Carl&#39;s blog">
<meta property="og:description" content="接着入门篇的内容，中级篇中，学习了RCC配置时钟，中断，外部中断的使用，系统计时器systick，串口通信，DNA存储器，以及关于I2C协议，以及EEPROM存储器的收发数据。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b.zhutix.com/bizhi/geometrix/53.jpg">
<meta property="article:published_time" content="2023-01-08T13:16:41.000Z">
<meta property="article:modified_time" content="2023-01-08T13:20:06.903Z">
<meta property="article:author" content="Carl">
<meta property="article:tag" content="电赛准备">
<meta property="article:tag" content="单片机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b.zhutix.com/bizhi/geometrix/53.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://carl.github.io/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32学习（中级篇）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-08 21:20:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img.166.net/reunionpub/ds/nbot/20210317/232642-0ohjgimbna.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://b.zhutix.com/bizhi/geometrix/53.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Carl's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STM32学习（中级篇）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-08T13:16:41.000Z" title="发表于 2023-01-08 21:16:41">2023-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-08T13:20:06.903Z" title="更新于 2023-01-08 21:20:06">2023-01-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32学习（中级篇）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RCC的使用"><a href="#RCC的使用" class="headerlink" title="RCC的使用"></a>RCC的使用</h1><p>使用HSE、HSI来配置系统时钟</p>
<h2 id="RCC的功能框图"><a href="#RCC的功能框图" class="headerlink" title="RCC的功能框图"></a>RCC的功能框图</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/RCC002.png" alt="STM32时钟树"></p>
<h2 id="HSI-HSE-来配置系统时钟"><a href="#HSI-HSE-来配置系统时钟" class="headerlink" title="HSI/HSE 来配置系统时钟"></a>HSI/HSE 来配置系统时钟</h2><p>这块地方主要要求看懂代码，学会代码的移植即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码对照功能框图和系统文件来看</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HSI_SetSysClock</span><span class="params">(<span class="type">uint32_t</span> pllmul)</span></span><br><span class="line">&#123;</span><br><span class="line">    __IO <span class="type">uint32_t</span> HSIStartUpStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把RCC外设初始化成复位状态</span></span><br><span class="line">    RCC_DeInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能HSI</span></span><br><span class="line">    RCC_HSICmd(ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 HSI 就绪</span></span><br><span class="line">    HSIStartUpStatus = RCC-&gt;CR &amp; RCC_CR_HSIRDY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 HSI就绪之后则继续往下执行</span></span><br><span class="line">    <span class="keyword">if</span> (HSIStartUpStatus == RCC_CR_HSIRDY) &#123;</span><br><span class="line">    <span class="comment">//-------------------------------------------------------------//</span></span><br><span class="line">        <span class="comment">// 这两句是操作FLASH闪存用到的，如果不操作FLASH，这两个注释掉也没影响</span></span><br><span class="line">        <span class="comment">// 使能FLASH 预存取缓冲区</span></span><br><span class="line">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SYSCLK周期与闪存访问时间的比例设置，这里统一设置成2</span></span><br><span class="line">        <span class="comment">// 设置成2的时候，SYSCLK低于48M也可以工作，如果设置成0或者1的时候，</span></span><br><span class="line">        <span class="comment">// 如果配置的SYSCLK超出了范围的话，则会进入硬件错误，程序就死了</span></span><br><span class="line">        <span class="comment">// 0：0 &lt; SYSCLK &lt;= 24M</span></span><br><span class="line">        <span class="comment">// 1：24&lt; SYSCLK &lt;= 48M</span></span><br><span class="line">        <span class="comment">// 2：48&lt; SYSCLK &lt;= 72M</span></span><br><span class="line">        FLASH_SetLatency(FLASH_Latency_2);</span><br><span class="line">    <span class="comment">//------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AHB预分频因子设置为1分频，HCLK = SYSCLK</span></span><br><span class="line">        RCC_HCLKConfig(RCC_SYSCLK_Div1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// APB2预分频因子设置为1分频，PCLK2 = HCLK</span></span><br><span class="line">        RCC_PCLK2Config(RCC_HCLK_Div1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// APB1预分频因子设置为1分频，PCLK1 = HCLK/2</span></span><br><span class="line">        RCC_PCLK1Config(RCC_HCLK_Div2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-----------设置各种频率主要就是在这里设置-------------------//</span></span><br><span class="line">        <span class="comment">// 设置PLL时钟来源为HSE，设置PLL倍频因子</span></span><br><span class="line">        <span class="comment">// PLLCLK = 4MHz * pllmul</span></span><br><span class="line">        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, pllmul);</span><br><span class="line">    <span class="comment">//-- -----------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启PLL</span></span><br><span class="line">        RCC_PLLCmd(ENABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 PLL稳定</span></span><br><span class="line">        <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当PLL稳定之后，把PLL时钟切换为系统时钟SYSCLK</span></span><br><span class="line">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取时钟切换状态位，确保PLLCLK被选为系统时钟</span></span><br><span class="line">        <span class="keyword">while</span> (RCC_GetSYSCLKSource() != <span class="number">0x08</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果HSI开启失败，那么程序就会来到这里，用户可在这里添加出错的代码处理</span></span><br><span class="line">        <span class="comment">// 当HSE开启失败或者故障的时候，单片机会自动把HSI设置为系统时钟，</span></span><br><span class="line">        <span class="comment">// HSI是内部的高速时钟，8MHZ</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用HSE功能类似这里不多赘述.</p>
<hr>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断其实就是异常</p>
<p>系统出现异常时停止执行主程序 去执行中断服务程序,执行完中断服务程序之后再接着执行主程序的内容</p>
<p>这里中断可以嵌套,至于先执行哪一个中断,看中断优先级.</p>
<h2 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h2><ol>
<li>系统的异常,体现再内核</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr01.png" alt="F103系统异常清单"></p>
<ol start="2">
<li>外部中断,体现到外设中</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr02.png" alt="F103外部中断清单"></p>
<h2 id="中断的管理-NVIC"><a href="#中断的管理-NVIC" class="headerlink" title="中断的管理-NVIC"></a>中断的管理-NVIC</h2><p>NVIC(嵌套向量中断控制器):管理芯片中所有中断的部分 </p>
<p>中断服务固件库在 CMSIS文件夹中的 core_cm3.c 文件中和 misc.c中</p>
<h3 id="NVIC寄存器"><a href="#NVIC寄存器" class="headerlink" title="NVIC寄存器"></a>NVIC寄存器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在配置中断的时候我们一般只用ISER、ICER和IP这三个寄存器，ISER用来使能中断，ICER用来失能中断，IP用来设置中断优先级。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> ISER[<span class="number">8</span>];       <span class="comment">// 中断使能寄存器,相当于总开关</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED0[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ICER[<span class="number">8</span>];       <span class="comment">// 中断清除寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RSERVED1[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ISPR[<span class="number">8</span>];       <span class="comment">// 中断使能悬起寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED2[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ICPR[<span class="number">8</span>];       <span class="comment">// 中断清除悬起寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED3[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> IABR[<span class="number">8</span>];       <span class="comment">// 中断有效位寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED4[<span class="number">56</span>];</span><br><span class="line">    __IO <span class="type">uint8_t</span>  IP[<span class="number">240</span>];       <span class="comment">// 中断优先级寄存器(8Bit wide)</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED5[<span class="number">644</span>];</span><br><span class="line">    __O  <span class="type">uint32_t</span> STIR;          <span class="comment">// 软件触发中断寄存器</span></span><br><span class="line">&#125;  NVIC_Type;</span><br></pre></td></tr></table></figure>

<h2 id="中断优先级的定义"><a href="#中断优先级的定义" class="headerlink" title="中断优先级的定义"></a>中断优先级的定义</h2><p>在NVIC 有一个专门的寄存器：中断优先级寄存器NVIC_IPRx.<strong>在F103中,只有高四位有效.</strong></p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr04.png" alt="使用4bit表达优先级"></p>
<p>用于表达优先级的这4bit，又被分组成抢占优先级和子优先级。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行， 如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p>
<h3 id="优先级的分组"><a href="#优先级的分组" class="headerlink" title="优先级的分组"></a>优先级的分组</h3><p>优先级的分组由内核外设SCB的应用程序中断及复位控制寄存器AIRCR的PRIGROUP[10:8]位决定，F103分为了5组，具体如下：主优先级=抢占优先级</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr045.png" alt="img"></p>
<p>设置优先级分组可调用库函数NVIC_PriorityGroupConfig()实现，有关NVIC中断相关的库函数都在库文件misc.c和misc.h中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置中断优先级分组：抢占优先级和子优先级</span></span><br><span class="line"><span class="comment">* 形参如下：</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_0: 0bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            4 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_1: 1 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            3 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_2: 2 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            2 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_3: 3 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            1 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_4: 4 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            0 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @注意 如果优先级分组为0，则抢占优先级就不存在，优先级就全部由子优先级控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置优先级分组</span></span><br><span class="line">    SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr05.png" alt="优先级分组真值表"></p>
<h2 id="中断编程的步骤"><a href="#中断编程的步骤" class="headerlink" title="中断编程的步骤"></a>中断编程的步骤</h2><ol>
<li>使能中断请求,相当于打开总开关.–中断使能寄存器配置</li>
<li>配置中断优先级分组, 配置SCB_ARCR,—调用NVIC_PriorityGroupConfig();</li>
<li>配置NVIC寄存器, 并初始化NVIC_InitTypeDef 结构体— 1.配置中断源(文件在STM32f10x.h中的IRQ中) 2.抢占优先级的值(根据优先级组配置) 3. 子优先级 4.内部使能.</li>
<li>编写中断服务函数!!! 名称一定不能写错,每个函数的名称在启动文件中,写错了会死循环!</li>
</ol>
<p>为了管理方便将中断全部写到 stm32f10x.it.c的函数中</p>
<hr>
<h1 id="EXTI-外部中断控制器"><a href="#EXTI-外部中断控制器" class="headerlink" title="EXTI- 外部中断控制器"></a>EXTI- 外部中断控制器</h1><p>EXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的20个中断/事件线。 每个中断/事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。EXTI可以实现对每个中断/事件线进行单独配置， 可以单独配置为中断或者事件，以及触发事件的属性。</p>
<h2 id="EXTI的功能框图"><a href="#EXTI的功能框图" class="headerlink" title="EXTI的功能框图"></a>EXTI的功能框图</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI002.png" alt="EXTI功能框图"></p>
<blockquote>
<p>一个斜杠并标注“20”字样，这个表示在控制器内部类似的信号线路有20个.</p>
</blockquote>
<p>EXTI有20个中断/事件线，每个GPIO都可以被设置为输入线，占用EXTI0至EXTI15， 还有另外七根用于特定的外设事件</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI01.png" alt="EXTI中断/事件线"></p>
<p>EXTI0至EXTI15用于GPIO</p>
<h2 id="EXTI初始化结构体"><a href="#EXTI初始化结构体" class="headerlink" title="EXTI初始化结构体"></a>EXTI初始化结构体</h2><p>标准库函数对每个外设都建立了一个初始化结构体，比如EXTI_InitTypeDef，结构体成员用于设置外设工作参数，并由外设初始化配置函数， 比如EXTI_Init()调用，这些设定参数将会设置外设相应的寄存器，达到配置外设工作环境的目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> EXTI_Line;                 <span class="comment">// 中断/事件线</span></span><br><span class="line">    EXTIMode_TypeDef EXTI_Mode;         <span class="comment">// EXTI模式</span></span><br><span class="line">    EXTITrigger_TypeDef EXTI_Trigger;   <span class="comment">// 触发类型</span></span><br><span class="line">    FunctionalState EXTI_LineCmd;       <span class="comment">// EXTI使能</span></span><br><span class="line">&#125; EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h2 id="外部中断控制实验设计"><a href="#外部中断控制实验设计" class="headerlink" title="外部中断控制实验设计"></a>外部中断控制实验设计</h2><p>我们设计使用外接的按键来作为触发源，使得控制器产生中断，并在中断服务函数中实现控制RGB彩灯的任务。</p>
<h3 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI004.png" alt="按键电路设计"></p>
<h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><ol>
<li>初始化用来产生中断的GPIO；</li>
<li>初始化EXTI；</li>
<li>配置NVIC；</li>
<li>编写中断服务函数；</li>
</ol>
<ul>
<li>bsp_exti.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.配置NVIC</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NVIC_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_initstruct;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选择中断的位置</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选择优先级的分组为1</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">	<span class="comment">// 设置主优先级</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 设置子优先级</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//使能</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	</span><br><span class="line">	NVIC_Init(&amp;NVIC_initstruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化用来产生中断的GPIO---键盘</span></span><br><span class="line"><span class="comment">//2.初始化EXTI</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_KEY1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	EXTI_InitTypeDef EXTI_initstruct;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_PIN; </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_PORT, &amp;GPIO_KEY1_initstruct);</span><br><span class="line">	<span class="comment">//初始化NVIC</span></span><br><span class="line">	NVIC_Config();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//时钟打开！！！</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">	<span class="comment">//选择输入线</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//因为是PA0，所以选择line0</span></span><br><span class="line">	EXTI_initstruct.EXTI_Line = EXTI_Line0;</span><br><span class="line">	<span class="comment">//调节模式为中断模式</span></span><br><span class="line">	EXTI_initstruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	<span class="comment">//触发方式设置为 上升触发</span></span><br><span class="line">	EXTI_initstruct.EXTI_Trigger = EXTI_Trigger_Rising;</span><br><span class="line">	<span class="comment">//使能</span></span><br><span class="line">	EXTI_initstruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_exti. h文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_EXTI.H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_EXTI.H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_KEY1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY1 的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_EXTI.H*/</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>stm32f10x_it.c 中添加</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_G_TOGGLE;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line0);		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main 函数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_exti.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                     <span class="comment">//初始化LED灯</span></span><br><span class="line">	EXTI_KEY1_Config();                         <span class="comment">//打开中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Systick-系统定时器"><a href="#Systick-系统定时器" class="headerlink" title="Systick-系统定时器"></a>Systick-系统定时器</h1><p>系统定时器：24 位 递减 存在于内核中，systick的寄存器如图所示</p>
<p>![image-20230103164648793](STM32学习- 中级/image-20230103164648793.png)</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic01.png" alt="SysTick寄存器汇总"></p>
<p>其中CTRL寄存器 又有四个位来控制</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic02.png" alt="SysTick控制及状态寄存器"></p>
<p>另外两个常用的寄存器 如下图所示：</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic03.png" alt="SysTick重装载数值寄存器"></p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic04.png" alt="SysTick当前数值寄存器"></p>
<h2 id="定时函数的设计"><a href="#定时函数的设计" class="headerlink" title="定时函数的设计"></a>定时函数的设计</h2><h2 id="硬件设计-1"><a href="#硬件设计-1" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>SysTick属于单片机内部的外设，不需要额外的硬件电路，剩下的只需一个LED灯即可。</p>
<p><strong>notice:</strong> 一般把systick 优先级设置成15(最低), 如果其他中断和systick的中断设置的优先级一样,比较系统默认的优先级.</p>
<h2 id="软件设计-1"><a href="#软件设计-1" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="定时时间的计算"><a href="#定时时间的计算" class="headerlink" title="定时时间的计算"></a>定时时间的计算</h3><ul>
<li>计时的时间只于 RELOAD和CLK 有关</li>
<li>CLK：可以设置成系统时钟(默认72M),或者系统时钟/8(9M), 由CTRL寄存器控制</li>
<li>RELOAD,由我们自己控制</li>
</ul>
<p>$t=reload×(1/CLK)$</p>
<p>常用1us 1ms,将clk设置成72M,reload设置成72,72000即可.</p>
<h3 id="systick的配置"><a href="#systick的配置" class="headerlink" title="systick的配置"></a>systick的配置</h3><p>在core_cm3.h文件中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __INLINE <span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">//检查 tick是否大于24位</span></span><br><span class="line">  <span class="keyword">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class="keyword">return</span> (<span class="number">1</span>);            </span><br><span class="line">  <span class="comment">//设置reload的值                                                             </span></span><br><span class="line">  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//设置优先级,默认为15(最低) </span></span><br><span class="line">  NVIC_SetPriority (SysTick_IRQn, (<span class="number">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* Load the SysTick Counter Value */</span>  </span><br><span class="line">  SysTick-&gt;VAL   = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">//  配置systick时钟为72M, 使能中断, 使能systick,然后开始计数</span></span><br><span class="line">  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | </span><br><span class="line">                   SysTick_CTRL_TICKINT_Msk   | </span><br><span class="line">                   SysTick_CTRL_ENABLE_Msk;                    </span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                                  <span class="comment">/* Function successful */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><ul>
<li>bsp_systick.c文件 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">__IO u32 TimingDelay; <span class="comment">//定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_us</span><span class="params">(__IO u32 nTime)</span> <span class="comment">//us延时</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	SysTick_Config(<span class="number">72</span>); <span class="comment">//1us 延时一次</span></span><br><span class="line">	TimingDelay = nTime; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(TimingDelay != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_ms</span><span class="params">(__IO u32 nTime)</span> <span class="comment">//ms延时</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	SysTick_Config(<span class="number">72000</span>); <span class="comment">//1ms 延时一次</span></span><br><span class="line">	TimingDelay = nTime;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(TimingDelay != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TimingDelay_Decrement</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//定义中段服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TimingDelay != <span class="number">0x00</span>) </span><br><span class="line">	&#123;</span><br><span class="line">        TimingDelay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_systick.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_SYSTICK,H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_SYSTICK,H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_us</span><span class="params">(__IO u32 nTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_ms</span><span class="params">(__IO u32 nTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TimingDelay_Decrement</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_SYSTICK,H*/</span></span></span><br></pre></td></tr></table></figure>

<p>中断服务函数 stm32f10x_it.c中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TimingDelay_Decrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();     <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>); <span class="comment">//定时器延时</span></span><br><span class="line">		LED_GREEN;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="串口通信的概念"><a href="#串口通信的概念" class="headerlink" title="串口通信的概念"></a>串口通信的概念</h2><p>这里和之前的51学习中的串口通信概念差不多</p>
<p>为了巩固这里再写一遍.</p>
<p>串口通信是硬件与硬件的信息传输</p>
<h3 id="串行与并行"><a href="#串行与并行" class="headerlink" title="串行与并行"></a>串行与并行</h3><p>假设传八个数据</p>
<ul>
<li>串行:一根线一位一位传输</li>
<li>并行: 8根线 同时传输八位</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>串行</th>
<th>并行</th>
</tr>
</thead>
<tbody><tr>
<td>通讯距离</td>
<td>远</td>
<td>近</td>
</tr>
<tr>
<td>抗干扰能力</td>
<td>强</td>
<td>弱</td>
</tr>
<tr>
<td>传输速率</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>成本</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="全双工-半双工-单工"><a href="#全双工-半双工-单工" class="headerlink" title="全双工 半双工 单工"></a>全双工 半双工 单工</h3><ul>
<li>全双工: 可以双向同时收发数据</li>
<li>半双工: 可以双向收发数据,但需要分时</li>
<li>单工: 只能单向收发数据</li>
</ul>
<h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h3><ul>
<li><p>同步: 有时钟信号都是同步</p>
</li>
<li><p> 异步:  不需要时钟信号</p>
</li>
</ul>
<p><strong>异步有 数据的起始位,主体数据,校验位,通信停止位</strong></p>
<h3 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h3><p>比特率: 每秒传输的<strong>二进制位数</strong>.</p>
<p>波特率: 每秒传输的<strong>码元</strong>个数.</p>
<p>码元-等于一个二进制位数时,比特率等于波特率</p>
<h2 id="串口的通信协议"><a href="#串口的通信协议" class="headerlink" title="串口的通信协议"></a>串口的通信协议</h2><p>不只是针对STM32,对于其他处理器也适用</p>
<p>物理层:硬件部分</p>
<p>协议层:软件部分</p>
<p>三个常用串口协议,主要是电平的区别,STM32的电平为TTL电平</p>
<h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p>电平高:-15V,低:+15V</p>
<p>一般由于工业设备,静电比较多,粉尘比较多,容错率比较高</p>
<h3 id="USB-转串口"><a href="#USB-转串口" class="headerlink" title="USB 转串口"></a>USB 转串口</h3><p>TTL 电平转USB电平</p>
<p>常用芯片:CH340等.</p>
<h3 id="原生的串口转串口"><a href="#原生的串口转串口" class="headerlink" title="原生的串口转串口"></a>原生的串口转串口</h3><p>都是TTL电平,不需要电平转换芯片</p>
<p>比如一些蓝牙模块,wifi模块</p>
<h3 id="串口的数据包"><a href="#串口的数据包" class="headerlink" title="串口的数据包"></a>串口的数据包</h3><p>起始位: 1个0电位</p>
<p>数据位</p>
<p>检验位: </p>
<p>奇校验(1的个数是奇数),偶校验,0校验(校验位总为0),1校验.</p>
<p>结束位</p>
<h2 id="STM32的串口的功能"><a href="#STM32的串口的功能" class="headerlink" title="STM32的串口的功能"></a>STM32的串口的功能</h2><h3 id="串口功能框图"><a href="#串口功能框图" class="headerlink" title="串口功能框图"></a>串口功能框图</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART008.png" alt="USART功能框图"></p>
<p>TX：数据发送</p>
<p>RX：数据接收</p>
<p>SCLK：同步通讯使用时用的时钟</p>
<p>n：请求, 一般不使用</p>
<p>![STM32F103VET6芯片的USART引脚](STM32学习- 中级/USART03.png)</p>
<p>各个串口的引脚图,如图所示</p>
<p>这里注意串口1和其他串口接的总线位置不一样,如果需要查找详细的串口位置,需要查找官方的数据手册查找串口位置.</p>
<h3 id="各个数据寄存器"><a href="#各个数据寄存器" class="headerlink" title="各个数据寄存器"></a>各个数据寄存器</h3><ul>
<li><p>数据寄存器寄存器: USART_DR: 九位有效,具体多少位由USART_CR1控制</p>
</li>
<li><p>控制寄存器1 USART_CR1: 1. M,1:8位;0:9位 2. PCE,PS 控制校验位, PE看是否出现错误 3.PEIE: 控制中断使能</p>
</li>
</ul>
<p>4.</p>
<ul>
<li><p>控制寄存器2 USART_CR2: STOP</p>
</li>
<li><p>状态寄存器: USART_SR: TEX,TC,观测是否发送完成</p>
</li>
<li><p>波特比率寄存器(USART_BRR) :前面11位是整数部分,后面3位是小数部分</p>
</li>
</ul>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART010.png" alt="波特率计算"></p>
<p>fck要注意是哪个串口,是72M还是36M,</p>
<p>小数部分即为 1/16, 所以只需呀将小数部分*16即可得到小数部分</p>
<h2 id="中断接收和发送的实验设计"><a href="#中断接收和发送的实验设计" class="headerlink" title="中断接收和发送的实验设计"></a>中断接收和发送的实验设计</h2><h3 id="硬件设计-2"><a href="#硬件设计-2" class="headerlink" title="硬件设计"></a>硬件设计</h3><p>usb转串口</p>
<p>电脑是USB,单片机是TTL电平,所以需要这个CH340转电平,这里需要安装CH340的驱动</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART011.png" alt="USB转串口硬件设计"></p>
<p>RX和TX的连接, 开发板上通过跳帽 连接PA9和PA10,</p>
<p>如果需要连接其他串口需要拔掉跳帽通过杜邦线连接到其他串口</p>
<h3 id="软件设计-2"><a href="#软件设计-2" class="headerlink" title="软件设计"></a>软件设计</h3><ul>
<li><strong>USART的结构体介绍</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> USART_BaudRate;            <span class="comment">/*!&lt;用来存放波特率,这里只需要填写115200即可</span></span><br><span class="line"><span class="comment">                                           The baud rate is computed using the following formula:</span></span><br><span class="line"><span class="comment">                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct-&gt;USART_BaudRate)))</span></span><br><span class="line"><span class="comment">                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_WordLength;          <span class="comment">/*!&lt; 用来设置字长是8位还是9位</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Word_Length */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_StopBits;            <span class="comment">/*!&lt;选择结束位是1个停止位还是0.5,1.5,2个.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Stop_Bits */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_Parity;              <span class="comment">/*!&lt; 配置校验位.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Parity</span></span><br><span class="line"><span class="comment">                                           @note When parity is enabled, the computed parity is inserted</span></span><br><span class="line"><span class="comment">                                                 at the MSB position of the transmitted data (9th bit when</span></span><br><span class="line"><span class="comment">                                                 the word length is set to 9 data bits; 8th bit when the</span></span><br><span class="line"><span class="comment">                                                 word length is set to 8 data bits). */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">uint16_t</span> USART_Mode;                <span class="comment">/*!&lt;控制是使能发送模式还是使能接收模式 is enabled or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_HardwareFlowControl; <span class="comment">/*!&lt;硬件控制流</span></span><br><span class="line"><span class="comment">                                           or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */</span></span><br><span class="line">&#125; USART_InitTypeDef;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面的结构体和同步通信有关,不需要初始化,如果不需要使用同步通信</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>主要用到的函数</strong></li>
</ul>
<ol>
<li>结构体初始化函数</li>
<li>数据发送函数</li>
<li>数据接收函数</li>
<li>中断状态位获取函数,中断清除等</li>
</ol>
<ul>
<li><strong>编程的要点</strong></li>
</ul>
<ol>
<li>初始化串口用到的GPIO, PA9,PA10</li>
<li>初始化串口</li>
<li>配置中断(接收中断,中断优先级)</li>
<li>使能串口</li>
<li>编写发送和接收函数</li>
<li>编写中断服务函数</li>
</ol>
<ul>
<li>bsp_usart.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PIN     GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PORT    GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_CLK     RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PIN     GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PORT    GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_BT   115200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CLK  RCC_APB2Periph_USART1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_IRQ  USART1_IRQn</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_USART_H*/</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_usart.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化串口用到的GPIO, PA9,PA10,初始化串口,配置中断(接收中断,中断优先级),使能串口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NVIC_Configuration</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 嵌套向量中断控制器组选择 */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置USART为中断源 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = USART_IRQ;</span><br><span class="line">    <span class="comment">/* 抢断优先级为1 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 子优先级为1 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    <span class="comment">/* 初始化配置NVIC */</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	<span class="comment">//配置Rx GPIO的PA9</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RX_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = RX_PIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(RX_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配值TX GPIO的PA10</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = TX_PIN;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(TX_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置USART1</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(USART_CLK , ENABLE);</span><br><span class="line">	</span><br><span class="line">	USART_InitStructure.USART_BaudRate = USART_BT;</span><br><span class="line">	</span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;</span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	</span><br><span class="line">	USART_Init(USART1 , &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置中断</span></span><br><span class="line">	</span><br><span class="line">	NVIC_Configuration(); <span class="comment">// 串口中断优先级配置</span></span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); <span class="comment">//Receive Data register not empty interrupt</span></span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1, ENABLE);<span class="comment">// 使能串口 配置UE位,相当于打开了总开关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送字符函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送1B函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendByte</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(pUSARTx, data);</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送 2B函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Send2Byte</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint16_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> data_h = (data &amp; <span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span> ;</span><br><span class="line">	<span class="type">uint8_t</span> data_l = (data &amp; <span class="number">0x00ff</span>);</span><br><span class="line">	</span><br><span class="line">	USART_SendByte(pUSARTx, data_h );</span><br><span class="line">	USART_SendByte(pUSARTx, data_l );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 8位数据的数组的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendARRAY</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> *<span class="built_in">array</span>,<span class="type">uint8_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		USART_SendByte(pUSARTx, <span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendSTR</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		USART_SendByte(pUSARTx, *(str+i));</span><br><span class="line">		i++;</span><br><span class="line">	&#125;<span class="keyword">while</span>(*(str+i) != <span class="string">&#x27;\0&#x27;</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向c库函数printf到串口，重定向后可使用printf函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 发送一个字节数据到串口 */</span></span><br><span class="line">    USART_SendData(USART1, (<span class="type">uint8_t</span>) ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待发送完毕 */</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 等待串口输入数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)USART_ReceiveData(USART1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在换串口时要注意"><a href="#在换串口时要注意" class="headerlink" title="在换串口时要注意"></a>在换串口时要注意</h3><ol>
<li>时钟的总线</li>
<li>GPIO的引脚</li>
<li>中断的中断源, 函数名</li>
<li>硬件上: 将USB转串口 用杜邦线连接到新的串口上</li>
</ol>
<h3 id="窗口接收"><a href="#窗口接收" class="headerlink" title="窗口接收"></a>窗口接收</h3><p>在stm32f10x_it.c中,添加中断, 这样有了一个接收文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ucTemp;</span><br><span class="line">    <span class="keyword">if</span> (USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET) </span><br><span class="line">	&#123;</span><br><span class="line">        ucTemp = USART_ReceiveData( USART1 );</span><br><span class="line">        USART_SendData(USART1,ucTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="串口控制LED的开与关"><a href="#串口控制LED的开与关" class="headerlink" title="串口控制LED的开与关"></a>串口控制LED的开与关</h2><p>只需在main.c文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ch;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	USART1_Config();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LED text\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LED = %c\n&quot;</span>,ch);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;LED = %c\n&quot;</span>,ch);</span><br><span class="line">		<span class="keyword">switch</span>(ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: LED_RED;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;红灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: LED_GREEN;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绿灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: LED_BLUE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;蓝灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: LED_YELLOW;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;黄灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: LED_PURPLE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;紫灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: LED_CYAN;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;青灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: LED_WHITE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;白灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: LED_RGBOFF;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;熄灭\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="DMA直接存储器的简介"><a href="#DMA直接存储器的简介" class="headerlink" title="DMA直接存储器的简介"></a>DMA直接存储器的简介</h2><p>DMA(Direct Memory Access)—直接存储器存取</p>
<p>作用: 把数据从一个地方搬到另一个地方, 而且不占用CPU</p>
<p>DMA1:有7个通道,可以实现P-&gt;M, M-&gt;P, M-&gt;M</p>
<p>DMA2(只存在于大容量,或者互联型中):有5个通道,可以实现P-&gt;M, M-&gt;P, M-&gt;M</p>
<h3 id="DMA的功能框图"><a href="#DMA的功能框图" class="headerlink" title="DMA的功能框图"></a>DMA的功能框图</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DMA002.png" alt="DMA框图"></p>
<ol>
<li>DMA请求,由发送端,外设等产生</li>
<li>DMA通道,DMA1有7条,DMA2有5条</li>
<li>当多个通道同时发送请求映射,仲裁器(<strong>第一阶段</strong>: 先由DMA_CCRx的 PL控制优先级决定, <strong>第二阶段</strong>: 优先级相同时再串口通道的编号优先级决定)</li>
</ol>
<p>如果不适用DMA,系统会默认使用CPU</p>
<h3 id="固件库编程"><a href="#固件库编程" class="headerlink" title="固件库编程"></a>固件库编程</h3><ol>
<li>DMA结构体成员</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralBaseAddr;   <span class="comment">// 外设地址 DMA_CPAR寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryBaseAddr;       <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_DIR;                  <span class="comment">// 传输方向 DMA_CCR 的DIR: P-&gt;M, M-&gt;P, </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_BufferSize;           <span class="comment">// 传输数目            </span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralInc;        <span class="comment">// 外设地址增量模式   DMA_CCR 的PINC,由普通和循环2个模式</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryInc;            <span class="comment">// 存储器地址增量模式  DMA_CCR 的MINC</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralDataSize;   <span class="comment">// 外设数据宽度    DMA_CCR 的MSIZE和PSIZE确定</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryDataSize;       <span class="comment">// 存储器数据宽度</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> DMA_Mode;                 <span class="comment">// 模式选择 DMA_ISR </span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_Priority;             <span class="comment">// 通道优先级</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_M2M;                  <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">&#125; DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>固件库函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="comment">//结构体初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="comment">//使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="M-to-M实验设计"><a href="#M-to-M实验设计" class="headerlink" title="M to M实验设计"></a>M to M实验设计</h2><p>FLASH to SRAM </p>
<h3 id="硬件设计-3"><a href="#硬件设计-3" class="headerlink" title="硬件设计"></a>硬件设计</h3><p>这里不需要其他的外设要求</p>
<h3 id="软件设计-3"><a href="#软件设计-3" class="headerlink" title="软件设计"></a>软件设计</h3><ul>
<li>编程要点: </li>
</ul>
<ol>
<li>定义一个变量存储再FLASH文件中， 再定义存储在SRAM中的变量</li>
<li>初始化DMA结构体</li>
<li>使能DMA时钟；</li>
<li>配置DMA数据参数；</li>
<li>使能DMA，进行传输；</li>
<li>等待传输完成，并对源数据和目标地址数据进行比较。</li>
</ol>
<ol>
<li>定义一个变量存储再FLASH文件中， 再定义存储在SRAM中的变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x01020304</span>,<span class="number">0x05060708</span>,<span class="number">0x090A0B0C</span>,<span class="number">0x0D0E0F10</span>,</span><br><span class="line">    <span class="number">0x11121314</span>,<span class="number">0x15161718</span>,<span class="number">0x191A1B1C</span>,<span class="number">0x1D1E1F20</span>,</span><br><span class="line">    <span class="number">0x21222324</span>,<span class="number">0x25262728</span>,<span class="number">0x292A2B2C</span>,<span class="number">0x2D2E2F30</span>,</span><br><span class="line">    <span class="number">0x31323334</span>,<span class="number">0x35363738</span>,<span class="number">0x393A3B3C</span>,<span class="number">0x3D3E3F40</span>,</span><br><span class="line">    <span class="number">0x41424344</span>,<span class="number">0x45464748</span>,<span class="number">0x494A4B4C</span>,<span class="number">0x4D4E4F50</span>,</span><br><span class="line">    <span class="number">0x51525354</span>,<span class="number">0x55565758</span>,<span class="number">0x595A5B5C</span>,<span class="number">0x5D5E5F60</span>,</span><br><span class="line">    <span class="number">0x61626364</span>,<span class="number">0x65666768</span>,<span class="number">0x696A6B6C</span>,<span class="number">0x6D6E6F70</span>,</span><br><span class="line">    <span class="number">0x71727374</span>,<span class="number">0x75767778</span>,<span class="number">0x797A7B7C</span>,<span class="number">0x7D7E7F80</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义DMA传输目标存储器</span></span><br><span class="line"><span class="comment">* 存储在内部的SRAM中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br></pre></td></tr></table></figure>

<p>2.初始化DMA结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_MTM_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打开DMA的时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(DMA1_CLK, ENABLE);</span><br><span class="line">	<span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)aSRC_Const_Buffer; <span class="comment">// 外设地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)aDST_Buffer;           <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                      <span class="comment">//从Flash 中 Sourse发出 </span></span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE;                         <span class="comment">//传输数目  </span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;         <span class="comment">// 外设地址增量模式：    使能</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 <span class="comment">// 存储器地址增量模式：  使能</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; <span class="comment">// 外设数据宽度：   一个字：32位</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;         <span class="comment">// 存储器数据宽度： 一个字：32位</span></span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           <span class="comment">// 模式选择 普通模式</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     <span class="comment">// 通道优先级 这里只有一个通道随意配置</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;                             <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结构体初始化以及使能</span></span><br><span class="line">	DMA_Init(DMA1_Channel, &amp;DMA_InitStructure);</span><br><span class="line">    DMA_ClearFlag(DMA1_FLAG);<span class="comment">// 给一个完成标志位</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.头文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DSP_DMA_MTM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DSP_DMA_MTM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE     32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_CLK        RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_Channel    DMA1_Channel6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_FLAG       DMA1_FLAG_HT6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_MTM_Config</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Buffercmp</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span>* pBuffer,<span class="type">uint32_t</span>* pBuffer1, <span class="type">uint16_t</span> BufferLength)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__DSP_DMA_MTM_H*/</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>数据比较函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">Buffercmp</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span>* pBuffer,</span></span><br><span class="line"><span class="params">                <span class="type">uint32_t</span>* pBuffer1, <span class="type">uint16_t</span> BufferLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 数据长度递减 */</span></span><br><span class="line">    <span class="keyword">while</span> (BufferLength--) &#123;</span><br><span class="line">        <span class="comment">/* 判断两个数据源是否对应相等 */</span></span><br><span class="line">        <span class="keyword">if</span> (*pBuffer != *pBuffer1) &#123;</span><br><span class="line">            <span class="comment">/* 对应数据源不相等马上退出函数，并返回0 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 递增两个数据源的地址指针 */</span></span><br><span class="line">        pBuffer++;</span><br><span class="line">        pBuffer1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 完成判断并且对应数据相对 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.主函数中显示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_dma_mtm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span> s = <span class="number">0</span>;</span><br><span class="line">	LED_GPIO_G_Config();</span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;</span><br><span class="line">	</span><br><span class="line">	DMA_MTM_Config();</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG)== RESET);</span><br><span class="line">	</span><br><span class="line">	s = Buffercmp(aSRC_Const_Buffer,aDST_Buffer, BUFFER_SIZE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_GREEN; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="M-to-P-实验设计"><a href="#M-to-P-实验设计" class="headerlink" title="M to P 实验设计"></a>M to P 实验设计</h2><p><strong>编程要点</strong></p>
<ol>
<li>初始化串口</li>
<li>配置DMA初始化结构体</li>
<li>编写主函数 开启串口,发送DMA请求</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.初始化串口只需要拷贝之前的初始化串口内容即可这里就不多写了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置DMA初始化结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_DMA_MTP_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打开DMA的时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(DMA1_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;            <span class="comment">// 外设地址  DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)SendBuff;              <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;                      <span class="comment">//从Flash 中 Sourse发出 </span></span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;                        <span class="comment">//传输数目  </span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;         <span class="comment">// 外设地址增量模式：    使能</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                  <span class="comment">// 存储器地址增量模式：  使能</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  <span class="comment">// 外设数据宽度：   一个字节：8位</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;      <span class="comment">// 存储器数据宽度： 一个字节：8位</span></span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           <span class="comment">// 模式选择 普通模式</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     <span class="comment">// 通道优先级 这里只有一个通道随意配置</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable ;                           <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结构体初始化以及使能</span></span><br><span class="line">	</span><br><span class="line">	DMA_Init(USART_DMA1_Channel, &amp;DMA_InitStructure);</span><br><span class="line">	DMA_ClearFlag(USART_DMA1_FLAG);</span><br><span class="line">	DMA_Cmd(USART_DMA1_Channel, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面再加一个printf的使用</span></span><br></pre></td></tr></table></figure>

<p>2.头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_DMA_MTP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_DMA_MTP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_CLK                 RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_DMA1_Channel       DMA1_Channel4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_DMA1_FLAG          DMA1_FLAG_HT4</span></span><br><span class="line"><span class="comment">// 外设寄存器地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  USART_DR_ADDRESS        (USART1_BASE+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENDBUFF_SIZE            5000</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面是配置串口使用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PIN     GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PORT    GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_CLK     RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PIN     GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PORT    GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_BT   115200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CLK  RCC_APB2Periph_USART1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_IRQ  USART1_IRQn</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_DMA_MTP_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/*__BSP_DMA_MTP_H*/</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.主函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_dma_mtp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;</span><br><span class="line">	</span><br><span class="line">	USART1_Config(); <span class="comment">//初始化串口</span></span><br><span class="line">	</span><br><span class="line">    USART1_DMA_MTP_Config(); <span class="comment">//初始化DMA</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;SENDBUFF_SIZE ; i++) <span class="comment">//把M 填满</span></span><br><span class="line">	&#123;</span><br><span class="line">		SendBuff[i]=<span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE); <span class="comment">//发送请求</span></span><br><span class="line">	<span class="comment">//现象可以边闪烁边发送数据</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_GREEN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="常用的存储器"><a href="#常用的存储器" class="headerlink" title="常用的存储器"></a>常用的存储器</h1><h2 id="存储器的种类"><a href="#存储器的种类" class="headerlink" title="存储器的种类"></a>存储器的种类</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag002.jpeg" alt="基本存储器种类"></p>
<p>易失性: 掉电数据是否容易丢失</p>
<p>易失性存储器:相对来说读写速度较快</p>
<ul>
<li>内存条</li>
</ul>
<p>不易失性存储器:</p>
<ul>
<li>硬盘</li>
</ul>
<h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>random access memory, 随意存储, 存储位置和读取速度没有关系</p>
<ul>
<li>DRAM: 动态的RAM (电容构成 )会通过不断充电放电,保持0/1的稳定</li>
<li>SRAM : 静态的RAM (锁存器构成)</li>
</ul>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag01.png" alt="DRAM与SRAM对比"></p>
<h3 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag02.png" alt="NOR_FLASH与NAND_FLASH特性对比"></p>
<p>FLASH存储器又称为闪存，它也是可重复擦写的储器</p>
<p>坏块：</p>
<p>XIP： 以字节的方式读写 直接读取数据</p>
<hr>
<h1 id="读写EEPROM"><a href="#读写EEPROM" class="headerlink" title="读写EEPROM"></a>读写EEPROM</h1><h2 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h2><h3 id="I2C的物理层"><a href="#I2C的物理层" class="headerlink" title="I2C的物理层"></a>I2C的物理层</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C002.png" alt="常见的I2C通讯系统"></p>
<ul>
<li>“总线”指多个设备共用的信号线。在一个I2C通讯总线中， 可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机。</li>
</ul>
<p>注意:iic在同一时间只能和一个设备通信</p>
<p>SCL：串行时钟线， </p>
<p>SDA： 双线串行数据线</p>
<p>每个连接到总线的数据都有一个独立地址，主机可以通过这个地址来实现不同地址的访问</p>
<p>总线通过接一个上拉店主街道电源. 使得处于不和主机通讯的空闲状态时,会输出高阻态. 方便实现线与 以及防止数据冲突 </p>
<blockquote>
<p>高阻态，目的是为了阻抗匹配，高阻态的时候获取外部信号的能力非常强，这样不会错过外部的电平变化</p>
</blockquote>
<blockquote>
<blockquote>
<p>需要高阻态。即：有一个设备输出高阻态时，总线就被拉成0V，若空闲为0，工作为1，则空闲设备相当于接地。后果是把总线上的电压拉成了0V，其他设备的电压会流入该设备，造成设备短路.主机由此知道总线正在被占用。而只有当所有设备都空闲，都输出高阻态时，总线才能检测到高电平（上拉电阻的作用）</p>
</blockquote>
</blockquote>
<p>I2C的传输速度: 标准模式传输速率为100kbit/s ，快速模式为400kbit/s ， 高速模式下可达 3.4Mbit/s，</p>
<h3 id="I2C的协议层"><a href="#I2C的协议层" class="headerlink" title="I2C的协议层"></a>I2C的协议层</h3><p>I2C的协议定义了 通讯的<strong>起始和停止信号</strong>、<strong>数据有效性</strong>、<strong>响应</strong>、<strong>仲裁</strong>、<strong>时钟同步</strong>和<strong>地址广播</strong>等环节。</p>
<h4 id="I2C的基本读写过程"><a href="#I2C的基本读写过程" class="headerlink" title="I2C的基本读写过程"></a>I2C的基本读写过程</h4><ol>
<li><strong>主机写数据到从机</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C003.jpg" alt="主机写数据到从机"></p>
<p>数据方向: 主机到从机</p>
<p>主机每传输一个字节, 从机会返回一个A的应答信号, 从机接收不了时会发送一个A非信号告诉中止</p>
<ol start="2">
<li><strong>主机从从机读数据</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C004.jpg" alt="主机由从机中读数据"></p>
<p>数据方向: 从机到总机</p>
<p>灰色部分由主机产生</p>
<ol start="3">
<li><strong>通讯复合格式</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C005.jpeg" alt="I2C通讯复合格式"></p>
<p>在第一次传输中， 主机通过SLAVE_ADDRESS寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与SLAVE_ADDRESS的区别)； 在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。</p>
<h4 id="通讯的起始和停止信号"><a href="#通讯的起始和停止信号" class="headerlink" title="通讯的起始和停止信号"></a>通讯的起始和停止信号</h4><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C008.jpg" alt="起始和停止信号"></p>
<p>起始信号: 在SCL为高电平时,SDA一个下降沿</p>
<p>停止信号: 在SCL为高电平时,SDA一个上升沿</p>
<h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C009.jpg" alt="数据有效性"></p>
<ul>
<li>一个时钟传输一个数据位, </li>
</ul>
<p>SCL位高电平时,表示读入SDA的数据</p>
<p>SCL为低电平时, 可以让SDA进行数据切换(有效防止数据传输的延时问题)</p>
<h4 id="地址及数据方向"><a href="#地址及数据方向" class="headerlink" title="地址及数据方向"></a>地址及数据方向</h4><p>I2C协议规定设备地址可以是7位或10位，实际中<strong>7位</strong>的地址应用比较广泛</p>
<p>紧跟设备地址的<strong>一个数据位</strong>用来表示数据传输方向, 确认是读还是写—0(读),1(写)</p>
<p>这里就构成了一个字节</p>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>I2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C011.jpg" alt="响应与非响应信号"></p>
<h2 id="STM32的I2C特性及架构"><a href="#STM32的I2C特性及架构" class="headerlink" title="STM32的I2C特性及架构"></a>STM32的I2C特性及架构</h2><ul>
<li>“软件模拟协议” </li>
</ul>
<p>直接控制STM32的两个GPIO引脚，分别用作SCL及SDA，按照上述信号的时序要求， 直接像控制LED灯那样控制引脚的输出(若是接收数据时则读取SDA电平)，就可以实现I2C通讯。</p>
<ul>
<li>“硬件协议” </li>
</ul>
<p>STM32的I2C片上外设专门负责实现I2C通讯协议， 只要配置好该外设，它就会自动根据协议要求产生通讯信号，收发数据并缓存起来， CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。</p>
<ul>
<li>STM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。</li>
</ul>
<h3 id="STM32的I2C架构剖析"><a href="#STM32的I2C架构剖析" class="headerlink" title="STM32的I2C架构剖析"></a>STM32的I2C架构剖析</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C012.jpg" alt="I2C架构图"></p>
<ol>
<li>通信引脚</li>
</ol>
<p>STM32F10x的I2C引脚,根据数据手册查出</p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>I2C1</th>
<th>I2C2</th>
</tr>
</thead>
<tbody><tr>
<td>SCL</td>
<td>PB6 / PB8(重映射)</td>
<td>PB10</td>
</tr>
<tr>
<td>SDA</td>
<td>PB7 / PB9(重映射)</td>
<td>PB11</td>
</tr>
</tbody></table>
<p>SMBA用的比较少这里不多做说明</p>
<ol start="2">
<li>时钟控制逻辑</li>
</ol>
<p>SCL线的时钟信号，由I2C接口根据时钟控制寄存器(CCR)控制， 控制的参数主要为时钟频率。配置I2C的CCR寄存器可修改通讯速率相关的参数：</p>
<p>此处计算只需要了解即可,后面计算时钟频率时有响应的库函数</p>
<p><strong>标准模式：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = CCR</em>T_{PCLK1}$</p>
<p><strong>快速模式中</strong> DUTY:  $T_{low}/T_{high}=2$  <strong>时：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = 2</em> CCR*T_{PCLK1}$</p>
<p><strong>快速模式中</strong> DUTY: $T_{low}/T_{high}=16/9$ <strong>时：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = 16</em>CCR*T_{PCLK1}$</p>
<p>PCLK1 表示 APB1上挂的时钟</p>
<ol start="3">
<li>数据控制逻辑</li>
</ol>
<p>数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC寄存器以及SDA数据线</p>
<p>比较器通过比较传来的地址和自身地址寄存器的内容进行比较,从而知道是不是叫自己</p>
<h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C013.jpg" alt="主发送器通讯过程"></p>
<p>这里是使用状态寄存器 I2C_SR1</p>
<p>响应的信号发送成功后, 数据状态寄存器会发生响应的状态</p>
<p>动作寄存器做一个内容之后, 下面的状态寄存器会做出响应的响应,确保工作的状态</p>
<p>因为STM32的传输速度比I2C速度快很多</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C014.jpg" alt="主接收器过程"></p>
<p>主接收器和主发送器的内容几乎一样</p>
<p>$A^{(1)}$是表示STM32接收到了数据做出的响应</p>
<p>EV7_1,要比EV7多设置一点步骤</p>
<p>NA: 非应答响应</p>
<h2 id="I2C的库函数"><a href="#I2C的库函数" class="headerlink" title="I2C的库函数"></a>I2C的库函数</h2><ol>
<li>I2C的初始化结构体</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> I2C_ClockSpeed;       <span class="comment">/*!&lt; 设置SCL时钟频率，此值要低于400000*/</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_Mode;             <span class="comment">/*!&lt; 指定工作模式，可选I2C模式及SMBUS模式 */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_DutyCycle;        <span class="comment">/*指定时钟占空比，可选low/high = 2:1及16:9模式*/</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_OwnAddress1;      <span class="comment">/*!&lt; 指定自身的I2C设备地址 */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_Ack;                 <span class="comment">/*!&lt; 使能或关闭响应(一般都要使能) */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_AcknowledgedAddress; <span class="comment">/*!&lt; 指定地址的长度，可为7位及10位 */</span></span><br><span class="line">&#125; I2C_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h2 id="I2C—读写EEPROM实验"><a href="#I2C—读写EEPROM实验" class="headerlink" title="I2C—读写EEPROM实验"></a>I2C—读写EEPROM实验</h2><h3 id="硬件设计-4"><a href="#硬件设计-4" class="headerlink" title="硬件设计"></a>硬件设计</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C015.png" alt="EEPROM硬件连接图"></p>
<h3 id="软件设计-4"><a href="#软件设计-4" class="headerlink" title="软件设计"></a>软件设计</h3><p>编程要点:</p>
<ol>
<li><p>初始化IIC相关的GPIO – PB6， PB7</p>
</li>
<li><p>配置IIC外设的工作模式</p>
</li>
<li><p>编写IIC写入EEPROM Byte write        的函数</p>
</li>
<li><p>编写IIC读入EEPROM RANDOM read的函数</p>
</li>
<li><p>使用read函数以及write函数进行校验</p>
</li>
<li><p>编写初始化结构体</p>
</li>
</ol>
<p><code>.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_i2c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置SCL GPIO的PA9</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(SCL_CLK , ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = SCL_PIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(SCL_PORT , &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配值SAD GPIO的PA10</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = SAD_PIN;</span><br><span class="line">	GPIO_Init(SAD_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置I2C1</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(I2C_CLK , ENABLE);</span><br><span class="line"></span><br><span class="line">	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit ;</span><br><span class="line">	I2C_InitStructure.I2C_ClockSpeed = I2C_BT;</span><br><span class="line">	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class="line">	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">	I2C_InitStructure.I2C_OwnAddress1 = I2Cx_OWN_ADDRESS7;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化与使能</span></span><br><span class="line">	I2C_Init(I2C1, &amp;I2C_InitStructure );</span><br><span class="line">	I2C_Cmd(I2C1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>.h</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//PB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_PIN     GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_PORT    GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_CLK     RCC_APB2Periph_GPIOB</span></span><br><span class="line"><span class="comment">//PB7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAD_PIN     GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAD_PORT    GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_BT   400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLK  RCC_APB1Periph_I2C1</span></span><br><span class="line"><span class="comment">/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2Cx_OWN_ADDRESS7      0X0A</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_USART_H*/</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写 字节发送函数</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C013.jpg" alt="主发送器通讯过程"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//关于这函数的编写由于有点复杂，所以先不放在这了，仔细看给的工程文件代码</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于后面是关于数据存储FLASH，和数据的发送</p>
<p>关于这块内容，数电还没有跟上，而且和EEPROM有比较强的相似性</p>
<p>打算后面用到了再回过头学习，接下来先学习高级篇</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%94%B5%E8%B5%9B%E5%87%86%E5%A4%87/">电赛准备</a><a class="post-meta__tags" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a></div><div class="post_share"><div class="social-share" data-image="https://b.zhutix.com/bizhi/geometrix/53.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/"><img class="next-cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STM32学习（入门篇）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记"><img class="cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-22</div><div class="title">51单片机学习笔记</div></div></a></div><div><a href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/" title="STM32学习（入门篇）"><img class="cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-29</div><div class="title">STM32学习（入门篇）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81Nzc4Ny8zNDI1MA"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img.166.net/reunionpub/ds/nbot/20210317/232642-0ohjgimbna.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Carl</div><div class="author-info__description">卡卡的博客，欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Sugarchen7"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Sugarchen7" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1515631876@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RCC%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">RCC的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RCC%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">RCC的功能框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HSI-HSE-%E6%9D%A5%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F"><span class="toc-number">1.2.</span> <span class="toc-text">HSI&#x2F;HSE 来配置系统时钟</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">2.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">中断的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E7%AE%A1%E7%90%86-NVIC"><span class="toc-number">2.2.</span> <span class="toc-text">中断的管理-NVIC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NVIC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">NVIC寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.</span> <span class="toc-text">中断优先级的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%88%86%E7%BB%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">优先级的分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BC%96%E7%A8%8B%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.4.</span> <span class="toc-text">中断编程的步骤</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EXTI-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">EXTI- 外部中断控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EXTI%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">EXTI的功能框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXTI%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">3.2.</span> <span class="toc-text">EXTI初始化结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.</span> <span class="toc-text">外部中断控制实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.1.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.2.</span> <span class="toc-text">软件设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Systick-%E7%B3%BB%E7%BB%9F%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">Systick-系统定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">定时函数的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">4.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">4.3.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E6%97%B6%E9%97%B4%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">4.3.1.</span> <span class="toc-text">定时时间的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#systick%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">4.3.2.</span> <span class="toc-text">systick的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-number">4.3.3.</span> <span class="toc-text">程序编写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">5.</span> <span class="toc-text">串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">串口通信的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">5.1.1.</span> <span class="toc-text">串行与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%8F%8C%E5%B7%A5-%E5%8D%8A%E5%8F%8C%E5%B7%A5-%E5%8D%95%E5%B7%A5"><span class="toc-number">5.1.2.</span> <span class="toc-text">全双工 半双工 单工</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5"><span class="toc-number">5.1.3.</span> <span class="toc-text">同步 异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%80%9F%E7%8E%87"><span class="toc-number">5.1.4.</span> <span class="toc-text">通信速率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">串口的通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RS-232"><span class="toc-number">5.2.1.</span> <span class="toc-text">RS-232</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-%E8%BD%AC%E4%B8%B2%E5%8F%A3"><span class="toc-number">5.2.2.</span> <span class="toc-text">USB 转串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E7%9A%84%E4%B8%B2%E5%8F%A3%E8%BD%AC%E4%B8%B2%E5%8F%A3"><span class="toc-number">5.2.3.</span> <span class="toc-text">原生的串口转串口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">5.2.4.</span> <span class="toc-text">串口的数据包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E7%9A%84%E4%B8%B2%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">5.3.</span> <span class="toc-text">STM32的串口的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE"><span class="toc-number">5.3.1.</span> <span class="toc-text">串口功能框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">5.3.2.</span> <span class="toc-text">各个数据寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E7%9A%84%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.4.</span> <span class="toc-text">中断接收和发送的实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">5.4.1.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">5.4.2.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%8D%A2%E4%B8%B2%E5%8F%A3%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F"><span class="toc-number">5.4.3.</span> <span class="toc-text">在换串口时要注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E6%8E%A5%E6%94%B6"><span class="toc-number">5.4.4.</span> <span class="toc-text">窗口接收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A7%E5%88%B6LED%E7%9A%84%E5%BC%80%E4%B8%8E%E5%85%B3"><span class="toc-number">5.5.</span> <span class="toc-text">串口控制LED的开与关</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DMA"><span class="toc-number">6.</span> <span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">DMA直接存储器的简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE"><span class="toc-number">6.1.1.</span> <span class="toc-text">DMA的功能框图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%BC%96%E7%A8%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">固件库编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#M-to-M%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.2.</span> <span class="toc-text">M to M实验设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">6.2.1.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">6.2.2.</span> <span class="toc-text">软件设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#M-to-P-%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.3.</span> <span class="toc-text">M to P 实验设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">常用的存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">存储器的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAM"><span class="toc-number">7.1.1.</span> <span class="toc-text">RAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FLASH"><span class="toc-number">7.1.2.</span> <span class="toc-text">FLASH</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E5%86%99EEPROM"><span class="toc-number">8.</span> <span class="toc-text">读写EEPROM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.1.</span> <span class="toc-text">I2C协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E7%9A%84%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">8.1.1.</span> <span class="toc-text">I2C的物理层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%B1%82"><span class="toc-number">8.1.2.</span> <span class="toc-text">I2C的协议层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%BB%E5%86%99%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">I2C的基本读写过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%92%8C%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">通讯的起始和停止信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">数据有效性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%8A%E6%95%B0%E6%8D%AE%E6%96%B9%E5%90%91"><span class="toc-number">8.1.2.4.</span> <span class="toc-text">地址及数据方向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94"><span class="toc-number">8.1.2.5.</span> <span class="toc-text">响应</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E7%9A%84I2C%E7%89%B9%E6%80%A7%E5%8F%8A%E6%9E%B6%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">STM32的I2C特性及架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STM32%E7%9A%84I2C%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90"><span class="toc-number">8.2.1.</span> <span class="toc-text">STM32的I2C架构剖析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B"><span class="toc-number">8.3.</span> <span class="toc-text">通讯过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E7%9A%84%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">I2C的库函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C%E2%80%94%E8%AF%BB%E5%86%99EEPROM%E5%AE%9E%E9%AA%8C"><span class="toc-number">8.5.</span> <span class="toc-text">I2C—读写EEPROM实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">8.5.1.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">8.5.2.</span> <span class="toc-text">软件设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">9.</span> <span class="toc-text">注意</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/" title="STM32学习（中级篇）"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32学习（中级篇）"/></a><div class="content"><a class="title" href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/" title="STM32学习（中级篇）">STM32学习（中级篇）</a><time datetime="2023-01-08T13:16:41.000Z" title="发表于 2023-01-08 21:16:41">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/" title="STM32学习（入门篇）"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32学习（入门篇）"/></a><div class="content"><a class="title" href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/" title="STM32学习（入门篇）">STM32学习（入门篇）</a><time datetime="2022-12-29T14:39:12.000Z" title="发表于 2022-12-29 22:39:12">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="51单片机学习笔记"/></a><div class="content"><a class="title" href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记">51单片机学习笔记</a><time datetime="2022-12-22T13:27:08.000Z" title="发表于 2022-12-22 21:27:08">2022-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/20/LaTex%E7%9A%84%E4%BD%BF%E7%94%A8/" title="LaTex的基本语法"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LaTex的基本语法"/></a><div class="content"><a class="title" href="/2022/12/20/LaTex%E7%9A%84%E4%BD%BF%E7%94%A8/" title="LaTex的基本语法">LaTex的基本语法</a><time datetime="2022-12-20T05:09:16.000Z" title="发表于 2022-12-20 13:09:16">2022-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown-Typora/" title="如何使用Markdown+ Typora"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何使用Markdown+ Typora"/></a><div class="content"><a class="title" href="/2022/12/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown-Typora/" title="如何使用Markdown+ Typora">如何使用Markdown+ Typora</a><time datetime="2022-12-18T07:04:09.000Z" title="发表于 2022-12-18 15:04:09">2022-12-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Carl</div><div class="footer_custom_text">一个人能走多远关键在于与谁同行，我愿用跨越山海的陪伴换来你金钱的点赞👍</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="8008663318" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>