<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Python语言进阶 | Carl's blog</title><meta name="author" content="Carl"><meta name="copyright" content="Carl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="python语言进阶中介绍了，异常处理，迭代器，推导式，生成器和装饰器，是Python语言中比较难的语法部分">
<meta property="og:type" content="article">
<meta property="og:title" content="Python语言进阶">
<meta property="og:url" content="http://carl.github.io/2023/01/13/Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="Carl&#39;s blog">
<meta property="og:description" content="python语言进阶中介绍了，异常处理，迭代器，推导式，生成器和装饰器，是Python语言中比较难的语法部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b.zhutix.com/bizhi/geometrix/53.jpg">
<meta property="article:published_time" content="2023-01-13T08:30:25.000Z">
<meta property="article:modified_time" content="2023-01-13T08:34:49.422Z">
<meta property="article:author" content="Carl">
<meta property="article:tag" content="数模准备">
<meta property="article:tag" content="语言基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b.zhutix.com/bizhi/geometrix/53.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://carl.github.io/2023/01/13/Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python语言进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-13 16:34:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img.166.net/reunionpub/ds/nbot/20210317/232642-0ohjgimbna.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://b.zhutix.com/bizhi/geometrix/53.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Carl's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python语言进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-13T08:30:25.000Z" title="发表于 2023-01-13 16:30:25">2023-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-13T08:34:49.422Z" title="更新于 2023-01-13 16:34:49">2023-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python语言进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul>
<li>首先我们要理解什么叫做**”异常”**？<ul>
<li>在程序运行过程中，总会遇到各种各样的问题和错误。</li>
<li>有些错误是我们编写代码时自己造成的：<ul>
<li>比如语法错误、调用错误，甚至逻辑错误。</li>
</ul>
</li>
<li>还有一些错误，则是不可预料的错误，但是完全有可能发生的：<ul>
<li>比如文件不存在、磁盘空间不足、网络堵塞、系统错误等等。</li>
</ul>
</li>
<li>这些导致程序在运行过程中出现异常中断和退出的错误，我们统称为异常。大多数的异常都不会被程序处理，而是以错误信息的形式展现出来。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0不能被作为除数</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span></span><br><span class="line">异常信息为：ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

<ul>
<li><p>异常的分类：</p>
<ul>
<li>异常有很多种类型，Python内置了几十种常见的异常，无需特别导入，直接就可使用。</li>
<li>需要注意的是，所有的异常都是异常类，首字母是大写的！</li>
</ul>
</li>
<li><p>异常的危害：</p>
<ul>
<li>如果程序中一旦出现了异常的语句代码，则该异常就会立即中断程序的运行！</li>
</ul>
</li>
<li><p>因此：</p>
<ul>
<li>为了保证程序的正常运行，提高程序健壮性和可用性。我们应当尽量考虑全面，将可能出现的异常进行处理，而不是留在那里，任由其发生。</li>
</ul>
</li>
<li><p>python处理异常的机制：</p>
<ul>
<li>Python内置了一套try…except…finally（else）…的异常处理机制，来帮助我们进行异常处理。其基本语法是：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>机制说明：</p>
<ul>
<li><p>首先，执行try子句（在关键字try和关键字except之间的语句）</p>
</li>
<li><p>如果没有异常发生，忽略except子句，try子句执行后结束。</p>
</li>
<li><p>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之前的语句正常执行&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之后的语句不会被执行&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果程序发生的异常不在你的捕获列表中，那么依然会抛出别的异常:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未捕获到异常，程序直接报错</span></span><br><span class="line">s1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>(s1)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> ex:    <span class="comment"># 本例为非法值异常，而你只捕获索引异常</span></span><br><span class="line">    <span class="built_in">print</span>(ex)</span><br></pre></td></tr></table></figure>

<ul>
<li>Exception是什么？<ul>
<li>在Python的异常中，有一个通用异常：<code>Exception</code>，它可以捕获任意异常。</li>
<li>思考：那么既然有这个什么都能管的异常，其他诸如OSError、ZeroDivisionError的异常是不是就可以不需要了？<ul>
<li>当然不是！很多时候程序只会弹出那么几个异常，没有必要针对所有的异常进行捕获，那样的效率会很低。另外，根据不同的异常种类，制定不同的处理措施，用于准确判断错误类型，存储错误日志，都是非常有必要甚至强制的。</li>
</ul>
</li>
<li>常见的异常类型：</li>
</ul>
<table>
<thead>
<tr>
<th>异常名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>AttributeError</td>
<td>试图访问一个对象没有的属性</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出异常</td>
</tr>
<tr>
<td>ImportError</td>
<td>无法引入模块或包；多是路径问题或名称错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>IndexError</td>
<td>下标索引错误</td>
</tr>
<tr>
<td>KeyError</td>
<td>试图访问不存在的键</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>Ctrl+C被按下，键盘终止输入</td>
</tr>
<tr>
<td>NameError</td>
<td>使用未定义的变量</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>语法错误</td>
</tr>
<tr>
<td>TypeError</td>
<td>传入对象的类型与要求的不符合</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>试图访问一个还未被设置的局部变量</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入一个调用者不期望的值，即使值的类型是正确的</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统执行错误</td>
</tr>
</tbody></table>
<ul>
<li>异常的基本使用：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    1/0</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line">print(&#x27;我是异常代码后序的操作代码！&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python的异常机制具有嵌套处理的能力:</p>
<ul>
<li>比如在函数f3()调用f2()，f2()调用f1()，虽然是在f1()出错了，但只需要在f3()进行异常捕获，不需要每一层都捕获异常</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#函数嵌套出现异常</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line">f3()</span><br></pre></td></tr></table></figure>

<ul>
<li>函数嵌套处理异常：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f3()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>try…excetion的嵌套</p>
<ul>
<li><p>之前我们说过，不是只使用通用的异常类Exception就万事大吉了，为了效率问题，我们需要对常见的异常信息进行精准的捕获，那么如果异常出现在用户层的话，则就需要对用户操作可能会出现的异常进行判断然后精准捕获了，如何操作呢？</p>
<ul>
<li>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。也就是前面说的嵌套处理能力。直到程序最顶端如果还没有被捕获，那么将弹出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发生异常之前的语句正常执行&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发生异常之后的语句不会被执行&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;里层没有抓好，只能辛苦我外层了&quot;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- 或者使用一个try和多个except的形式：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之前的语句正常执行&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之后的语句不会被执行&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是第一个抓取到除零异常的&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> (ValueError,ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是备胎&quot;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- 或者在except后面跟一个元组，元组中包含多个异常类
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>finally和else子句</p>
<ul>
<li><p><code>try except</code>语法还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行：</p>
</li>
<li><p>同样的，还有一个可选的finally子句。无论try执行情况和except异常触发情况如何，finally子句都会被执行！</p>
</li>
<li><p>当然，else和finally同时存在时：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;else&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finally&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主动抛出异常：raise</p>
<ul>
<li><p>很多时候，我们需要主动抛出一个异常。Python内置了一个关键字<code>raise</code>，可以主动触发异常。</p>
</li>
<li><p>疑问：</p>
<ul>
<li>为什么要自己主动抛出异常？不嫌多事么？因为有的时候，你需要记录错误信息，然后将异常继续往上层传递，让上层去处理异常，如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    divNum = <span class="built_in">input</span>(<span class="string">&#x27;enter a divNum:&#x27;</span>)</span><br><span class="line">    divNum = <span class="built_in">int</span>(divNum)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span>/divNum</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;记录异常日志： &quot;</span>, ex)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;但是我自己无法处理，只能继续抛出，看看上层能否处理（甩锅）&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;非法录入&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;用户录入非法数据，请重新输入！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- 有时候，你需要主动弹出异常，作为警告或特殊处理：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用户录入自己的性别：1表示男，2表示女</span></span><br><span class="line">sex = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please input a number: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> sex == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是个男人！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> sex == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是个女人！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;好像有什么不符合常理的事情发生了！！&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;非法的输入&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是个人妖！&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>在介绍迭代器之前，先说明下迭代的概念：</p>
<ul>
<li><p>迭代：</p>
<ul>
<li>通过for循环遍历”对象”的每一个元素的过程。</li>
<li>这里的对象指的就是可迭代对象。因此记住：for循环遍历的只能是可迭代的对象。</li>
</ul>
</li>
<li><p>可迭代类型的对象：</p>
<ul>
<li>在Python中，list/tuple/string/dict/set/bytes都是可以迭代的数据类型/可迭代对象！</li>
</ul>
</li>
<li><p>如何判定一个对象是否为可迭代对象呢？</p>
<ul>
<li>可以通过collections模块的Iterable类型作用在isinstance中来判断一个对象是否可迭代</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>,Iterable))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>迭代器</p>
<ul>
<li><p>迭代器是一种可以被遍历的对象(可迭代类型对象)，并且能作用于next()函数。</p>
</li>
<li><p>性质：</p>
<ul>
<li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往后遍历不能回溯，不像列表，你随时可以取后面的数据，也可以返回头取前面的数据。</li>
</ul>
</li>
<li><p>迭代器通常要实现两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</p>
</li>
<li><p>注意：</p>
<ul>
<li>可迭代对象并不一定是迭代器！</li>
<li>常见的数据结构，字符串、列表、元组都属于可迭代对象，并不是迭代器！</li>
</ul>
</li>
<li><p>如何创建一个迭代器呢？</p>
<ul>
<li>字符串，列表或元组对象，甚至自定义对象都可用于创建迭代器：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用Python内置的iter()方法创建迭代器对象</span></span><br><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)</span><br></pre></td></tr></table></figure>

<pre><code>- 可以使用type查看列表和迭代器类型的不同：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(lis),<span class="built_in">type</span>(it))</span><br></pre></td></tr></table></figure>

<pre><code>- 使用next()方法获取迭代器的下一个元素：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>

<pre><code>- 使用for循环遍历迭代器：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lis = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)          <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:            <span class="comment"># 使用for循环遍历迭代对象</span></span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思考：迭代器的作用是什么？</p>
<ul>
<li>可迭代对象的优缺点：<ul>
<li>可迭代对象的优点：可以直观查看里面的对象，如直接查看列表的内容</li>
<li>可迭代对象缺点：全部内容要加载至内存中，故占用内存</li>
</ul>
</li>
<li>迭代器的优缺点：<ul>
<li>优点：<ul>
<li>提供了一种通用不依赖索引的迭代取值方式；</li>
<li>节省内存，迭代器在内存中相当于只占一个数据的空间：因为每次取值都上一条数据会在内存释放，加载当前的此条数据。</li>
</ul>
</li>
<li>缺点：<ul>
<li>因为有next方法，即只能往后取值,不能往前，取值不如按照索引的方式灵活，不能取指定的某一个值</li>
<li>无法预测迭代器的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：迭代器和可迭代的区别？</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.凡是可作用于for循环的对象都是可迭代类型；</span><br><span class="line"></span><br><span class="line">2.凡是可作用于next()函数的对象都是迭代器类型；</span><br><span class="line"></span><br><span class="line">3.list、dict、str等是可迭代的但不是迭代器，因为next()函数无法调用它们。可以通过iter()函数将它们转换成迭代器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义迭代器</p>
<ul>
<li><p>很多时候，为了让我们自己写的类成为一个迭代器，需要在类里实现<code>__iter__()</code>和<code>__next__()</code>方法</p>
<ul>
<li>实际上，在使用next()函数的时候，调用的就是迭代器对象的<code>__next__</code>方法</li>
<li>python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现<code>__iter__</code>方法，而<code>__iter__</code>方法要返回一个迭代器。<ul>
<li>迭代器自身正是一个迭代器，所以迭代器的<code>__iter__</code>方法返回自身即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#迭代生成指定范围数列的平方值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):  <span class="comment"># 迭代起始、终止位</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):     <span class="comment"># 返回自身的迭代器, 就是返回自己</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):     <span class="comment"># 调用next()函数 重写父类方法: 返回下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> self.start &gt; self.stop:   <span class="comment"># 结尾时抛出异常</span></span><br><span class="line">            <span class="keyword">raise</span> (StopIteration)</span><br><span class="line">        item = self.start**<span class="number">2</span></span><br><span class="line">        self.start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>菲波那切数列实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#菲波那切数列实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FbnList</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,num</span>):</span><br><span class="line">        self.num = num</span><br><span class="line">        </span><br><span class="line">        self.index = <span class="number">0</span> <span class="comment">#当前生成了第几位数</span></span><br><span class="line">        <span class="comment">#初始化前三位值</span></span><br><span class="line">        self.num1 = <span class="number">0</span></span><br><span class="line">        self.num2 = <span class="number">1</span></span><br><span class="line">        self.num3 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &gt;= self.num:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        value = self.num1</span><br><span class="line">        self.num1,self.num2,self.num3 = self.num2,self.num3,self.num2+self.num3</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数为要生成多少位菲波那切数列的值</span></span><br><span class="line">fbn = FbnList(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fbn:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>实现类似iter功能的类：可以使得将列表转换成迭代器</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List_A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,alist</span>):</span><br><span class="line">        self.alist = alist</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &lt; <span class="built_in">len</span>(self.alist):</span><br><span class="line">            value = self.alist[self.index]</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">a = List_A([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><ul>
<li><p>Python语言有一种独特的语法，相当于语法糖的存在，可以帮你在某些场合写出比较精简酷炫的代码。但没有它，也不会有太多的影响。Python语言有几种不同类型的推导式</p>
<ul>
<li>列表推导式</li>
<li>字典推导式</li>
<li>集合推导式</li>
<li>元组推导式?</li>
</ul>
</li>
<li><p>列表推导式</p>
<ul>
<li>列表推导式是一种快速生成列表的方式。其形式是用方括号括起来的一段语句，如下例子所示：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alist = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="comment">############上下两组代码是等效</span></span><br><span class="line">alist = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    alist.append(x*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li>列表推导式要这么理解，首先执行for循环，对于遍历的每一个x，代入x*x表达式中进行运算，将运算结果逐一添加到一个新列表内，循环结束，得到最终列表。它相当于下面的代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alist = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    alist.append(x*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：<ul>
<li>列表推导式为我们提供了一种在一行内实现较为复杂逻辑的生成列表的方法。其核心语法是用中括号[]将生成逻辑封装起来。当然列表推导式也有多样用法</li>
</ul>
</li>
<li>增加条件语句</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alist = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"></span><br><span class="line"><span class="comment">##############相当于如下代码</span></span><br><span class="line">alist_1 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        alist_1.append(x*x)</span><br><span class="line"><span class="built_in">print</span>(alist_1)</span><br></pre></td></tr></table></figure>

<ul>
<li>多重循环</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">re = [a+b <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(re)</span><br><span class="line"></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line">alist = []</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>:</span><br><span class="line">        alist.append(a+b)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字典推导式</p>
<ul>
<li>既然使用中括号[]可以编写列表推导式，那么使用大括号呢？你猜对了！使用大括号{}可以制造字典推导式！</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;x:x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dic = &#123;&#125;</span></span><br><span class="line"><span class="string">for x in [2,4,6]:</span></span><br><span class="line"><span class="string">    dic[x] = x**2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意x: x**2的写法，中间的冒号，表示左边的是key右边的是value。</p>
</li>
<li><p>集合推导式</p>
<ul>
<li>大括号除了能用作字典推导式，还可以用作集合推导式，两者仅仅在细微处有差别。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>元组推导式</p>
<ul>
<li>使用了中括号和大括号，那么使用圆括号，是不是元组推导式？想法不错，但事实却没有。圆括号在Python中被用作生成器的语法了，很快我们就会讲到，没有元组推导式。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#&lt;generator object &lt;genexpr&gt; at 0x102f45970&gt;</span></span><br><span class="line"><span class="comment">#返回的是一个生成器对象</span></span><br></pre></td></tr></table></figure>


<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul>
<li><p>在Python这门语言中，生成器毫无疑问是最有用的特性之一。</p>
</li>
<li><p>与此同时，也是使用的最不广泛的Python特性之一</p>
</li>
<li><p>究其原因，主要是因为，在其他主流语言里面没有生成器的概念。正是由于生成器是一个“新”的东西，所以，它一方面没有引起广大工程师的重视，另一方面，也增加了工程师的学习成本，最终导致大家错过了Python中如此有用的一个特性。那到底什么是生成器呢？</p>
</li>
<li><p>有时候，序列或集合内的元素的个数非常巨大，如果全制造出来并放入内存，对计算机的压力是非常大的。</p>
<ul>
<li>比如，假设需要获取一个10**20次方如此巨大的数据序列，把每一个数都生成出来，并放在一个内存的列表内，如果使用这种粗暴的方式，你能确保你的计算机会有如此大的内存么？</li>
<li>那么如果元素可以按照某种算法推算出来，需要该元素的话那就计算到哪个元素，那么就可以在循环的过程中不断推算出后续的元素，而不必创建完整的元素集合，从而节省大量的空间。在Python中，这种一边循环一边计算出元素的机制，称为生成器：generator。</li>
<li>因此：<strong>生成器是一种特殊的迭代器，生成器自动实现了“迭代器协议”（即__iter__和next方法）</strong>，不需要再手动实现两方法。</li>
</ul>
</li>
<li><p><strong>下面，我们一起来看看如何创建一个生成器！2种方式</strong></p>
<ul>
<li>生成器推导式(忽略)</li>
<li>for循环,yield关键字</li>
</ul>
</li>
<li><p>生成器推导式：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#生成器对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过next()函数获得generator的下一个返回值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br></pre></td></tr></table></figure>

<ul>
<li>但更多情况下，我们使用for循环创建生成器：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>yield关键字创建生成器(重点)</p>
<ul>
<li><p>在 Python中，使用yield返回的函数会变成一个生成器（generator）。 在调用生成器的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行next()方法时从当前位置继续运行。下面重点理解yield关键字的使用：</p>
<ul>
<li>yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器</li>
<li>当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象</li>
<li>当你使用for进行遍历的时候或者调用next函数后，函数中的代码才会执行</li>
</ul>
</li>
<li><p>简单示例代码：函数体通过for循环结合yield返回一个生成器</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createGenerator</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是循环体！&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> i*i <span class="comment">#使用了yield返回的结果而不是用return</span></span><br><span class="line">g = createGenerator()</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment">#&lt;generator object createGenerator at 0x104bc5970&gt;</span></span><br><span class="line">v1 = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line"><span class="comment">#我是循环体！</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">v2 = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="built_in">print</span>(v2)</span><br><span class="line"><span class="comment">#我是循环体！</span></span><br><span class="line"><span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>思考：下述函数的执行结果是什么？</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">yieldTest</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        temp = <span class="keyword">yield</span> i <span class="comment">#赋值语句一定是先执行等号右侧的，在执行等号左侧</span></span><br><span class="line">        <span class="built_in">print</span>(temp)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">     <span class="comment">#在生成器函数实现内部是可以向yield后面写代码</span></span><br><span class="line">        </span><br><span class="line">obj = yieldTest()<span class="comment">#创建一个生成器对象</span></span><br><span class="line">v1 = <span class="built_in">next</span>(obj)</span><br><span class="line"><span class="built_in">print</span>(v1) <span class="comment">#执行结果：0</span></span><br><span class="line"></span><br><span class="line">v2 = <span class="built_in">next</span>(obj)</span><br><span class="line"><span class="built_in">print</span>(v2) <span class="comment">#执行结果：None 1</span></span><br></pre></td></tr></table></figure>


<p>​<br>    - 思考None是如何产生的第一次取值：yield 返回了 i 值 0，停在yield i，temp没赋到值。第二次取值，开始在print，temp没被赋值，故打印None，i加1，继续while判断，yield 返回了 i 值 1，停在yield i）</p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><ul>
<li><p>装饰器（Decorator）：</p>
<ul>
<li><p>从字面上理解，就是装饰对象的器件。</p>
</li>
<li><p>就是可以在不修改原有代码的情况下，为被装饰的对象增加新的功能或者附加限制条件。</p>
</li>
<li><p>装饰器有很多种，有函数的装饰器，也有类的装饰器。装饰器在很多语言中的名字也不尽相同，它体现的是设计模式中的装饰模式。</p>
</li>
<li><p>装饰器的语法是将@装饰器名，放在被装饰对象上面。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在进行装饰器的介绍之前，我们必须先明确几个概念和原则：</p>
<ul>
<li>首先，Python程序是从上往下顺序执行的,而且碰到函数的定义代码块是不会立即执行的，只有等到该函数被调用时，才会执行其内部的代码块</li>
<li>其次，由于顺序执行的原因，如果你真的对同一个函数定义了两次，那么，后面的定义会覆盖前面的定义。因此，在Python中代码的放置位置是有区别的，不能随意摆放，通常函数体要放在调用的语句之前。</li>
</ul>
</li>
<li><p>虚拟场景</p>
<ul>
<li>有一个大公司，下属的基础平台部负责内部应用程序及API的开发。另外还有上百个业务部门负责不同的业务，这些业务部门各自调用基础平台部提供的不同函数，也就是API处理自己的业务，情况如下：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>公司还在创业初期时，基础平台部就开发了这些函数。由于各种原因，比如时间紧，比如人手不足，比如架构缺陷，比如考虑不周等等，没有为函数的调用进行安全认证。现在，公司发展壮大了，不能再像初创时期的“草台班子”一样将就下去了，基础平台部主管决定弥补这个缺陷，于是：</p>
<ul>
<li><p>第一天：主管叫来了一个运维工程师，工程师跑上跑下逐个部门进行通知，让他们在代码里加上认证功能，然后，当天他被开除了。</p>
</li>
<li><p>第二天：主管叫来了一个python自动化开发工程师。哥们是这么干的，只对基础平台的代码进行重构，让N个业务部门无需做任何修改。这哥们很快也被开了，连运维也没得做。　　</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<pre><code>- 第三天：主管又换了个开发工程师。他是这么干的：定义个认证函数，在原来其他的函数中调用它，代码如下:
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cheak</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<pre><code>- 但是主管依然不满意，不过这一次他解释了为什么。

  - 主管说：写代码要遵循开放封闭原则，简单来说，已经实现的功能代码内部不允许被修改，但外部可以被扩展。如果将开放封闭原则应用在上面的需求中，那么就是不允许在函数f1 、f2、f3......f100的内部进行代码修改，但是可以在外部对它们进行扩展。

- 第四天：已经没有时间让主管找别人来干这活了，他决定亲自上阵，使用装饰器完成这一任务，并且打算在函数执行后再增加个日志功能。主管的代码如下：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">func</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;认证功能操作&#x27;</span>)</span><br><span class="line">    result = func()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API</span></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="meta">@outer  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<pre><code>- 使用装饰器@outer，也是仅需对基础平台的代码进行拓展，就可以实现在其他部门调用函数API之前都进行认证操作，并且其他业务部门无需对他们自己的代码做任何修改，调用方式也不用变。
</code></pre>
<ul>
<li><p>装饰器机制分析</p>
<ul>
<li>下面以f1函数为例，对装饰器的运行机制进行分析：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.定义一个装饰器</span></span><br><span class="line"><span class="comment">#装饰器outer是有特殊要求的：</span></span><br><span class="line"><span class="comment">#要求1：装饰器函数必须要有一个参数（表示的是被装饰函数的函数名）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">func</span>): <span class="comment">#step2.func == f1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;给f1函数增添的安全认证功能&#x27;</span>)</span><br><span class="line">        func() <span class="comment">#step3:等同于在调用f1()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;给f1函数增加了数据检测的功能&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner<span class="comment">#step4：inner表示的是内部函数的名字，该函数名就会替换被装饰的函数名</span></span><br><span class="line"><span class="comment">#2.使用定义好的装饰器，去装饰某一个函数（在不修改函数原有代码的基础上给其增添新的功能）</span></span><br><span class="line"><span class="comment">#如果装饰器装饰了一个函数，则装饰器函数就会被自动调用</span></span><br><span class="line"><span class="meta">@outer </span><span class="comment"># step1.调用装饰器函数，且将被装饰的函数名传递给装饰器函数的参数</span></span><br><span class="line"><span class="comment">#使用outer装饰器装饰f1函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(): <span class="comment">#step5：f1 == inner; inner()函数调用就是在调用f1()</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(): <span class="comment">#f2是没有被outer装饰的</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f2函数的原有实现&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f1() <span class="comment">#实际上就是在调用inner()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- 1.程序开始运行，从上往下解释，读到def outer(func):的时候，发现这是个函数定义，于是把函数体加载到内存里。</span><br><span class="line"></span><br><span class="line">- 2.读到@outer的时候，程序被@这个语法吸引住了，解释器知道这是个装饰器，按规矩要立即执行的，于是程序开始运行@后面那个名字outer所定义的函数。</span><br><span class="line"></span><br><span class="line">- 3.程序返回到outer函数，开始执行装饰器的语法规则。规则是：</span><br><span class="line">  - 被装饰的函数的名字会被当作参数传递给装饰函数。装饰函数执行它自己内部的代码后，会将它的返回值赋值给被装饰的函数。原来的f1函数被当做参数传递给了func，而f1这个函数名之后会指向inner函数。</span><br><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line">  - @outer和@outer()有区别，没有括号时，outer函数依然会被执行，这和传统的用括号才能调用函数不同，需要特别注意！</span><br><span class="line">  - f1这个函数名当做参数传递给装饰函数outer，也就是：func = f1，@outer等于outer(f1),实际上传递了f1的函数体，而不是执行f1后的返回值。</span><br><span class="line">  - outer函数return的是inner这个函数名，而不是inner()这样被调用后的返回值</span><br><span class="line"></span><br><span class="line">- 4.程序开始执行outer函数内部的内容，一开始它又碰到了一个函数inner，inner函数定义块被程序观察到后不会立刻执行，而是读入内存中（这是默认规则）。</span><br><span class="line"></span><br><span class="line">- 5.再往下，碰到return inner，返回值是个函数名，并且这个函数名会被赋值给f1这个被装饰的函数，也就是f1 = inner。根据前面的知识，我们知道，此时f1函数被新的函数inner覆盖了（实际上是f1这个函数名更改成指向inner这个函数名指向的函数体内存地址，f1不再指向它原来的函数体的内存地址），再往后调用f1的时候将执行inner函数内的代码，而不是先前的函数体。那么先前的函数体去哪了？还记得我们将f1当做参数传递给func这个形参么？func这个变量保存了老的函数在内存中的地址，通过它就可以执行老的函数体，你能在inner函数里看到result = func()这句代码，它就是这么干的！</span><br><span class="line"></span><br><span class="line">- 6.接下来，还没有结束。当业务部门，依然通过f1()的方式调用f1函数时，执行的就不再是旧的f1函数的代码，而是inner函数的代码。</span><br><span class="line"></span><br><span class="line">- 7.以上流程走完后，你应该看出来了，在没有对业务部门的代码和接口调用方式做任何修改的同时，也没有对基础平台部原有的代码做内部修改，仅仅是添加了一个装饰函数，就实现了我们的需求，在函数调用前进行认证，调用后写入日志。这就是装饰器的最大作用。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思考：为什么我们要搞一个outer函数一个inner函数这么复杂呢？一层函数不行吗？</p>
<ul>
<li>请注意，@outer这句代码在程序执行到这里的时候就会自动执行outer函数内部的代码，如果不封装一下，在业务部门还未进行调用的时候，就执行了，这和初衷不符。当然，如果你对这个有需求也不是不行。</li>
</ul>
</li>
<li><p>带参装饰器</p>
<ul>
<li><p>上面的例子中，f1函数没有参数，在实际情况中肯定会需要参数的，函数的参数怎么传递的呢？</p>
</li>
<li><p>在inner函数的定义部分也加上一个参数，调用func函数的时候传递这个参数：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">func</span>):<span class="comment">#2.func == f1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">n</span>): <span class="comment">#3.n == name,n就是被装饰函数的参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;新功能！&#x27;</span>)</span><br><span class="line">        func(n) <span class="comment">#4.func(n) == f1(n)</span></span><br><span class="line">    <span class="keyword">return</span> inner <span class="comment">#5.inner就会覆盖原先的被装饰函数名f1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer </span><span class="comment">#1.调用装饰器函数，将被装饰的函数名f1作为实参，传递给outer的形参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">name</span>): <span class="comment">#6.f1 == inner</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f1的原有功能，f1的参数值为：&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line">f1(<span class="string">&#x27;bobo&#x27;</span>) <span class="comment">#7.inner(&#x27;bobo&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%A8%A1%E5%87%86%E5%A4%87/">数模准备</a><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">语言基础</a></div><div class="post_share"><div class="social-share" data-image="https://b.zhutix.com/bizhi/geometrix/53.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/01/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python语言基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="Python语言基础"><img class="cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-12</div><div class="title">Python语言基础</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81Nzc4Ny8zNDI1MA"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img.166.net/reunionpub/ds/nbot/20210317/232642-0ohjgimbna.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Carl</div><div class="author-info__description">卡卡的博客，欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Sugarchen7"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Sugarchen7" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1515631876@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">雪花❄️在复杂多变的云层中都经历了截然不同的一生，那些成熟很快的孩子们很棒，但晚熟的也一时难得，每个人都有自己独有的时区，所以不必羡慕身边的谁很早就拥有了什么，也不必为了慌张的追赶而错过了沿途的风景，这个过程对有些人来说可能会很早对有些人说可能会很晚，重要的是--向前。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">推导式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">生成器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">装饰器</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/13/Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/" title="Python语言进阶"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python语言进阶"/></a><div class="content"><a class="title" href="/2023/01/13/Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/" title="Python语言进阶">Python语言进阶</a><time datetime="2023-01-13T08:30:25.000Z" title="发表于 2023-01-13 16:30:25">2023-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="Python语言基础"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python语言基础"/></a><div class="content"><a class="title" href="/2023/01/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" title="Python语言基础">Python语言基础</a><time datetime="2023-01-12T14:10:53.000Z" title="发表于 2023-01-12 22:10:53">2023-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/" title="STM32学习（中级篇）"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32学习（中级篇）"/></a><div class="content"><a class="title" href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/" title="STM32学习（中级篇）">STM32学习（中级篇）</a><time datetime="2023-01-08T13:16:41.000Z" title="发表于 2023-01-08 21:16:41">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/" title="STM32学习（入门篇）"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32学习（入门篇）"/></a><div class="content"><a class="title" href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/" title="STM32学习（入门篇）">STM32学习（入门篇）</a><time datetime="2022-12-29T14:39:12.000Z" title="发表于 2022-12-29 22:39:12">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="51单片机学习笔记"/></a><div class="content"><a class="title" href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记">51单片机学习笔记</a><time datetime="2022-12-22T13:27:08.000Z" title="发表于 2022-12-22 21:27:08">2022-12-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Carl</div><div class="footer_custom_text">一个人能走多远关键在于与谁同行，我愿用跨越山海的陪伴换来你金钱的点赞👍</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="8008663318" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>