<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>STM32学习（入门篇） | Carl's blog</title><meta name="author" content="Carl"><meta name="copyright" content="Carl"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="stm32是现在用得很多的单片机，希望通过学习stm32单片机来应用到生活和比赛当中。本文是观看野火官方的视频做的笔记，用的是野火的指南针开发板。">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32学习（入门篇）">
<meta property="og:url" content="http://carl.github.io/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/index.html">
<meta property="og:site_name" content="Carl&#39;s blog">
<meta property="og:description" content="stm32是现在用得很多的单片机，希望通过学习stm32单片机来应用到生活和比赛当中。本文是观看野火官方的视频做的笔记，用的是野火的指南针开发板。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b.zhutix.com/bizhi/geometrix/53.jpg">
<meta property="article:published_time" content="2022-12-29T14:39:12.000Z">
<meta property="article:modified_time" content="2023-01-08T13:27:54.252Z">
<meta property="article:author" content="Carl">
<meta property="article:tag" content="电赛准备">
<meta property="article:tag" content="单片机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b.zhutix.com/bizhi/geometrix/53.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://carl.github.io/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32学习（入门篇）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-08 21:27:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img.166.net/reunionpub/ds/nbot/20210317/232642-0ohjgimbna.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://b.zhutix.com/bizhi/geometrix/53.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Carl's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STM32学习（入门篇）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-29T14:39:12.000Z" title="发表于 2022-12-29 22:39:12">2022-12-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-08T13:27:54.252Z" title="更新于 2023-01-08 21:27:54">2023-01-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32学习（入门篇）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文使用的是野火生产的[STM32-指南针]([关于本项目 — <a target="_blank" rel="noopener" href="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/README.html">野火]STM32库开发实战指南——基于野火指南者开发板 文档 (embedfire.com)</a>)，观看野火教程的<a href="%5B3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8DAP%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Xs411g7Aj?p=1&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">学习视频</a>的学习笔记</p>
<h1 id="DAP仿真软件的配置"><a href="#DAP仿真软件的配置" class="headerlink" title="DAP仿真软件的配置"></a>DAP仿真软件的配置</h1><p>这里观看这里的教程：[DAP仿真器与串口下载程序 — <a target="_blank" rel="noopener" href="https://doc.embedfire.com/stm32_products/must_read/zh/latest/doc/quickstart/DAP/DAP.html">野火]STM32开发板必读说明 文档 (embedfire.com)</a></p>
<p><img src="https://doc.embedfire.com/stm32_products/must_read/zh/latest/_images/DAP_0.png" alt="../../../_images/DAP_0.png"></p>
<p>左侧不出现，注意换一个USB口。右侧不出现，DAP插入开发板时，换成SWD</p>
<p>普通DAP注意connect：under Reset 。Reset 选择HW RESET或者 VECTRESTET </p>
<p>注意配置，配置好后，DAP仿真器应该亮绿灯。</p>
<p>编译完成后点击LOAD即可下载程序。</p>
<hr>
<h1 id="什么是STM32"><a href="#什么是STM32" class="headerlink" title="什么是STM32"></a>什么是STM32</h1><h2 id="STM32的引脚说明"><a href="#STM32的引脚说明" class="headerlink" title="STM32的引脚说明"></a>STM32的引脚说明</h2><table>
<thead>
<tr>
<th>引脚分类</th>
<th>引脚说明说明</th>
</tr>
</thead>
<tbody><tr>
<td>电源</td>
<td>(VBAT)、(VDD Vss)、(VDDA VSSA)、(VREF+VREF-)等</td>
</tr>
<tr>
<td>晶振IO</td>
<td>主晶振IO，RTC晶振IO</td>
</tr>
<tr>
<td>下载IO</td>
<td>用于JTAG下载的IO:JTMS、JTCK、JTDI、JTDO、NJTRST</td>
</tr>
<tr>
<td>BOOT IO</td>
<td>BOOTo、BOOT1，用于设置系统的启动方式</td>
</tr>
<tr>
<td>复位IO</td>
<td>NRST，用于外部复位</td>
</tr>
<tr>
<td></td>
<td>上面5部分IO组成的系统我们也叫做最小系统</td>
</tr>
<tr>
<td>GPIO</td>
<td>专用器件接到专用的总线，比如I2C，SPI，SDIO，FSMC，DCMI这些总线的器件需要接到专用的IO</td>
</tr>
<tr>
<td>GPIO</td>
<td>普通的元器件接到GPIO，比如蜂鸣器，LED，按键等元器件用普通的GPIO即</td>
</tr>
<tr>
<td>GPIO</td>
<td>如果还有剩下的IO，可根据项目需要引出或者不引出</td>
</tr>
</tbody></table>
<p>具体引脚的功能说明见 数据手册(最好读英文)</p>
<hr>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h2><p>意义： 给有特殊意义的地址取了一个别名</p>
<p>STM32中的 头文件 <code>#include &quot;stm32f10x.h&quot;</code></p>
<p>以及51单片机中的 头文件<code>#inclde &quot;reg51.h&quot;</code></p>
<p>中都是存放着寄存器映射</p>
<h2 id="以GPIOB口为例子"><a href="#以GPIOB口为例子" class="headerlink" title="以GPIOB口为例子"></a>以GPIOB口为例子</h2><p>我们找到GPIOB端口的输出数据寄存器ODR的地址是0x40010C0C</p>
<blockquote>
<p>(在官方参考手册的 2.3存储器映像中找到起始位置)</p>
</blockquote>
<p>ODR寄存器是32bit，低16bit有效，对应着16个外部IO，写0/1对应的的IO则输出低/高电平。</p>
<p>通过下面语句将其全部置为一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0x4001</span> <span class="number">0</span>C0C) = <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">// 我们对位操作时通常使用位操作符 |,&amp;的形式 在之后会介绍</span></span><br></pre></td></tr></table></figure>

<p>我们给<code>*(unsigned int*)(0x4001 0C0C)</code>定义一个别名,就是寄存器映射</p>
<p>上面所讲的头文件实际上就是对 各个特殊意义的地址取了别名后进行封装</p>
<hr>
<hr>
<h1 id="新建工程模板"><a href="#新建工程模板" class="headerlink" title="新建工程模板"></a>新建工程模板</h1><h2 id="点亮一盏灯-简易版"><a href="#点亮一盏灯-简易版" class="headerlink" title="点亮一盏灯(简易版)"></a>点亮一盏灯(简易版)</h2><ol>
<li>首先看电路原理图</li>
</ol>
<p>通过PB0端口来控制绿灯的点亮</p>
<p>![img](STM32 学习/SVF7QMT2%$O`06832X``8EQ.png)</p>
<p>PB0 由GPIOB_ODR(output data register) 端口输出寄存器控制</p>
<ul>
<li><p>找到 GPIOB的地址为 <code>0X4001 0C00 </code></p>
</li>
<li><p>ODR的地址偏移：0C h</p>
</li>
<li><p>点亮灯-让最低位输出零</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X4001</span> <span class="number">0</span>C0C) &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"><span class="comment">//这步骤是 让最后一位置零,并且不影响其他位的取值</span></span><br><span class="line"><span class="comment">//注意ODR的复位值：0x0000 0000,不进行这步,灯也会亮,但是为了可读一定要加上这一句</span></span><br></pre></td></tr></table></figure>

<p>但是STM32比51单片机高级的地方在于PB0口既可以当作输入 又可以当作输出,而且默认为输入</p>
<p>这里我们要将它 <strong>配置IO口为输出</strong></p>
<p>![image-20221226223404869](STM32 学习/image-20221226223404869.png)</p>
<p>PB0是0 所以是最后四位</p>
<p>使用 通用推挽输出模式[0,0]</p>
<p>模式控制速度这里选择10MHZ</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X4001</span> <span class="number">0</span>C00) &amp;= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>然后我们发现要控制GPIOB打开 还得控制时钟打开</p>
<p>![](STM32 学习/image-20221226223936675.png)</p>
<p>由寄存器组起始地址表中,查到RCC的地址是 0x4002 1000</p>
<p>然后再APB2 外设时钟使能寄存器(RCC_APB2ENR)中看到</p>
<p>![image-20221226224355093](STM32 学习/image-20221226224355093.png)</p>
<p>![image-20221226224416328](STM32 学习/image-20221226224416328.png)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X0</span>x4002 <span class="number">1018</span>) &amp;= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//亮绿灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40021018</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C00</span>) |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));<span class="comment">//4*1-蓝灯 4*5红灯</span></span><br><span class="line">	<span class="comment">// 控制ODR寄存器 让灯亮</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) &amp;= ~(<span class="number">0</span>&lt;&lt;<span class="number">0</span>)<span class="comment">//&lt;&lt;1-蓝灯,&lt;&lt;5红灯	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> SystemInit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//闪烁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">400</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">400</span>;j++);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40021018</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C00</span>) |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 控制ODR寄存器 让灯亮</span></span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		delay();</span><br><span class="line">		<span class="comment">// 控制ODR寄存器 让灯灭</span></span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		delay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用寄存器点亮一盏灯"><a href="#使用寄存器点亮一盏灯" class="headerlink" title="使用寄存器点亮一盏灯"></a>使用寄存器点亮一盏灯</h1><h2 id="读GPIO的系统框图"><a href="#读GPIO的系统框图" class="headerlink" title="读GPIO的系统框图"></a>读GPIO的系统框图</h2><p>![7](STM32 学习/7.png)</p>
<ul>
<li><p>上半部分是输入部分</p>
</li>
<li><p>下半部分是输出部分</p>
</li>
</ul>
<p>圈2这个位置是选择工作模式</p>
<p>通常选择推挽工作模式</p>
<p>开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中，或者是电平不匹配的场合</p>
<p>圈3这个位置就是我们的ODR控制输出，也可以通过BSRR 位设置、清除寄存器控制</p>
<p>输入部分</p>
<p>首先是一个上拉下拉 在端口配置低寄存器中选择上拉/下拉模式</p>
<p>然后是TTL 也称为0/1转换器来实现数模转换</p>
<p>圈5是IDR</p>
<p>圈6读取数字信号</p>
<p>圈7读取模拟信号</p>
<h2 id="自己写寄存器映射到头文件中"><a href="#自己写寄存器映射到头文件中" class="headerlink" title="自己写寄存器映射到头文件中"></a>自己写寄存器映射到头文件中</h2><p>打开头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义总线的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2 (unsigned int)0x40010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABH  (unsigned int)0x40020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB1 (unsigned int)0x40000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据寄存器偏移确定外设的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB (APB2+0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSS   (ABH +0x1000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制特定的寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRL  *(unsigned int*)(GPIOB+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRH  *(unsigned int*)(GPIOB+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR  *(unsigned int*)(GPIOB+0x0C)</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR *(unsigned int*)(RSS+0x18)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*片上外设基地址  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE         ((unsigned int)0x40000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*总线基地址，GPIO都挂载到APB2上 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/* AHB总线基地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHBPERIPH_BASE      (PERIPH_BASE + 0x20000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIOB外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE          (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIOB寄存器地址,强制转换成指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRL           *(unsigned int*)(GPIOB_BASE+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRH           *(unsigned int*)(GPIOB_BASE+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_IDR           *(unsigned int*)(GPIOB_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR           *(unsigned int*)(GPIOB_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BSRR          *(unsigned int*)(GPIOB_BASE+0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BRR           *(unsigned int*)(GPIOB_BASE+0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_LCKR          *(unsigned int*)(GPIOB_BASE+0x18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*RCC外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE           (AHBPERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="comment">/*RCC的AHB1时钟使能寄存器地址,强制转换成指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR        *(unsigned int*)(RCC_BASE+0x18)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	RCC_APB2ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	GPIOB_CRL |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 控制GPIOB_BSRR, GPIOB_BRR寄存器 让灯亮</span></span><br><span class="line">	GPIOB_BRR  |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	GPIOB_BSRR |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="构建STM32库函数的雏形"><a href="#构建STM32库函数的雏形" class="headerlink" title="构建STM32库函数的雏形"></a>构建STM32库函数的雏形</h1><h2 id="通过结构体来访问地址"><a href="#通过结构体来访问地址" class="headerlink" title="通过结构体来访问地址"></a>通过结构体来访问地址</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*片上外设基地址  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE         ((unsigned int)0x40000000)</span></span><br><span class="line"><span class="comment">/*总线基地址，GPIO都挂载到APB2上 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/*GPIOB外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE          (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 寄存器结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">uint32_t</span> CRL;       <span class="comment">// 端口配置低寄存器，     地址偏移0X00</span></span><br><span class="line">   <span class="type">uint32_t</span> CRH;       <span class="comment">// 端口配置高寄存器，     地址偏移0X04</span></span><br><span class="line">   <span class="type">uint32_t</span> IDR;       <span class="comment">// 端口数据输入寄存器，   地址偏移0X08</span></span><br><span class="line">   <span class="type">uint32_t</span> ODR;       <span class="comment">// 端口数据输出寄存器，   地址偏移0X0C</span></span><br><span class="line">   <span class="type">uint32_t</span> BSRR;      <span class="comment">// 端口位设置/清除寄存器，地址偏移0X10</span></span><br><span class="line">   <span class="type">uint32_t</span> BRR;       <span class="comment">// 端口位清除寄存器，     地址偏移0X14</span></span><br><span class="line">   <span class="type">uint32_t</span> LCKR;      <span class="comment">// 端口配置锁定寄存器，   地址偏移0X18</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GBIO ((GPIO_TypeDef*)GPIOB_BASE)</span></span><br><span class="line"><span class="comment">//之后就可以用 GBIO-&gt;CRL来访问CRL</span></span><br></pre></td></tr></table></figure>

<h2 id="通过建立库函数来控制GPIO"><a href="#通过建立库函数来控制GPIO" class="headerlink" title="通过建立库函数来控制GPIO"></a>通过建立库函数来控制GPIO</h2><ol>
<li>在工程文件下 新建一个<code>.h</code>的头文件和同名的<code>.c</code>文件 并加到工程文件中</li>
<li>在新建的<code>.c</code>文件中调用<code>.h</code>文件</li>
<li><code>.h</code>文件中要采取固定方式书写,防止重复调用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F10X_GPIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F10X_GPIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分别定义每个引脚 置1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_0              (uint16_t)0x0001)  <span class="comment">/*!&lt; 选择Pin0 (1&lt;&lt;0) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_1              ((uint16_t)0x0002)  <span class="comment">/*!&lt; 选择Pin1 (1&lt;&lt;1)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_2              ((uint16_t)0x0004)  <span class="comment">/*!&lt; 选择Pin2 (1&lt;&lt;2)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_3              ((uint16_t)0x0008)  <span class="comment">/*!&lt; 选择Pin3 (1&lt;&lt;3)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_4              ((uint16_t)0x0010)  <span class="comment">/*!&lt; 选择Pin4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_5              ((uint16_t)0x0020)  <span class="comment">/*!&lt; 选择Pin5 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6              ((uint16_t)0x0040)  <span class="comment">/*!&lt; 选择Pin6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7              ((uint16_t)0x0080)  <span class="comment">/*!&lt; 选择Pin7 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8              ((uint16_t)0x0100)  <span class="comment">/*!&lt; 选择Pin8 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_9              ((uint16_t)0x0200)  <span class="comment">/*!&lt; 选择Pin9 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_10             ((uint16_t)0x0400)  <span class="comment">/*!&lt; 选择Pin10 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_11             ((uint16_t)0x0800)  <span class="comment">/*!&lt; 选择Pin11 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_12             ((uint16_t)0x1000)  <span class="comment">/*!&lt; 选择Pin12 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_13             ((uint16_t)0x2000)  <span class="comment">/*!&lt; 选择Pin13 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_14             ((uint16_t)0x4000)  <span class="comment">/*!&lt; 选择Pin14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_15             ((uint16_t)0x8000)  <span class="comment">/*!&lt; 选择Pin15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_All            ((uint16_t)0xFFFF)  <span class="comment">/*!&lt; 选择全部引脚 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面可以加函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*__STM32F10X_GPIO_H*/</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>.c</code>文件中写函数</p>
<ol start="4">
<li>最后只需在<code>main.c</code>声明 <code>#include XX.h</code>即可使用函数</li>
</ol>
<h2 id="构建初始化函数"><a href="#构建初始化函数" class="headerlink" title="构建初始化函数"></a>构建初始化函数</h2><ol>
<li>定义结构体存放初始化的配置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;      <span class="comment">/*!&lt; 选择要配置的GPIO引脚 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Speed;    <span class="comment">/*!&lt; 选择GPIO引脚的速率 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Mode;     <span class="comment">/*!&lt; 选择GPIO引脚的工作模式 */</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义枚举类型 对每一个模式进行赋值</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel004.png" alt="端口配置低寄存器"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* GPIO输出速率枚举定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Speed_10MHz = <span class="number">1</span>,         <span class="comment">// 10MHZ        (01)b</span></span><br><span class="line">    GPIO_Speed_2MHz,              <span class="comment">// 2MHZ         (10)b</span></span><br><span class="line">    GPIO_Speed_50MHz              <span class="comment">// 50MHZ        (11)b</span></span><br><span class="line">&#125; GPIOSpeed_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* GPIO工作模式枚举定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Mode_AIN = <span class="number">0x0</span>,           <span class="comment">// 模拟输入     (0000 0000)b</span></span><br><span class="line">    GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,  <span class="comment">// 浮空输入     (0000 0100)b</span></span><br><span class="line">    GPIO_Mode_IPD = <span class="number">0x28</span>,          <span class="comment">// 下拉输入     (0010 1000)b</span></span><br><span class="line">    GPIO_Mode_IPU = <span class="number">0x48</span>,          <span class="comment">// 上拉输入     (0100 1000)b</span></span><br><span class="line"></span><br><span class="line">    GPIO_Mode_Out_OD = <span class="number">0x14</span>,       <span class="comment">// 开漏输出     (0001 0100)b</span></span><br><span class="line">    GPIO_Mode_Out_PP = <span class="number">0x10</span>,       <span class="comment">// 推挽输出     (0001 0000)b</span></span><br><span class="line">    GPIO_Mode_AF_OD = <span class="number">0x1C</span>,        <span class="comment">// 复用开漏输出  (0001 1100)b</span></span><br><span class="line">    GPIO_Mode_AF_PP = <span class="number">0x18</span>         <span class="comment">// 复用推挽输出  (0001 1000)b</span></span><br><span class="line">&#125; GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义GPIO初始化函数,来实现寄存器配置</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel006.png" alt="GPIO引脚工作模式真值表分析"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*函数功能：初始化引脚模式</span></span><br><span class="line"><span class="comment">*参数说明：GPIOx，该参数为GPIO_TypeDef类型的指针，指向GPIO端口的地址</span></span><br><span class="line"><span class="comment">*         GPIO_InitTypeDef:GPIO_InitTypeDef结构体指针，指向初始化变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> currentmode =<span class="number">0x00</span>,currentpin = <span class="number">0x00</span>,pinpos = <span class="number">0x00</span>,pos = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">uint32_t</span> tmpreg = <span class="number">0x00</span>, pinmask = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*---------------- GPIO 模式配置 -------------------*/</span></span><br><span class="line">    <span class="comment">// 把输入参数GPIO_Mode的低四位暂存在currentmode</span></span><br><span class="line">    currentmode = ((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp;</span><br><span class="line">                ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bit4是1表示输出，bit4是0则是输入</span></span><br><span class="line">    <span class="comment">// 判断bit4是1还是0，即首选判断是输入还是输出模式</span></span><br><span class="line">    <span class="keyword">if</span> ((((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp;</span><br><span class="line">            ((<span class="type">uint32_t</span>)<span class="number">0x10</span>)) != <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出模式则要设置输出速度</span></span><br><span class="line">        currentmode |= (<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*-----GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- ----*/</span></span><br><span class="line">    <span class="comment">// 配置端口低8位，即Pin0~Pin7</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Pin &amp;</span><br><span class="line">            ((<span class="type">uint32_t</span>)<span class="number">0x00FF</span>)) != <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先备份CRL寄存器的值</span></span><br><span class="line">        tmpreg = GPIOx-&gt;CRL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环，从Pin0开始配对，找出具体的Pin</span></span><br><span class="line">        <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pos的值为1左移pinpos位</span></span><br><span class="line">            pos = ((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 令pos与输入参数GPIO_PIN作位与运算</span></span><br><span class="line">            currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">            <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚</span></span><br><span class="line">                pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">                pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">                tmpreg &amp;= ~pinmask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">                tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 下拉输入模式,引脚默认置0,对BRR寄存器写1对引脚置0</span></span><br><span class="line">                    GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">                    <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 上拉输入模式,引脚默认值为1,对BSRR寄存器写1对引脚置1</span></span><br><span class="line">                        GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前面处理后的暂存值写入到CRL寄存器之中</span></span><br><span class="line">        GPIOx-&gt;CRL = tmpreg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*--------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----*/</span></span><br><span class="line">    <span class="comment">// 配置端口高8位，即Pin8~Pin15</span></span><br><span class="line">    <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class="number">0x00FF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// // 先备份CRH寄存器的值</span></span><br><span class="line">        tmpreg = GPIOx-&gt;CRH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环，从Pin8开始配对，找出具体的Pin</span></span><br><span class="line">        <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pos与输入参数GPIO_PIN作位与运算</span></span><br><span class="line">            currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">            <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚</span></span><br><span class="line">                pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">                pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">                tmpreg &amp;= ~pinmask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">                tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 下拉输入模式,引脚默认置0,对BRR寄存器写1可对引脚置0</span></span><br><span class="line">                    GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 上拉输入模式,引脚默认值为1,对BSRR寄存器写1可对引脚置1</span></span><br><span class="line">                    GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前面处理后的暂存值写入到CRH寄存器之中</span></span><br><span class="line">        GPIOx-&gt;CRH = tmpreg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提高代码的可移植性"><a href="#提高代码的可移植性" class="headerlink" title="提高代码的可移植性"></a>提高代码的可移植性</h2><p>涉及到GPIO端口时候利用 宏来进行替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_GPIO_PORT GPIOB <span class="comment">//将点亮的端口用宏替代</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK_ENABLE (RCC-&gt;APB2ENR |=((1)&lt;&lt;3)) <span class="comment">//点亮对应端口的时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_GPIO_PIN GPIO_pin_0 <span class="comment">//LED_G对应PB0是第一个引脚</span></span></span><br></pre></td></tr></table></figure>

<p>将后面的代码用宏来替代</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>直接操作内存-&gt;寄存器映射-&gt;利用寄存器结构体方便访问结构体成员-&gt;加强可读性(编写函数)-&gt;定义初始化结构体(将所有要配置的参数枚举出来)-&gt;利用宏定义增强可移植性</p>
<hr>
<h1 id="固件库编程"><a href="#固件库编程" class="headerlink" title="固件库编程"></a>固件库编程</h1><h2 id="分析固件库内容"><a href="#分析固件库内容" class="headerlink" title="分析固件库内容"></a>分析固件库内容</h2><ol>
<li>汇编语言编写的启动文件(简单)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startup_stm32f10x_hd.c: 设置堆栈指针,设置PC指针,初始化中断向量表,配置系统时钟,对用C库函数,进入C语言的环境</span><br><span class="line">hd,表示大小</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer01.png" alt="详细说明见表"></p>
<ol start="2">
<li>时钟配置文件(简单)</li>
</ol>
<p>system_stm32f10zx.c: 把系统时钟HSE=8M, 经过PLL 倍频为PLL=72M</p>
<ol start="3">
<li><strong>stm32f10x.h</strong> </li>
</ol>
<p>ST生产的外设相关的: 实现寄存器映射</p>
<p>XXX: GPIO,USRAT,I2C,SPI,FSMC</p>
<p>stm32f10x_XX.h :存放外设初始化结构体,外设初始化结构体成员的参数列表,外设固件库函数声明</p>
<p>stm32f10x_XX.c :外设驱动函数库文件</p>
<ol start="4">
<li><strong>core_cm.h</strong></li>
</ol>
<p>内核映射: 内核相关的寄存器映射</p>
<p>core_cm.c: 内核外设的驱动固件库</p>
<p>NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器)</p>
<p>misc.h</p>
<p>misc.c</p>
<ol start="5">
<li>在main函数里面定义使用的<strong>头文件</strong></li>
</ol>
<p>为了方便定义了 头文件配置文件: 实现外设所以的文件的声明</p>
<p><strong>stm32f10x_conf.h</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用什么外设 就取消什么注释</span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>专门存放中断服务函数的C文件</li>
</ol>
<p>stm32f10x_it.h</p>
<p>stm32f10x_it.c</p>
<p>这个函数可以随意放在其他的地方,并不一定要放到stm32f10x_it.c 中</p>
<h2 id="固件库的内容"><a href="#固件库的内容" class="headerlink" title="固件库的内容"></a>固件库的内容</h2><p>看固件库的头文件来分析函数的作用</p>
<hr>
<h1 id="建立带固件库的工程模板"><a href="#建立带固件库的工程模板" class="headerlink" title="建立带固件库的工程模板"></a>建立带固件库的工程模板</h1><p>基本上看着视频操作，或者书本就可</p>
<p>但是有一点特别注意</p>
<p>![8](STM32 学习/8.png)</p>
<p>将这个版本设置成5，不然不仅编译慢还疯狂报错</p>
<hr>
<h1 id="利用固件库编程点亮LED"><a href="#利用固件库编程点亮LED" class="headerlink" title="利用固件库编程点亮LED"></a>利用固件库编程点亮LED</h1><h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><p>1.主函数内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(LED_G_PORT, LED_G_PIN);    <span class="comment">//set函数将引脚上的 置为1</span></span><br><span class="line">	GPIO_ResetBits(LED_G_PORT, LED_G_PIN);  <span class="comment">//reset函数将引脚上的 置为1</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.bsp_led.c文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_initstruct; <span class="comment">//定义一个结构体初始化绿灯的内容</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_G_CLK, ENABLE); <span class="comment">//打开绿灯的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//定义绿灯为推挽输出</span></span><br><span class="line">	GPIO_initstruct.GPIO_Pin = LED_G_PIN;          <span class="comment">//将引脚对应为绿灯的引脚</span></span><br><span class="line">	GPIO_initstruct.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//定义速度为50M</span></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_initstruct);            <span class="comment">//使用初始化函数配置到GPIO_CLR</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.bsp_led.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PIN  GPIO_Pin_0                    <span class="comment">// 宏定义绿灯的管脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PORT GPIOB                         <span class="comment">// 宏定义绿灯的端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK  RCC_APB2Periph_GPIOB          <span class="comment">//宏定义绿灯的时钟</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BEP_LED_H*/</span></span></span><br></pre></td></tr></table></figure>

<h2 id="实现流水灯"><a href="#实现流水灯" class="headerlink" title="实现流水灯"></a>实现流水灯</h2><ol>
<li>主函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_GREEN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bsp_led.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_G_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_G_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_G_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_G_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_G_initstruct.GPIO_Pin = LED_G_PIN; </span><br><span class="line">	GPIO_G_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_G_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_B_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_B_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_B_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_B_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_B_initstruct.GPIO_Pin = LED_B_PIN; </span><br><span class="line">	GPIO_B_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_B_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_R_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_R_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_R_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_R_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_R_initstruct.GPIO_Pin = LED_R_PIN; </span><br><span class="line">	GPIO_R_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_R_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>bsp_led.h</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_PIN  GPIO_Pin_1 <span class="comment">//只有端口不同的区别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//红灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_PIN  GPIO_Pin_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开绿灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_G_PORT, LED_G_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_G_PORT, LED_G_PIN); </span></span><br><span class="line"><span class="comment">//开蓝灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_B_PORT, LED_B_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_B_PORT, LED_B_PIN); </span></span><br><span class="line"><span class="comment">//开蓝灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_R_PORT, LED_R_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_R_PORT, LED_R_PIN); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示红色</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RED  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_GREEN       \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_BLUE    \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//黄(红+绿)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_YELLOW  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"><span class="comment">//紫(红+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PURPLE  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//青(绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_CYAN \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//白(红+绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WHITE   \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//黑(全部关闭)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RGBOFF  \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BEP_LED_H*/</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="GPIO输入-按键检测"><a href="#GPIO输入-按键检测" class="headerlink" title="GPIO输入- 按键检测"></a>GPIO输入- 按键检测</h1><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIOin003.png" alt="按键原理图"></p>
<p>这里采用了连接<strong>电容</strong>的方式来<strong>物理消抖</strong></p>
<p>R57和R15的作用都是保护电路</p>
<p>如果按键按下就会 读到高电平 按键不按下的时候会得到低电平</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><ol>
<li>对引脚进行初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在.h文件中</span></span><br><span class="line"><span class="comment">//KEY1宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="comment">//在.c文件中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_G_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct; <span class="comment">//定义KEY1的结构体</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_G_CLK, ENABLE); <span class="comment">//打开KEY1对应的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//设置模式为浮空输入模式</span></span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_G_PIN;   <span class="comment">//设置KEY1对应的引脚</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_G_PORT, &amp;GPIO_KEY1_initstruct); <span class="comment">//调用初始化函数配置到寄存器中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写按键检测函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span> <span class="comment">//传入对应的端口和引脚</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON ) <span class="comment">//是否按下 按下为1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON);<span class="comment">//松手检测</span></span><br><span class="line">		<span class="keyword">return</span> KEY_ON;  <span class="comment">//返回按下</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> KEY_OFF; <span class="comment">//返回没有按下</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>灯状态变化函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LED_G_TOGGLE; <span class="comment">//宏定义函数 相当于对 对应位取反</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_TOGGLE &#123;LED_G_PORT-&gt;ODR ^= LED_G_PIN ;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写好的文件"><a href="#编写好的文件" class="headerlink" title="编写好的文件"></a>编写好的文件</h2><ol>
<li>main 函数中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;keyscan.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化LED灯</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;        <span class="comment">//亮黑灯,相当于把所有灯关上</span></span><br><span class="line">	</span><br><span class="line">	KEY1_GPIO_Config();                     <span class="comment">//初始化按键1</span></span><br><span class="line">	KEY2_GPIO_Config();                     <span class="comment">//初始化按键2</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(KEY_Scan( KEY1_PORT, KEY1_PIN) == KEY_ON) <span class="comment">//检测按键1是否按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			LED_G_TOGGLE; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(KEY_Scan( KEY2_PORT, KEY2_PIN) == KEY_ON)<span class="comment">//检测按键2是否按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			LED_B_TOGGLE; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bsp_key.h  文件中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//KEY1定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY2定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PIN  GPIO_Pin_13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PORT GPIOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_CLK  RCC_APB2Periph_GPIOC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ON  1 <span class="comment">//把按下宏定义为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_OFF 0 <span class="comment">//把未按下宏定义为0</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的声明</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY2_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*__BEP_KEY_H */</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>bsp_key.c 文件中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;keyscan.h&quot;</span></span></span><br><span class="line"><span class="comment">//按键1初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct; <span class="comment">//定义按键1对应的结构体</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_CLK, ENABLE); <span class="comment">//打开按键1对应的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//将模式设置为浮空输入模式</span></span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_PIN; <span class="comment">//设置按键1对应管脚</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_PORT, &amp;GPIO_KEY1_initstruct); <span class="comment">//调用初始化函数,穿入对应的端口中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按键2初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY2_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY2_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY2_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_KEY2_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_KEY2_initstruct.GPIO_Pin = KEY2_PIN; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY2_PORT, &amp;GPIO_KEY2_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span> <span class="comment">//按键检测函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON ) <span class="comment">//判断按键是否按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON);<span class="comment">//松手检测</span></span><br><span class="line">		<span class="keyword">return</span> KEY_ON;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> KEY_OFF;</span><br><span class="line">&#125;+-</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="GPIO的输入与输出"><a href="#GPIO的输入与输出" class="headerlink" title="GPIO的输入与输出"></a>GPIO的输入与输出</h1><h2 id="类比51-总线操作和位操作"><a href="#类比51-总线操作和位操作" class="headerlink" title="类比51 总线操作和位操作"></a>类比51 总线操作和位操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//在51单片机中,让LED1输出低电平有两个操作</span><br><span class="line">P0=0xFE; //这是总线操作,直接操作P0端口</span><br><span class="line">P0^0=0;  //这是位操作,控制LED1对应的端口</span><br></pre></td></tr></table></figure>

<p>在STM32中 <code>GPIOB-&gt;ODR $= (0&lt;&lt;0) </code> 就类似于51单片机中的总线操作</p>
<p>51单片机中通过关键字sbit来实现位定义， STM32没有这样的关键字，而是通过访问位带别名区来实现.</p>
<h2 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h2><p>STM32中，有两个位置可以实现此操作，分别是部分片上外设和部分片上SRAM.</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIObi002.png" alt="STM32位带示意图"></p>
<ol>
<li>外设外带区的地址为：0X40000000~0X40100000，大小为1MB</li>
</ol>
<p>这1MB的大小在103系列大/中/小容量型号的单片机中包含了片上外设的全部寄存器， </p>
<p>这些寄存器的地址为：0X40000000-0X40029FFF。</p>
<p>外设位带区经过膨胀后的位带别名区地址为：0X42000000-0X43FFFFFF， </p>
<p>这个地址仍然在CM3 片上外设的地址空间中</p>
<ol start="2">
<li>SRAM的位带区的地址为：0X2000 0000<del>X2010 0000，大小为1MB，经过膨胀后的位带别名区地址为：0X2200 0000</del>0X23FF FFFF， 大小为32MB。这个位操作用得比较少</li>
</ol>
<h2 id="位带地区和外设别名取的转换："><a href="#位带地区和外设别名取的转换：" class="headerlink" title="位带地区和外设别名取的转换："></a>位带地区和外设别名取的转换：</h2><p>关键：1个位膨胀成32个位</p>
<h4 id="外设位带别名区地址"><a href="#外设位带别名区地址" class="headerlink" title="外设位带别名区地址"></a>外设位带别名区地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x42000000</span>+ (A<span class="number">-0x40000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>0X42000000是外设位带别名区的起始地址，0x40000000是外设位带区的起始地址，（A-0x40000000）表示该比特前面有多少个字节， 一个字节有8位，所以<em>8，一个位膨胀后是4个字节，所以</em>4，n表示该比特在A地址的序号，因为一个位经过膨胀后是四个字节，所以也*4。</p>
<h4 id="SRAM位带别名区地址"><a href="#SRAM位带别名区地址" class="headerlink" title="SRAM位带别名区地址"></a>SRAM位带别名区地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x22000000</span>+ (A<span class="number">-0x20000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>统一公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把“位带地址+位序号”转换成别名地址的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x00FFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>

<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><p>LED的电亮</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在配置好环境后,即时钟打开,模式调整好后</span></span><br><span class="line"><span class="comment">//只需要将最后一步,点灯改为位操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR (GPIO_BASE + 0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBout(n) ((GPIOB_ODR &amp; 0xF0000000)+0x02000000+(( GPIOB_ODR &amp; 0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class="line"></span><br><span class="line">PBout(<span class="number">0</span>)=<span class="number">0</span>; <span class="comment">//开灯</span></span><br><span class="line">PBout(<span class="number">0</span>)=<span class="number">1</span>; <span class="comment">//关灯</span></span><br><span class="line"><span class="comment">//这里是绿灯,改为其他灯只需改成其他灯的初始化文件,如何将n改为1-&gt;蓝灯,n=5-&gt;红灯</span></span><br></pre></td></tr></table></figure>

<p>KEY 的检测</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在配置好环境后,即时钟打开,模式调整好后</span></span><br><span class="line"><span class="comment">//只需要将最后一步,检测改为位操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR (GPIOA_BASE + 0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAin(n) ((GPIOA_IDR &amp; 0xF0000000)+0x02000000+(( GPIOA_IDR &amp; 0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PAin(n) == KEY_ON)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(PAin(n) == KEY_ON);</span><br><span class="line">	LED_G_TEDDLE;<span class="comment">//此处写控制灯的电位发生反转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="启动文件-了解"><a href="#启动文件-了解" class="headerlink" title="启动文件(了解)"></a>启动文件(了解)</h1><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer01.png" alt="详细说明见表"></p>
<p>此处以最常用的hd为例,讲解启动文件</p>
<p>参考资料 中文手册 第九章, 开发手册(英文)</p>
<p>启动文件是上电之后第一个执行的文件</p>
<h2 id="启动文件的作用"><a href="#启动文件的作用" class="headerlink" title="启动文件的作用"></a>启动文件的作用</h2><ol>
<li>初始化堆栈指针()</li>
<li>设置PC指针(程序每执行一步,PC指针加一)</li>
</ol>
<p>让PC指针 = Reset handler</p>
<ol start="3">
<li>初始化中断向量表</li>
<li>配置系统时钟</li>
<li>调用C库函数_main,最终到C的世界</li>
</ol>
<h2 id="启动文件的内容"><a href="#启动文件的内容" class="headerlink" title="启动文件的内容"></a>启动文件的内容</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu01.png" alt="启动文件使用的ARM汇编指令汇总"></p>
<ol>
<li>配置栈 - 放变量(局部变量) 函数调用的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400                         ;1k</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3 ;分配1KB空间 不初始化 可读可写 8字节对齐 </span><br><span class="line">Stack_Mem       SPACE   Stack_Size                        </span><br><span class="line">__initial_sp    ;紧跟着SPCE语句,表示出栈</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置堆 - 主要用于动态内存的分配, malloc()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap_Size     EQU     0x00000200 ;512Byte</span><br><span class="line"></span><br><span class="line">            AREA    HEAP, NOINIT, READWRITE, ALIGN=3 </span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem      SPACE   Heap_Size ;分配空间</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">PRESERVE 8 ;表示当前堆栈以8字节对齐</span><br><span class="line">TUHUMB     ;兼容老版本?</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化中断向量表</li>
</ol>
<p>当内核响应了一个发生的异常,对应的异常服务例程(ESR)执行. 根据每个向量(数字)对应一个异常,每个向量表对应一个地址,通过这个地址来访问中断服务程序.</p>
<p>数字越小,中断优先级越高</p>
<p>灰色代表内核,白色代表外设</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu02.png" alt="F103向量表"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">AREA    RESET, DATA, READONLY</span><br><span class="line">EXPORT  __Vectors       ; </span><br><span class="line">EXPORT  __Vectors_End  </span><br><span class="line">EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">; 函数名对应的就是地址</span><br><span class="line">__Vectors  DCD   __initial_sp        ;栈顶地址</span><br><span class="line">        DCD   Reset_Handler       ;复位程序地址</span><br><span class="line">        DCD   NMI_Handler         ;不可屏蔽中断 和上面的表一致</span><br><span class="line">        DCD   HardFault_Handler</span><br><span class="line">        DCD   MemManage_Handler</span><br><span class="line">        DCD   BusFault_Handler</span><br><span class="line">        DCD   UsageFault_Handler</span><br><span class="line">        DCD   0                    ; 0 表示保留</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   SVC_Handler</span><br><span class="line">        DCD   DebugMon_Handler</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   PendSV_Handler</span><br><span class="line">        DCD   SysTick_Handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;外部中断开始</span><br><span class="line">        DCD   WWDG_IRQHandler</span><br><span class="line">        DCD   PVD_IRQHandler</span><br><span class="line">        DCD   TAMPER_IRQHandler</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">        DCD   DMA2_Channel2_IRQHandler</span><br><span class="line">        DCD   DMA2_Channel3_IRQHandler</span><br><span class="line">        DCD   DMA2_Channel4_5_IRQHandler</span><br><span class="line">__Vectors_End</span><br><span class="line">__Vectors_Size EQU __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>复位程序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA |.text|, CODE, READONLY</span><br></pre></td></tr></table></figure>

<p>定义一个名称为.text的代码段，可读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Reset_Handler PROC ;定义子程序</span><br><span class="line">            EXPORT  Reset_Handler    [WEAK] ;弱定义, 这个可以由C语言实现,如果用户没定义</span><br><span class="line">            IMPORT  SystemInit       ;插入 相对于C中的extern </span><br><span class="line">            IMPORT  __main           ;插入 C库函数- 初始化堆栈 最终调用我们写的main函数 实现从汇编到C语言的世界</span><br><span class="line"></span><br><span class="line">            LDR     R0, =SystemInit  ;系统时钟配置函数,用户配置</span><br><span class="line">            BLX     R0               ;BX执行完返回</span><br><span class="line">            LDR     R0, =__main</span><br><span class="line">            BX      R0               ;BX执行完不用返回</span><br><span class="line">            ENDP    ;结束子程序,于PROC一起使用</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu03.png" alt="CM4内核的指令"></p>
<ol start="5">
<li>中断服务函数</li>
</ol>
<p>都是可以自己修改的,因为是[weak]弱定义,如果我们自己写了会执行我们自己写的,如果没有的写的话就会执行汇编语言自己写的,这里注意 如果我们自己写的话 函数名一定要写对!!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">NMI_Handler     PROC    ;系统异常</span><br><span class="line">                EXPORT  NMI_Handler           [WEAK]</span><br><span class="line">                B       .  ;这个表示可以无限循环,可以被其他函数调用 这函数可以在C语言中实现</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler       [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC    ;外部中断</span><br><span class="line">                EXPORT  WWDG_IRQHandler       [WEAK]</span><br><span class="line">                EXPORT  PVD_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  TAMP_STAMP_IRQHandler [WEAK]</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">LTDC_IRQHandler</span><br><span class="line">LTDC_ER_IRQHandler</span><br><span class="line">DMA2D_IRQHandler</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>堆栈的初始化</li>
</ol>
<p>程序的开头我们分配了堆和栈的大小,以及起始地址和结束地址</p>
<p>这里是用C语言来实现初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1 ALIGN</span><br><span class="line"></span><br><span class="line">ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示4字节对齐。</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;用户栈和堆初始化,由C库函数_main来完成</span><br><span class="line">IF      :DEF:__MICROLIB  ;这个宏在KEIL里面开启,开发环境ide;TARGET-MICROLIB 这个勾勾上</span><br><span class="line"></span><br><span class="line">EXPORT  __initial_sp ;知道栈和堆的地址</span><br><span class="line">EXPORT  __heap_base </span><br><span class="line">EXPORT  __heap_limit</span><br><span class="line"> </span><br><span class="line">ELSE ;如果</span><br><span class="line"></span><br><span class="line">IMPORT  __use_two_region_memory  ; 这个函数由用户自己实现</span><br><span class="line">EXPORT  __user_initial_stackheap </span><br><span class="line"></span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">LDR     R0, =  Heap_Mem                   ;这是CPU的暂存寄存器,CPU执行程序用的</span><br><span class="line">LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">LDR     R3, = Stack_Mem</span><br><span class="line">BX      LR</span><br><span class="line"></span><br><span class="line">ALIGN</span><br><span class="line"></span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>分配栈,堆的空间</p>
</li>
<li><p>中断向量表 </p>
</li>
<li><p>复位程序- 系统上电执行的第一个程序</p>
</li>
<li><p>中断服务程序,防止用户中断服务程序编写错误,进入无限循环</p>
</li>
<li><p>用户堆和栈的初始化</p>
</li>
<li><p>最后就进入到c的世界                    </p>
</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%94%B5%E8%B5%9B%E5%87%86%E5%A4%87/">电赛准备</a><a class="post-meta__tags" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a></div><div class="post_share"><div class="social-share" data-image="https://b.zhutix.com/bizhi/geometrix/53.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/"><img class="prev-cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">STM32学习（中级篇）</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">51单片机学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记"><img class="cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-22</div><div class="title">51单片机学习笔记</div></div></a></div><div><a href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/" title="STM32学习（中级篇）"><img class="cover" src="https://b.zhutix.com/bizhi/geometrix/53.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-08</div><div class="title">STM32学习（中级篇）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81Nzc4Ny8zNDI1MA"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img.166.net/reunionpub/ds/nbot/20210317/232642-0ohjgimbna.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Carl</div><div class="author-info__description">卡卡的博客，欢迎访问</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Sugarchen7"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Sugarchen7" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1515631876@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">雪花❄️在复杂多变的云层中都经历了截然不同的一生，那些成熟很快的孩子们很棒，但晚熟的也一时难得，每个人都有自己独有的时区，所以不必羡慕身边的谁很早就拥有了什么，也不必为了慌张的追赶而错过了沿途的风景，这个过程对有些人来说可能会很早对有些人说可能会很晚，重要的是--向前。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DAP%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">DAP仿真软件的配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSTM32"><span class="toc-number">2.</span> <span class="toc-text">什么是STM32</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E7%9A%84%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">STM32的引脚说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84"><span class="toc-number">3.1.</span> <span class="toc-text">寄存器映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5GPIOB%E5%8F%A3%E4%B8%BA%E4%BE%8B%E5%AD%90"><span class="toc-number">3.2.</span> <span class="toc-text">以GPIOB口为例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.</span> <span class="toc-text">新建工程模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E4%BA%AE%E4%B8%80%E7%9B%8F%E7%81%AF-%E7%AE%80%E6%98%93%E7%89%88"><span class="toc-number">4.1.</span> <span class="toc-text">点亮一盏灯(简易版)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%82%B9%E4%BA%AE%E4%B8%80%E7%9B%8F%E7%81%AF"><span class="toc-number">5.</span> <span class="toc-text">使用寄存器点亮一盏灯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BBGPIO%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE"><span class="toc-number">5.1.</span> <span class="toc-text">读GPIO的系统框图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">5.2.</span> <span class="toc-text">自己写寄存器映射到头文件中</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E5%BB%BASTM32%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E9%9B%8F%E5%BD%A2"><span class="toc-number">6.</span> <span class="toc-text">构建STM32库函数的雏形</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BB%93%E6%9E%84%E4%BD%93%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%9C%B0%E5%9D%80"><span class="toc-number">6.1.</span> <span class="toc-text">通过结构体来访问地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BB%BA%E7%AB%8B%E5%BA%93%E5%87%BD%E6%95%B0%E6%9D%A5%E6%8E%A7%E5%88%B6GPIO"><span class="toc-number">6.2.</span> <span class="toc-text">通过建立库函数来控制GPIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">构建初始化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-number">6.4.</span> <span class="toc-text">提高代码的可移植性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">固件库编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%9B%BA%E4%BB%B6%E5%BA%93%E5%86%85%E5%AE%B9"><span class="toc-number">7.1.</span> <span class="toc-text">分析固件库内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">7.2.</span> <span class="toc-text">固件库的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%B8%A6%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.</span> <span class="toc-text">建立带固件库的工程模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%9B%BA%E4%BB%B6%E5%BA%93%E7%BC%96%E7%A8%8B%E7%82%B9%E4%BA%AELED"><span class="toc-number">9.</span> <span class="toc-text">利用固件库编程点亮LED</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E7%81%AF"><span class="toc-number">9.1.</span> <span class="toc-text">点灯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-number">9.2.</span> <span class="toc-text">实现流水灯</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO%E8%BE%93%E5%85%A5-%E6%8C%89%E9%94%AE%E6%A3%80%E6%B5%8B"><span class="toc-number">10.</span> <span class="toc-text">GPIO输入- 按键检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.1.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.2.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">10.3.</span> <span class="toc-text">编写好的文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">11.</span> <span class="toc-text">GPIO的输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%AF%9451-%E6%80%BB%E7%BA%BF%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">11.1.</span> <span class="toc-text">类比51 总线操作和位操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%B8%A6%E6%93%8D%E4%BD%9C"><span class="toc-number">11.2.</span> <span class="toc-text">位带操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%B8%A6%E5%9C%B0%E5%8C%BA%E5%92%8C%E5%A4%96%E8%AE%BE%E5%88%AB%E5%90%8D%E5%8F%96%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">11.3.</span> <span class="toc-text">位带地区和外设别名取的转换：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%AE%BE%E4%BD%8D%E5%B8%A6%E5%88%AB%E5%90%8D%E5%8C%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">11.3.0.1.</span> <span class="toc-text">外设位带别名区地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SRAM%E4%BD%8D%E5%B8%A6%E5%88%AB%E5%90%8D%E5%8C%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">11.3.0.2.</span> <span class="toc-text">SRAM位带别名区地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.4.</span> <span class="toc-text">软件实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6-%E4%BA%86%E8%A7%A3"><span class="toc-number">12.</span> <span class="toc-text">启动文件(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text">启动文件的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">12.2.</span> <span class="toc-text">启动文件的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">12.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/" title="STM32学习（中级篇）"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32学习（中级篇）"/></a><div class="content"><a class="title" href="/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/" title="STM32学习（中级篇）">STM32学习（中级篇）</a><time datetime="2023-01-08T13:16:41.000Z" title="发表于 2023-01-08 21:16:41">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/" title="STM32学习（入门篇）"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32学习（入门篇）"/></a><div class="content"><a class="title" href="/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/" title="STM32学习（入门篇）">STM32学习（入门篇）</a><time datetime="2022-12-29T14:39:12.000Z" title="发表于 2022-12-29 22:39:12">2022-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="51单片机学习笔记"/></a><div class="content"><a class="title" href="/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="51单片机学习笔记">51单片机学习笔记</a><time datetime="2022-12-22T13:27:08.000Z" title="发表于 2022-12-22 21:27:08">2022-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/20/LaTex%E7%9A%84%E4%BD%BF%E7%94%A8/" title="LaTex的基本语法"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LaTex的基本语法"/></a><div class="content"><a class="title" href="/2022/12/20/LaTex%E7%9A%84%E4%BD%BF%E7%94%A8/" title="LaTex的基本语法">LaTex的基本语法</a><time datetime="2022-12-20T05:09:16.000Z" title="发表于 2022-12-20 13:09:16">2022-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown-Typora/" title="如何使用Markdown+ Typora"><img src="https://b.zhutix.com/bizhi/geometrix/53.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何使用Markdown+ Typora"/></a><div class="content"><a class="title" href="/2022/12/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown-Typora/" title="如何使用Markdown+ Typora">如何使用Markdown+ Typora</a><time datetime="2022-12-18T07:04:09.000Z" title="发表于 2022-12-18 15:04:09">2022-12-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Carl</div><div class="footer_custom_text">一个人能走多远关键在于与谁同行，我愿用跨越山海的陪伴换来你金钱的点赞👍</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="8008663318" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>