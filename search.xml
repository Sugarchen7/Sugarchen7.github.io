<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LaTex的基本语法</title>
    <url>/2022/12/20/LaTex%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文是B站以下两视频的学习笔记<br><a href="https://www.bilibili.com/video/BV15x411j7k6?p=1&amp;vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7">latex中文教程-15集从入门到精通包</a></p>
<p><a href="https://www.bilibili.com/video/BV1Zh411y7ps/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7">数模&amp;美赛之LaTeX攻破</a></p>
<h1 id="LaTeX-的基本框架"><a href="#LaTeX-的基本框架" class="headerlink" title="$LaTeX$的基本框架"></a>$LaTeX$的基本框架</h1><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">%导言区</span><br><span class="line">\<span class="selector-tag">documentclass</span>&#123;<span class="selector-tag">article</span>&#125; %这里有<span class="selector-tag">article</span> <span class="selector-tag">book</span> <span class="selector-tag">letter</span> <span class="selector-tag">report</span>等格式</span><br><span class="line">\<span class="selector-tag">usepackage</span>&#123;<span class="selector-tag">ctex</span>&#125; % 引入中文包,可以在正文区里输入中文</span><br><span class="line">\<span class="selector-tag">author</span>&#123;<span class="selector-tag">Carl</span>&#125;</span><br><span class="line">\<span class="selector-tag">date</span> &#123;\<span class="selector-tag">today</span>&#125;</span><br><span class="line">\<span class="selector-tag">title</span>&#123;<span class="selector-tag">My</span> <span class="selector-tag">first</span> <span class="selector-tag">document</span>&#125;</span><br><span class="line">%正文区<span class="selector-tag">-</span>一个<span class="selector-tag">LaTeX</span>文件中只有一个正文去</span><br><span class="line">\<span class="selector-tag">begin</span>&#123;<span class="selector-tag">document</span>&#125;	</span><br><span class="line">	\<span class="selector-tag">maketitle</span>	%在<span class="selector-tag">letter</span>中无法使用此命令</span><br><span class="line">	</span><br><span class="line">	<span class="selector-tag">hello</span> <span class="selector-tag">world</span></span><br><span class="line">	你好世界</span><br><span class="line">			%这里用空行可以另起一行</span><br><span class="line">	这是一个公式:$<span class="selector-tag">f</span>(x)=<span class="selector-tag">x</span>^<span class="number">2</span>+<span class="number">2</span><span class="selector-tag">x</span>+<span class="number">1</span>$ %单美元符号 接在后面输入公式</span><br><span class="line">	</span><br><span class="line">	这是另一个公式:$$<span class="selector-tag">f</span>(x)=<span class="number">3</span><span class="selector-tag">x</span>^<span class="number">2</span>+<span class="number">2</span><span class="selector-tag">x</span>+<span class="number">1</span>$$ %双美元符号 另起一行输入公式</span><br><span class="line">\<span class="selector-tag">end</span>&#123;<span class="selector-tag">document</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LaTeX-中文架构的搭建"><a href="#LaTeX-中文架构的搭建" class="headerlink" title="$LaTeX$ 中文架构的搭建"></a>$LaTeX$ 中文架构的搭建</h1><h2 id="首先设置"><a href="#首先设置" class="headerlink" title="首先设置"></a>首先设置</h2><ul>
<li>选项-构建-XeLaTeX</li>
<li>编译器-UTF-8</li>
</ul>
<h2 id="搭建中文架构"><a href="#搭建中文架构" class="headerlink" title="搭建中文架构"></a>搭建中文架构</h2><p>ctex 宏包和文档类2进一步封装了 CJK、xeCJK、luatexja 等宏包，使得用户在排版中文时 不用再考虑排版引擎等细节。</p>
<p>ctex 宏包本身用于配合各种文档类排版中文，而 ctex 文档类对 LATEX 的标准文档类进行了封装，对一些排版根据中文排版习惯做了调整，包括 ctexart / ctexrep / ctexbook。ctex 宏包和文档类能够识别操作系统和 TEX 发行版中安装的中文字体，因此基本 无需额外配置即可排版中文文档。<a href="lshort-zh-cn">^1</a></p>
<p>下面举一个使用 ctex 文档类排版中文的最简例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">在\LaTeX&#123;&#125;中排版中文。</span><br><span class="line">汉字和English单词混排，通常不需要在中英文之间添加额外的空格。</span><br><span class="line">当然，为了代码的可读性，加上汉字和 English 之间的空格也无妨。</span><br><span class="line">汉字换行时不会引入多余的空格。</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LaTeX-字体字号的设置"><a href="#LaTeX-字体字号的设置" class="headerlink" title="$LaTeX$ 字体字号的设置"></a>$LaTeX$ 字体字号的设置</h1><h2 id="字体设置的两种方式"><a href="#字体设置的两种方式" class="headerlink" title="字体设置的两种方式"></a>字体设置的两种方式</h2><ul>
<li>字体声明 <code>\texterm&#123;Roman Family&#125;</code></li>
<li>字体命令<code>&#123;\texterm Roman Family&#125; %这里的大括号表示作用的范围</code></li>
</ul>
<h2 id="字体族的设置"><a href="#字体族的设置" class="headerlink" title="字体族的设置"></a>字体族的设置</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>\rmfamily</td>
<td>\textrm{…}</td>
<td>roman</td>
<td align="center">衬线字体（罗马体）</td>
</tr>
<tr>
<td>\sffamily</td>
<td>\textsf{…}</td>
<td>sans serif</td>
<td align="center">无衬线字体</td>
</tr>
<tr>
<td>\ttfamily</td>
<td>\texttt{…}</td>
<td>typewriter</td>
<td align="center">等宽字体</td>
</tr>
</tbody></table>
<h2 id="字体系列的设置-粗细"><a href="#字体系列的设置-粗细" class="headerlink" title="字体系列的设置(粗细)"></a>字体系列的设置(粗细)</h2><table>
<thead>
<tr>
<th>\mdseries</th>
<th>\textmd{…}</th>
<th>medium</th>
<th>正常粗细（中等）</th>
</tr>
</thead>
<tbody><tr>
<td>\bfseries</td>
<td>\textbf{…}</td>
<td><strong>bold face</strong></td>
<td>粗体</td>
</tr>
</tbody></table>
<h2 id="字体形状的设置"><a href="#字体形状的设置" class="headerlink" title="字体形状的设置"></a>字体形状的设置</h2><table>
<thead>
<tr>
<th>\upshape</th>
<th>\upshape</th>
<th>upright</th>
<th>直立体</th>
</tr>
</thead>
<tbody><tr>
<td>\itshape</td>
<td>\textit{…}</td>
<td>italic</td>
<td>意大利斜体</td>
</tr>
<tr>
<td>\slshape</td>
<td>\textsl{…}</td>
<td>slanted</td>
<td>倾斜体</td>
</tr>
<tr>
<td>\scshape</td>
<td>\textsc{…}</td>
<td>SMALL CAPS</td>
<td>小型大写字母</td>
</tr>
</tbody></table>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%字体字号设置</span></span><br><span class="line"><span class="keyword">\documentclass</span>[10pt]&#123;article&#125;<span class="comment">%10磅是默认正常的字体大小，即下文中的normalsize</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\myfont</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;<span class="keyword">\textsf</span>&#123;Fancy Text&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">%字体族设置(罗马字体、无衬线字体、打字机字体)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\textrm</span>&#123;Roman Family&#125; <span class="keyword">\textsf</span>&#123;Scan Serif Family&#125;<span class="keyword">\texttt</span>&#123;Typewriter Family&#125;<span class="comment">%\textrm等是字体命令，大括号里是作用到的文字</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\rmfamily</span> Roman Family&#125; &#123;<span class="keyword">\sffamily</span> Scan Serif Family&#125;&#123;<span class="keyword">\ttfamily</span> Typewriter Family&#125;<span class="comment">%\rmfamily是字体声明，后面紧跟的文字是作用到的文字</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\sffamily</span> Who are you?you find self on everyone around.take you as the same as others!&#125;</span><br><span class="line">&#123;<span class="keyword">\ttfamily</span> Are you aiser than others?&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%字体系列设置(粗细、宽度)，\textbf可以对字体加粗</span></span><br><span class="line"><span class="keyword">\textmd</span>&#123;Medium Series&#125; <span class="keyword">\textbf</span>&#123;Boldface Series&#125;<span class="comment">%\textmd等是字体命令，大括号里是作用到的文字</span></span><br><span class="line">&#123;<span class="keyword">\mdseries</span> Medium Series&#125; &#123;<span class="keyword">\bfseries</span> Boldface Series&#125;<span class="comment">%字体声明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%字体形状(直立、斜体、伪斜体、小型大写)</span></span><br><span class="line"><span class="keyword">\textup</span>&#123;Upright Shape&#125; <span class="keyword">\textit</span>&#123;Italic Shape&#125; <span class="comment">%字体命令</span></span><br><span class="line"><span class="keyword">\textsl</span>&#123;Slanted Shape&#125; <span class="keyword">\textsc</span>&#123;Small Caps Shape&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\upshape</span> Upright Shape&#125; &#123;<span class="keyword">\itshape</span> Italic Shape &#125;<span class="comment">%字体声明</span></span><br><span class="line">&#123;<span class="keyword">\slshape</span> Slanted Shape&#125;</span><br><span class="line">&#123;<span class="keyword">\scshape</span> Small Caps Shape&#125;</span><br></pre></td></tr></table></figure>



<h2 id="英文字体大小的设置"><a href="#英文字体大小的设置" class="headerlink" title="英文字体大小的设置"></a>英文字体大小的设置</h2><p>控制文档的参数:<code>\documentclass[11pt]&#123;article&#125;</code>                 </p>
<table>
<thead>
<tr>
<th>字号</th>
<th>10pt 选项（默认）</th>
<th>11pt 选项</th>
<th>12pt 选项</th>
</tr>
</thead>
<tbody><tr>
<td>\tiny</td>
<td>5pt</td>
<td>6pt</td>
<td>6pt</td>
</tr>
<tr>
<td>\scriptsize</td>
<td>7pt</td>
<td>8pt</td>
<td>8pt</td>
</tr>
<tr>
<td>\footnotesize</td>
<td>8pt</td>
<td>9pt</td>
<td>10pt</td>
</tr>
<tr>
<td>\small</td>
<td>9pt</td>
<td>10pt</td>
<td>10.95pt</td>
</tr>
<tr>
<td>\normalsize</td>
<td>10pt</td>
<td>10.95pt</td>
<td>12pt</td>
</tr>
<tr>
<td>\large</td>
<td>12pt</td>
<td>12pt</td>
<td>14.4pt</td>
</tr>
<tr>
<td>\Large</td>
<td>14.4pt</td>
<td>14.4pt</td>
<td>17.28pt</td>
</tr>
<tr>
<td>\LARGE</td>
<td>17.28pt</td>
<td>17.28pt</td>
<td>20.74pt</td>
</tr>
<tr>
<td>\huge</td>
<td>20.74pt</td>
<td>20.74pt</td>
<td>24.88pt</td>
</tr>
<tr>
<td>\Huge</td>
<td>24.88pt</td>
<td>24.88pt</td>
<td>24.88pt</td>
</tr>
</tbody></table>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%字体大小</span></span><br><span class="line">&#123;<span class="keyword">\tiny</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\scriptsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\footnotesize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\small</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\normalsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\Large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\LARGE</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\huge</span>  Hello &#125;<span class="keyword">\\</span> </span><br></pre></td></tr></table></figure>



<h2 id="中文字体的设置"><a href="#中文字体的设置" class="headerlink" title="中文字体的设置"></a>中文字体的设置</h2><p>在引入了中文宏包后</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">\songti</span> 宋体&#125; <span class="keyword">\quad</span> &#123;<span class="keyword">\heiti</span> 黑体&#125; <span class="keyword">\quad</span> &#123;<span class="keyword">\fangsong</span> 仿宋&#125; <span class="keyword">\quad</span> &#123;<span class="keyword">\kaiti</span> 楷体&#125;</span><br><span class="line"><span class="comment">%中文的粗细设置</span></span><br><span class="line"><span class="keyword">\textbf</span>&#123;粗体&#125; <span class="keyword">\quad</span> <span class="keyword">\textit</span>&#123;斜体&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中文字体大小的设置"><a href="#中文字体大小的设置" class="headerlink" title="中文字体大小的设置"></a>中文字体大小的设置</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\zihao</span>&#123;5&#125; <span class="comment">%里面填字号</span></span><br></pre></td></tr></table></figure>

<h2 id="函数与字体设置分离的思想"><a href="#函数与字体设置分离的思想" class="headerlink" title="函数与字体设置分离的思想"></a>函数与字体设置分离的思想</h2><p>在导言区中设置函数<code>\newcommand&#123;\myfont&#125;&#123;\textbf&#123;\textbf&#125;&#123;\textsf&#123;Fancy Text&#125;&#125;&#125;</code></p>
<p>在正文中使用命令<code>\myfont</code></p>
<hr>
<h1 id="LaTeX-的篇章结构"><a href="#LaTeX-的篇章结构" class="headerlink" title="$LaTeX$ 的篇章结构"></a>$LaTeX$ 的篇章结构</h1><h3 id="标题的设置"><a href="#标题的设置" class="headerlink" title="标题的设置"></a>标题的设置</h3><ul>
<li><code>\section</code>为一级标题</li>
<li><code>\subsection</code>为二级标题</li>
<li><code>\subsubsection</code>为三级标题 ….</li>
</ul>
<p>在导言区可以设置标题的格式[^2]</p>
<p>[^2]:详情见ctext 第七章标题格式的设置</p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ol>
<li><strong>空一行</strong>  (推荐使用这个)</li>
<li>\ \ 两个反斜杠 注意此时首行不缩进</li>
<li><code>\par</code>使用命令</li>
</ol>
<h2 id="ctextbook"><a href="#ctextbook" class="headerlink" title="ctextbook"></a>ctextbook</h2><ul>
<li><code>\chart</code>设置章节</li>
<li><code>\tableofcontents</code>设置目录</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%文档基本结构</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\title</span>&#123;First Tex File&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Carl&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\maketitle</span><span class="comment">%使得导言区的设置生效</span></span><br><span class="line">	<span class="keyword">\section</span>&#123;引言&#125;</span><br><span class="line">	中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。</span><br><span class="line">	</span><br><span class="line">	中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。<span class="keyword">\par</span></span><br><span class="line">	中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。<span class="keyword">\\</span>中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。</span><br><span class="line">	<span class="keyword">\section</span>&#123;实验方法&#125;</span><br><span class="line">	<span class="keyword">\section</span>&#123;实验结果&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>&#123;数据&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>&#123;图表&#125;</span><br><span class="line">	<span class="keyword">\subsubsection</span>&#123;实验过程&#125;</span><br><span class="line">	<span class="keyword">\section</span>&#123;结论&#125;</span><br><span class="line">	<span class="keyword">\section</span>&#123;致谢&#125;	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul>
<li>在英文段落中两个单词直接空一格，注意此时不管几个空格都当作一个空格</li>
<li>中文段落中，两个中文之间加空格，视作无空格</li>
<li>在中文英文都有的段落中，中文和因为之间会存在一个空格</li>
<li>段落首行的缩进是自动产生的！不可以用空格代替!!!</li>
</ul>
<p>手动加入空格</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\quad</span> <span class="comment">%一个空格</span></span><br><span class="line"><span class="keyword">\qquad</span> <span class="comment">%两个空格</span></span><br><span class="line"><span class="comment">%... 更多可以查询手册</span></span><br></pre></td></tr></table></figure>



<h2 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\#</span> <span class="keyword">\$</span> <span class="keyword">\&#123;</span>  <span class="keyword">\&#125;</span> <span class="keyword">\~</span>&#123;&#125; <span class="keyword">\_</span>&#123;&#125; <span class="keyword">\^</span>&#123;&#125; <span class="keyword">\textbackslash</span></span><br></pre></td></tr></table></figure>

<h2 id="排版符号"><a href="#排版符号" class="headerlink" title="排版符号"></a>排版符号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\S \P \dag \ddag \copyright \pounds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="标志符号"><a href="#标志符号" class="headerlink" title="标志符号"></a>标志符号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ </span>TeX&#123;&#125; <span class="keyword">\ </span>LaTeX&#123;&#125;  <span class="keyword">\ </span>LaTeXe&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%XlLaTeX用xltxtra宏包提供</span></span><br><span class="line"><span class="keyword">\XlLaTeX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%其他标志符号见手册</span></span><br></pre></td></tr></table></figure>

<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">` <span class="comment">%左单引号 </span></span><br><span class="line">&#x27; <span class="comment">%右单引号 </span></span><br><span class="line">`` <span class="comment">%左双引号 </span></span><br><span class="line">&#x27;&#x27; <span class="comment">%右双引号 </span></span><br></pre></td></tr></table></figure>

<h2 id="连字符"><a href="#连字符" class="headerlink" title="连字符"></a>连字符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- -- ---</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><ul>
<li><em><strong>texstudio最上方向导里有图片插入，可以不用自己写代码，不过导言区需要加个\usepackage{graphicx}命令</strong></em></li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%导言区内</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125; <span class="comment">%导入宏包</span></span><br><span class="line"><span class="keyword">\graphicspath</span>&#123;&#123;figures/&#125;,&#123;pics/&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区内</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[设置参数]&#123;图像名字&#125;</span><br><span class="line"><span class="comment">% 这里推荐用 texstudio最上方向导里的图片插入</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="表格的制作"><a href="#表格的制作" class="headerlink" title="表格的制作"></a>表格的制作</h1><ul>
<li>\\   表示换行</li>
<li>&amp;    连接不同的列</li>
<li>l      表示左对齐</li>
<li>c      表示居中对齐</li>
<li>r      表示右对齐</li>
<li>p{宽度}  控制宽度,注意单位</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 在正文区中</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l| c| c| c| p&#123;宽度&#125;|&#125;<span class="comment">%会有5列，指定每列的居中形式,|表示每列中间有竖线分开.||表示双竖线</span></span><br><span class="line">	<span class="keyword">\hline</span> <span class="comment">%每行之间由横线分开.\hline \hline 表示双横线</span></span><br><span class="line">	姓名<span class="built_in">&amp;</span>语文<span class="built_in">&amp;</span>数学<span class="built_in">&amp;</span>外语<span class="built_in">&amp;</span>政治<span class="keyword">\\</span><span class="comment">%\\表示换行</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line">	张三<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line">	张1<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line">	张2<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="浮动体"><a href="#浮动体" class="headerlink" title="浮动体"></a>浮动体</h1><ul>
<li>灵活分页</li>
<li>给图标加标题</li>
<li>交叉引用</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%图片的浮动体</span></span><br><span class="line"><span class="keyword">\LaTeX</span>&#123;&#125;中<span class="keyword">\TeX</span> 系统的吉祥物--小狮子见图<span class="keyword">\ref</span>&#123;fig-lion&#125; <span class="comment">%交叉引用</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp] <span class="comment">%[htbp]表示浮动体的排版位置</span></span><br><span class="line">	<span class="keyword">\centering</span> <span class="comment">%使得以下内容居中的命令</span></span><br><span class="line">	<span class="keyword">\includegraphics</span>&#123;two2.jpg&#125; <span class="comment">%插入图片</span></span><br><span class="line">	<span class="comment">%\label命令为浮动体设置标签，\ref引用该标签</span></span><br><span class="line">	<span class="keyword">\caption</span>&#123;<span class="keyword">\TeX</span> 系统的吉祥物---小狮子&#125;<span class="keyword">\label</span>&#123;fig-lion&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">%表格的浮动体</span></span><br><span class="line">在<span class="keyword">\LaTeX</span>&#123;&#125;中也可以使用表<span class="keyword">\ref</span>&#123;tab-score&#125;所示的表格</span><br><span class="line">	<span class="keyword">\begin</span>&#123;table&#125;[htbp]</span><br><span class="line">		<span class="keyword">\centering</span></span><br><span class="line">		<span class="keyword">\caption</span>&#123;成绩单&#125;<span class="keyword">\label</span>&#123;tab-score&#125;</span><br><span class="line">		<span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l|c|c|c|r|&#125;</span><br><span class="line">			<span class="keyword">\hline</span><span class="comment">%每行之间由横线分开</span></span><br><span class="line">			姓名<span class="built_in">&amp;</span>语文<span class="built_in">&amp;</span>数学<span class="built_in">&amp;</span>外语<span class="built_in">&amp;</span>政治<span class="keyword">\\</span><span class="comment">%\\表示换行</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">			张三<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">			张1<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">			张2<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">		<span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;table&#125;	</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>可以使用软件直接生成公式复制到$LaTeX$中</p>
<p>软件名: Mathpix</p>
<h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">1.美元符号 <span class="built_in">$</span>a+b=b+a <span class="built_in">$</span></span><br><span class="line">2.小括号 <span class="keyword">\(</span>a+b=b+a<span class="keyword">\)</span></span><br><span class="line">3.浮动体math环境</span><br><span class="line"><span class="keyword">\begin</span>&#123;math&#125;</span><br><span class="line">a+b=b+a</span><br><span class="line"><span class="keyword">\end</span>&#123;math&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><ul>
<li>使用<code>^</code> 符号</li>
</ul>
<p>比如<code>2^2</code>的效果是 $2^2$.但是后面只能跟一个字符</p>
<p>如果需要跟多个字符则需要使用^{}</p>
<p>比如2^{20}的效果是:  $2^{20}$</p>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>使用_符号</p>
<p>比如a_1,a_2,a_3. $a_1,a_2,a_3$. 但是后面也只能跟一个字符</p>
<p>如果需要跟多个字符则需要使用_{}</p>
<p>比如a_{20}的效果是:   </p>
<p>$a_{20}$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\beta</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\gamma</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\epsilon</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\pi</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\omega</span><span class="built_in">$</span>	</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Gamma</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Delta</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Theta</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Pi</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>得到:</p>
<p>$\alpha$<br>$\beta$<br>$\gamma$<br>$\epsilon$<br>$\pi$<br>$\omega$<br>$\Gamma$<br>$\Delta$<br>$\Theta$<br>$\Pi$<br>$\Omega$</p>
<h2 id="数学公式-1"><a href="#数学公式-1" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\log</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sin</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\cos</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\arccos</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\arcsin</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\ln</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%以及联合使用</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sin</span><span class="built_in">^</span>2x+<span class="keyword">\cos</span><span class="built_in">^</span>2x=1<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;2&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;x<span class="built_in">^</span>2+y<span class="built_in">^</span>2&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;2+<span class="keyword">\sqrt</span>&#123;2&#125;&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>[4]&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>得到:</p>
<p>$\log$<br>$\sin$<br>$\cos$<br>$\arccos$<br>$\arcsin$<br>$\ln$</p>
<p>$\sin^2x+\cos^2x=1$<br>$\sqrt{2}$<br>$\sqrt{x^2+y^2}$<br>$\sqrt{2+\sqrt{2}}$<br>$\sqrt[4]{x}$</p>
<h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%两种写法</span></span><br><span class="line">1.大约是原体积的<span class="built_in">$</span>3/4<span class="built_in">$</span></span><br><span class="line">2.大约是原体积的<span class="built_in">$</span><span class="keyword">\frac</span>&#123;3&#125;&#123;4&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%1.</span></span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%不会自动编号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">\begin</span>&#123;displaymath&#125;</span><br><span class="line">		2x<span class="built_in">^</span>2+5x+3=6	</span><br><span class="line">	<span class="keyword">\end</span>&#123;displaymath&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%会自动编号!这个很重要</span></span><br><span class="line"></span><br><span class="line">	交换律见式<span class="keyword">\ref</span>&#123;eq:commutative&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">		a+b=b+a <span class="keyword">\label</span>&#123;eq:commutative&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%不会自动编号的equation环境</span></span><br><span class="line"><span class="comment">%注意要引用一个宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;equation*&#125;</span><br><span class="line">		a+b=b+a <span class="keyword">\label</span>&#123;eq:commutative&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;equation*&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="矩阵的生成"><a href="#矩阵的生成" class="headerlink" title="矩阵的生成"></a>矩阵的生成</h1><ul>
<li>省略号: <code>\dots(水平), \vdots(垂直), \ddots(斜的), adots(需要自己配置)</code></li>
<li><code>\adot</code>的效果.可以直接用<code>\iddots</code>生成，但要调用<code>mathdots</code>宏包</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%需要导入宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;<span class="comment">%&amp;分列 \\分行</span></span><br><span class="line">  0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">  1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;<span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%括号包裹的矩阵</span></span><br><span class="line"> 0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span>	</span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;vmatrix&#125;<span class="comment">%长竖线包裹的矩阵</span></span><br><span class="line">0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;bmatrix&#125;<span class="comment">%长中括号包裹的矩阵</span></span><br><span class="line">0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%括号包裹的矩阵</span></span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125;<span class="built_in">^</span>2<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;12&#125;<span class="built_in">^</span>2<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;13&#125;<span class="built_in">^</span>2<span class="keyword">\\</span></span><br><span class="line">0<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;22&#125;<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;33&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;bmatrix&#125;<span class="comment">%长中括号包裹的矩阵</span></span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125;<span class="built_in">&amp;</span><span class="keyword">\dots</span><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;1n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span><span class="keyword">\ddots</span><span class="built_in">&amp;</span><span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;<span class="built_in">_</span>&#123;n <span class="keyword">\times</span> n&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%分块矩阵(矩阵嵌套)</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1<span class="built_in">&amp;</span>0<span class="keyword">\\</span>0<span class="built_in">&amp;</span>1</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;<span class="keyword">\Large</span> 0&#125;<span class="keyword">\\</span>  <span class="comment">%生成一个很大的0</span></span><br><span class="line"><span class="keyword">\text</span>&#123;<span class="keyword">\Large</span> 0&#125;<span class="built_in">&amp;</span><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1<span class="built_in">&amp;</span>0<span class="keyword">\\</span>0<span class="built_in">&amp;</span>1</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%括号包裹的矩阵</span></span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125;<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;12&#125;<span class="built_in">&amp;</span><span class="keyword">\cdots</span><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;ln&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;22&#125;<span class="built_in">&amp;</span><span class="keyword">\cdots</span><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;2n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>		<span class="built_in">&amp;</span><span class="keyword">\dots</span> <span class="built_in">&amp;</span><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\multicolumn</span>&#123;2&#125;&#123;c&#125;&#123;<span class="keyword">\raisebox</span>&#123;1.3ex&#125;[0pt]&#123;<span class="keyword">\Huge</span> 0&#125;&#125; <span class="comment">%合并行和列;设置大小</span></span><br><span class="line"><span class="built_in">&amp;</span>		<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;nn&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">1<span class="built_in">&amp;</span><span class="keyword">\frac</span> 12 <span class="built_in">&amp;</span><span class="keyword">\dots</span> <span class="built_in">&amp;</span><span class="keyword">\frac</span> ln <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hdotsfor</span>&#123;4&#125;<span class="keyword">\\</span>  <span class="comment">%跨列的省略号：\hdotsfor&#123;&lt;列数&gt;&#125;</span></span><br><span class="line">m<span class="built_in">&amp;</span><span class="keyword">\frac</span> m2<span class="built_in">&amp;</span> <span class="keyword">\dots</span> <span class="built_in">&amp;</span><span class="keyword">\frac</span> mn</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">%行内小矩阵(smallmatrix)环境</span></span><br><span class="line">复数<span class="built_in">$</span>z=(x,y)<span class="built_in">$</span>也可以用矩阵</span><br><span class="line"><span class="keyword">\begin</span>&#123;math&#125;</span><br><span class="line">   <span class="keyword">\left</span>(<span class="comment">%需手动加上左括号</span></span><br><span class="line">   <span class="keyword">\begin</span>&#123;smallmatrix&#125;</span><br><span class="line">  x<span class="built_in">&amp;</span> -y<span class="keyword">\\</span>y<span class="built_in">&amp;</span>x</span><br><span class="line">   <span class="keyword">\end</span>&#123;smallmatrix&#125;</span><br><span class="line">   <span class="keyword">\right</span>)<span class="comment">%需手动加上右括号</span></span><br><span class="line"><span class="keyword">\end</span>&#123;math&#125;来表示</span><br><span class="line"></span><br><span class="line"><span class="comment">%array环境(类似表格环境tabular)</span></span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;r|r&#125;</span><br><span class="line"><span class="keyword">\frac</span> 12<span class="built_in">&amp;</span>0<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">0<span class="built_in">&amp;</span> -<span class="keyword">\frac</span> abc<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="多行数学公式"><a href="#多行数学公式" class="headerlink" title="多行数学公式"></a>多行数学公式</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区引入宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amssymb&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区</span></span><br><span class="line">	<span class="comment">%gather和gather*环境(可以使用\\换行)</span></span><br><span class="line">	<span class="comment">%带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">	a+b=b+a<span class="keyword">\\</span></span><br><span class="line">	ab  ba</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%不带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">	3+5=5+3<span class="keyword">\\</span></span><br><span class="line">	3 <span class="keyword">\times</span> 5=5<span class="keyword">\times</span> 3</span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%在\\前使用\notetag阻止编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">	3<span class="built_in">^</span>2+4<span class="built_in">^</span>2=5<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%align和align*环境(用&amp;对齐)</span></span><br><span class="line"><span class="comment">%带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">	x <span class="built_in">&amp;</span>=t+<span class="keyword">\cos</span> t+1<span class="keyword">\\</span></span><br><span class="line">	y <span class="built_in">&amp;</span>=2 <span class="keyword">\sin</span> t</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="comment">%不带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align*&#125;</span><br><span class="line">x <span class="built_in">&amp;</span>=t+<span class="keyword">\cos</span> t+1<span class="keyword">\\</span></span><br><span class="line">y <span class="built_in">&amp;</span>=2 <span class="keyword">\sin</span> t</span><br><span class="line"><span class="keyword">\end</span>&#123;align*&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%split环境(对齐采用align环境的方式，编号在中间)</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;split&#125;</span><br><span class="line">	<span class="keyword">\cos</span> 2x <span class="built_in">&amp;</span>=<span class="keyword">\cos</span><span class="built_in">^</span>2 x- <span class="keyword">\sin</span><span class="built_in">^</span>2 x<span class="keyword">\\</span></span><br><span class="line">	<span class="built_in">&amp;</span>=2<span class="keyword">\cos</span><span class="built_in">^</span>2 x-1</span><br><span class="line"><span class="keyword">\end</span>&#123;split&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;		</span><br><span class="line">	</span><br><span class="line"><span class="comment">%case环境</span></span><br><span class="line"><span class="comment">%每行公式中使用&amp;分隔为两部分</span></span><br><span class="line"><span class="comment">%通常表示值和后面的条件</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">	D(x)=<span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">	1,<span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;如果&#125; x <span class="keyword">\in</span> <span class="keyword">\mathbb</span>&#123;Q&#125;;<span class="keyword">\\</span></span><br><span class="line">	0,<span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;如果&#125; x <span class="keyword">\in</span> <span class="keyword">\mathbb</span>&#123;R&#125;<span class="keyword">\setminus</span><span class="keyword">\mathbb</span>&#123;Q&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用zotero实现参考文献的导入"><a href="#使用zotero实现参考文献的导入" class="headerlink" title="使用zotero实现参考文献的导入"></a>使用zotero实现参考文献的导入</h1><ul>
<li>下载zotero</li>
<li>在扩展程序中下载 save to zotero</li>
<li>在文章页面中点击 save to zotero 保存到文库中</li>
<li>在文库中导出 导出格式为BiBTeX</li>
<li>用记事本打开导出文件,复制到所写的latex文件中</li>
<li>ref,改为文章的题目方便查找</li>
<li>在正文内使用命令<code>\cite</code>选择所引用的文章即可</li>
<li><strong>注意检查格式!!!</strong></li>
</ul>
<p>在参考文献位置输入命令</p>
<p><code>\bibligraphy&#123;book&#125;</code>生成参考文献</p>
<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>新起一页 <code>\newpage</code></p>
<p><code>\appendix</code> 表示是附录部分</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\section</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;lstlisting&#125;[language=matlab] <span class="comment">% 语言可以自己选择</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">%这里面粘贴代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;lstlisting&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LaTeX</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机学习笔记</title>
    <url>/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文是<a href="%5B%E6%97%A0%E9%BC%A0%E6%A0%87%E5%A3%B0%E9%9F%B3__%E6%9C%80%E5%85%A8__%E9%83%AD%E5%A4%A9%E7%A5%A5%E5%8D%81%E5%A4%A9%E5%B8%A6%E4%BD%A0%E7%B2%BE%E9%80%9A51%E5%8D%95%E7%89%87%E6%9C%BA__%E5%B8%A6%E6%A0%87%E9%A2%98__%E5%B8%A6%E7%BD%91%E7%9B%98%E8%B5%84%E6%96%99_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1DW411a7mz/?spm_id_from=333.337.search-card.all.click&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">郭天祥老师的课堂</a>笔记</p>
<h1 id="预备知识：C51的基本语法"><a href="#预备知识：C51的基本语法" class="headerlink" title="预备知识：C51的基本语法"></a>预备知识：C51的基本语法</h1><h2 id="变量类型的大小"><a href="#变量类型的大小" class="headerlink" title="变量类型的大小"></a>变量类型的大小</h2><table>
<thead>
<tr>
<th align="center">变量类型</th>
<th align="center">位数</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">16</td>
<td align="center">$2^{-15} - 2^{15}-1$</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">32</td>
<td align="center">$2^{-31} - 2^{31}-1$</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">8</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">doubt</td>
<td align="center">64</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">16</td>
<td align="center">$0-2^{16}-1$</td>
</tr>
<tr>
<td align="center">unsigned char</td>
<td align="center">8</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">unsigned long</td>
<td align="center">32</td>
<td align="center">$0-2^{32}-1$</td>
</tr>
</tbody></table>
<p>一般会使用 <code>typedef</code>改名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br></pre></td></tr></table></figure>

<h2 id="C51特有的类型"><a href="#C51特有的类型" class="headerlink" title="C51特有的类型"></a>C51特有的类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sfr		<span class="comment">//特殊功能寄存器声明 长度:8位	0-255</span></span><br><span class="line">sfr16	<span class="comment">//特殊功能寄存器声明 长度:16位	0-65535</span></span><br><span class="line">sbit	<span class="comment">//特殊功能位声明 长度:1位  这个用的比较多</span></span><br><span class="line">bit		<span class="comment">//位变量声明 长度:1位  </span></span><br></pre></td></tr></table></figure>

<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般使用以下两个头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="51单片机学习的重点"><a href="#51单片机学习的重点" class="headerlink" title="51单片机学习的重点"></a>51单片机学习的重点</h1><ul>
<li>51单片机能够运行的基本要求: 电源, 晶振(相当于人的心脏), 复位电路</li>
<li>如何控制输入输出的高低电平</li>
<li>定时器</li>
<li>中断</li>
<li>串口通信</li>
</ul>
<hr>
<h1 id="电亮一盏灯"><a href="#电亮一盏灯" class="headerlink" title="电亮一盏灯"></a>电亮一盏灯</h1><p>本文使用的软件是KEIL4, 端口烧录使用的是: PZ-ISP(不需要冷启动)</p>
<ul>
<li>首先观察开发板上第一个发光二极管的接口是P2^0</li>
<li>创建一个程序和 <code>.c</code>文件</li>
<li>在.<code>c</code>文件中编写代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> <span class="comment">//定义51单片机的各个串口</span></span></span><br><span class="line">sbit D1=P2^<span class="number">0</span>;  \\把串口P2^<span class="number">0</span>赋值给D1</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	D1=0; //这里是低电平高效 让D1等于0的时候灯亮</span></span><br><span class="line">	P2=<span class="number">0xFE</span>;  <span class="comment">//也可以之间控制端口的值,控制第一个发光二极管亮</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="灯的闪烁和流水灯"><a href="#灯的闪烁和流水灯" class="headerlink" title="灯的闪烁和流水灯"></a>灯的闪烁和流水灯</h1><h2 id="延时函数的编写"><a href="#延时函数的编写" class="headerlink" title="延时函数的编写"></a>延时函数的编写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写延时函数注意不要超过变量的范围</span></span><br><span class="line"><span class="comment">//可以用二重函数编写</span></span><br><span class="line"><span class="comment">//编写后将晶振改为11.0592进行调试,一般不是很准确.</span></span><br></pre></td></tr></table></figure>

<p>灯的闪烁只需要，让灯亮如何延时一段时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">sbit D1=P2^<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		D1=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">		D1=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流水灯的编写"><a href="#流水灯的编写" class="headerlink" title="流水灯的编写"></a>流水灯的编写</h3><p>这里需要调用一个位变换函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">a=_crol_(a,b)//让a左移b位</span><br></pre></td></tr></table></figure>

<p>流水灯编写如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 temp=<span class="number">0xfe</span>;</span><br><span class="line">	P2=temp;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=_crol_(temp,<span class="number">1</span>);</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">		P2=temp;</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------</span><br><span class="line"><span class="comment">//不使用该函数的方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">		&#123;</span><br><span class="line">				P2=~(<span class="number">0x01</span>&lt;&lt;t);</span><br><span class="line">			delay(<span class="number">50000</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="蜂鸣器-的使用"><a href="#蜂鸣器-的使用" class="headerlink" title="蜂鸣器 的使用"></a>蜂鸣器 的使用</h1><p><strong>这里是无源蜂鸣器</strong></p>
<p>普中开发板上使用的蜂鸣器是无源蜂鸣器，属于压电式蜂鸣器类型。这里说的有源和无源，并不是指电源的意思，而是指蜂鸣器内部是否含有振荡电路，有源蜂鸣器内部自带振荡电路，只需提供电源即可发声，而无源蜂鸣器则需提供一 定频率的脉冲信号才能发声，频率大小通常在 1.5-5KHz 之间。</p>
<p>普中的板子使用了五线四项步进电机控制蜂鸣器,接在了P25上</p>
<p>让<strong>无源</strong>蜂鸣器响的操作如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是无源蜂鸣器的代码!</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u8;</span><br><span class="line">sbit beep=P2^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u16 t = <span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(t--)</span><br><span class="line">		&#123;</span><br><span class="line">			beep=!beep;</span><br><span class="line">			delay(<span class="number">100</span>);</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="51单片机各个引脚的功能"><a href="#51单片机各个引脚的功能" class="headerlink" title="51单片机各个引脚的功能"></a>51单片机各个引脚的功能</h1><ul>
<li>1-8: P1 端口</li>
<li>9：复位</li>
<li>10-17:P3端口（注意它有第二功能）见书本P16</li>
<li>18，19分别对应X1，X2，是晶振</li>
<li>20: Vss接电源</li>
<li>21-28: P2端口</li>
<li>29：PSEN: 一般不用</li>
<li>30：ALE: 会输出$1/6$的时针周期方波,接到示波器,识别单片机是否工作正常</li>
<li>31:</li>
<li>32-39: P0端口, 一般接入上拉电阻</li>
<li>40: VCC</li>
</ul>
<hr>
<h1 id="静态数码管的显示"><a href="#静态数码管的显示" class="headerlink" title="静态数码管的显示"></a>静态数码管的显示</h1><h2 id="数码管的显示"><a href="#数码管的显示" class="headerlink" title="数码管的显示"></a>数码管的显示</h2><p>数字8每一个位置放了一个发光二极管, 通过控制不同位置发光二极管的亮灭来显示不同的数字</p>
<p>数码管有两种接法</p>
<ol>
<li>共阴极接法:给高电平有效,即通过输入1来控制</li>
<li>共阳极接法:给低电平有效,即通过输入0来控制</li>
</ol>
<p>以共阴极接法为例不同数字的16进制编码如下所示</p>
<p>![数码管](51 单片机的学习/数码管.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d,</span><br><span class="line">0      1     2     3     4     5</span><br><span class="line">0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c,</span><br><span class="line">6       7     8     9     A    B</span><br><span class="line">0x39, 0x5e, 0x79, 0x71,  0x00,</span><br><span class="line">C       D     E     F    无显示</span><br></pre></td></tr></table></figure>

<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可用此代码</span></span><br><span class="line">u8 code[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h2><ul>
<li>位选:控制哪个数码管亮</li>
<li>段选: 每个数码管abcdefg都相互连接起来, 控制亮什么</li>
</ul>
<p>普中开发板利用的是三八译码器</p>
<p>郭天祥视频教程使用是寄存器控制方法大同小异</p>
<p>本文中介绍锁存器的存储方式: 先给高电平,然后放入数据,再给低电平.完成输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wela= ;<span class="comment">//位选端口</span></span><br><span class="line">dula= ;<span class="comment">//段选端口</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		wela=<span class="number">1</span>;</span><br><span class="line">		P0=   ;选择哪个灯亮</span><br><span class="line">		wela=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		dula=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择亮的数字</span></span><br><span class="line">		dula=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><ol>
<li>处理main函数的A时,发生了B</li>
<li>停止处理A,开始处理中断程序B</li>
<li>B处理完成后,接着继续处理A</li>
</ol>
<p>![中断](51 单片机的学习/中断.png)</p>
<p>![中断流程](51 单片机的学习/中断流程.png)</p>
<h2 id="中断允许寄存器-IE"><a href="#中断允许寄存器-IE" class="headerlink" title="中断允许寄存器 IE"></a>中断允许寄存器 IE</h2><p>MCS-51的CPU对中断源的开放或屏蔽,是由片内的中断允许寄存器E控制的。E的字节地址为A8H,可进行位寻址。<br>中断允许寄存器E对中断的开放和关闭实现两级控制。所谓两级控制,就是有一个总的开关中断控制位EA(E.7位),<strong>当EA=0时,所有的中断请求被屏蔽</strong>,CPU对任何中断请求都不接受;<strong>当EA= 1时,CPU开放中断,但五个中断源的中断请求是否允许,还要由企中的低5位所对应的5个中断请求允许控制位的状态来决定</strong>.<a href="%E9%83%AD%E5%A4%A9%E7%A5%A5%E6%95%99%E7%A8%8BP55">^1</a></p>
<p>AH8表示可以直接控制每个位的值</p>
<p>![中断允许控制位](51 单片机的学习/中断允许控制位.png)</p>
<h2 id="中断处理的优先级"><a href="#中断处理的优先级" class="headerlink" title="中断处理的优先级"></a>中断处理的优先级</h2><p>![中断处理的优先级](51 单片机的学习/中断处理的优先级.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这上面的优先级从高到低分别对应 0 1 2 3 4</span><br><span class="line">用于写中断服务程序中的interrupt ?  后面的数字</span><br></pre></td></tr></table></figure>

<h2 id="中断响应的条件"><a href="#中断响应的条件" class="headerlink" title="中断响应的条件"></a>中断响应的条件</h2><p>一个中断源的中断请求被响应,需满足以下条件:</p>
<ol>
<li>该中断源发出中断请求。</li>
<li>CPU开中断,即中断总允许位EA = 1。</li>
<li>申请中断的中断源的中断允许位=1,即该中断没有被屏蔽。</li>
<li>无同级或更高级中断正在被服务。</li>
</ol>
<h2 id="外部中断器功能的选择"><a href="#外部中断器功能的选择" class="headerlink" title="外部中断器功能的选择"></a>外部中断器功能的选择</h2><p>外部中断的触发有两种触发方式:电平触发方式和跳沿触发方式。</p>
<h3 id="电平触发方式-默认"><a href="#电平触发方式-默认" class="headerlink" title="电平触发方式(默认)"></a>电平触发方式(默认)</h3><p>若外部中断定义为电平触发方式,外部中断申请触发器的状态随着CPU在每个机器周期采样到的外部中断输入线的电平变化而变化,这能提高CPU对外部中断请求的响应速度。<strong>当外部中断源被设定为电平触发方式时,在中断服务程序返回之前,外部中断请求输人必须无效(即变为高电平),否则CPU返回主程序后会再次响应中断。</strong>所以电平触发方式适合于外部中断以低电平输人而且中断服务程序能清除外部中断请求源(即外部中断输入电平又变为高电平)的情况。</p>
<h3 id="跳沿触发方式"><a href="#跳沿触发方式" class="headerlink" title="跳沿触发方式"></a>跳沿触发方式</h3><p>外部中断若定义为跳沿触发方式,外部中断申请触发器能锁存外部中断输人线上的负跳变。即便是CPU暂时不能响应,中断申请标志也不会丢失。在这种方式里,如果相继连续两次采样，<strong>一个机器周期采样到外部中断输人为高，下一个机器周期采样为低,则置“1”中断申请触发器,直到CPU响应此中断时才清0。</strong>这样不会丢失中断,但输人的负脉冲宽度至少<strong>保持12个时钟周期</strong>(若晶振频率为6MHz,则为2pS),才能被CPU采样到。外部中断的跳沿触发方式适合于以负脉冲形式输入的外部中断请求。</p>
<h2 id="中断程序的编写"><a href="#中断程序的编写" class="headerlink" title="中断程序的编写"></a>中断程序的编写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">EA=<span class="number">1</span>; <span class="comment">//开启总中断</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//打开外部中断0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//主程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">extero</span><span class="params">()</span> interrupt 0</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//中断服务程序,无需声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="定时器的工作模式"><a href="#定时器的工作模式" class="headerlink" title="定时器的工作模式"></a>定时器的工作模式</h2><p>51单片机内有两个可编程的定时器/计数器T1、T0,。两个定时器/计数器都具有定时器和计数器两种工作模式.</p>
<ol>
<li><strong>定时工作模式</strong></li>
</ol>
<ul>
<li><p>定时功能也是通过计数器的计数来实现的,不过此时的计数脉冲来自单片机的内部,即每个机器周期产生一个计数脉冲,也就是每经过1个机器周期的时间,计数器加1。如果MCS -51采用12MHz晶体,则计数频率为1MHz,即每过1us的时间计数器加1。这样可以根据计数值计算出定时时间,也可根据定时时间的要求计算出计数器的初值。</p>
</li>
<li><p>MCS-51单片机的定时器/计数器具有4种工作方式(方式0、方式1、方式2和方式3),其控制字均在相应的特殊功能寄存器中,通过对特殊功能寄存器的编程,用户可方便地选择定时器/计数器两种工作模式和4种工作方式。</p>
</li>
</ul>
<ol start="2">
<li>计数工作模式</li>
</ol>
<ul>
<li>计数功能是对外来脉冲进行计数。MCS -51芯片有TD(P3.4)和TI(P3.5)两个输入引脚分别是这两个计数器的计数脉冲输入端。每当外部输人的脉冲发生负跳变时,计数器加1。</li>
</ul>
<h2 id="定时器的结构"><a href="#定时器的结构" class="headerlink" title="定时器的结构"></a>定时器的结构</h2><p> 51单片机的定时器/计数器结构.<strong>定时器/计数器TO</strong>由特殊功能寄存器**THO(高四位)、TLO(低四位)**构成,定时器/计数器T1由特殊功能寄存器TH1、TL1构成。</p>
<p>![定时器的结构](51 单片机的学习/定时器的结构.png)</p>
<p>特殊功能寄存器<strong>TMOD</strong>用于选择<strong>定时器/计数器TO、T1</strong>的工作模式和工作方式。</p>
<p>特殊功能寄存器<strong>TCON</strong>用于控制TO、T1的<strong>启动和停止计数</strong>,同时包含了TO、T1的状态。</p>
<p><strong>TMOD、TCON这两个寄存器的内容由软件设置</strong>。单片机复位时,两个寄存器的所有位都被清0。</p>
<h3 id="TMOD工作方式寄存器"><a href="#TMOD工作方式寄存器" class="headerlink" title="TMOD工作方式寄存器"></a>TMOD工作方式寄存器</h3><p>工作方式寄存器‘<strong>TMOD</strong>用于<strong>选择</strong>定时器/计数器的<strong>工作模式和工作方式</strong>,它的字节地址为89H,不能进行位寻址。TMOD一共有八位</p>
<p>前四位为M1,后四位为M2, 控制M1,M2的编码可以选择工作方式</p>
<table>
<thead>
<tr>
<th align="center">M1</th>
<th align="center">M0</th>
<th align="center">工作方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">方式0,为13位定时器/计数器</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center"><strong>方式1,为16位定时器/计数器</strong></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">方式2,8位初值自动重新装人的8位定时器/计数器</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">方式3,仅适用于T0,分成两个8位计数器，T1停止计数</td>
</tr>
</tbody></table>
<h3 id="定时器-计数器控制寄存器TCON"><a href="#定时器-计数器控制寄存器TCON" class="headerlink" title="定时器/计数器控制寄存器TCON"></a>定时器/计数器控制寄存器TCON</h3><p>TCON一共有八位</p>
<p>工作方式的不同,tocn的功能也就不同</p>
<p>TCOC是在不同方式下,</p>
<p>计数溢出标志位: 如果装满即功能位全都是1时,进入中断服务程序.</p>
<h2 id="定时器的工作方式"><a href="#定时器的工作方式" class="headerlink" title="定时器的工作方式"></a>定时器的工作方式</h2><p>四种见郭天祥老师教程的70页</p>
<ul>
<li>当前视频使用的是方式1</li>
</ul>
<p>TLO是低8位, THO是高8位</p>
<p> $X(计数个数)=2^{16}-N(计数初值)$</p>
<p>控制计数初值的大小,来控制定时的时间</p>
<p>t为时间</p>
<p>$THO=(2^{16}-t)/256$ ,即取前四位</p>
<p>$TLO=(2^{16}-t)$ % $256$ ,即取后四位</p>
<h2 id="定时器的使用步骤"><a href="#定时器的使用步骤" class="headerlink" title="定时器的使用步骤"></a>定时器的使用步骤</h2><p><strong>初始化程序应完成如下工作:</strong></p>
<ol>
<li><p>对TMOD赋值，以确定TO和T1的工作方式。</p>
</li>
<li><p>计算初值,并将其写入THO、TLO或TH1、TL1。</p>
</li>
<li><p>中断方式时，则对IE赋值，开放中断。</p>
</li>
<li><p>使TRO或TR1置位，启动定时/计数器定时或计数。</p>
</li>
</ol>
<p><strong>以方式1为例</strong>:</p>
<ol>
<li><p>对TMOD赋值: TMOD=0x01; 选择方式1 定时器0</p>
</li>
<li><p>计算THO和TLO: 控制定时器的时间 t=50000时候为50ms</p>
</li>
<li><p>开启中断: EA=1(开启总中断) ETO1=1(开启定时器0) 这里看优先级就知道是ETO</p>
</li>
<li><p>TRO=1 启动定时器0</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	tt=<span class="number">0</span>;</span><br><span class="line">    TOMD=<span class="number">0x01</span>;<span class="comment">//设置工作模式</span></span><br><span class="line">	THO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)/<span class="number">256</span>;</span><br><span class="line">    TLO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)%<span class="number">256</span>;</span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//开总断</span></span><br><span class="line">    ETO=<span class="number">1</span>;<span class="comment">//开定时器0中断</span></span><br><span class="line">    TRO=<span class="number">1</span>;<span class="comment">//启动定时器0 ,定时器加满进入一次中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tt=?)<span class="comment">//进入中断的次数 即tt个50ms</span></span><br><span class="line">        &#123;</span><br><span class="line">            tt=<span class="number">0</span>; <span class="comment">//tt清零 方便下次进入</span></span><br><span class="line">            <span class="comment">//执行程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exter0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">	tt++;</span><br><span class="line">    THO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)/<span class="number">256</span>;</span><br><span class="line">    TLO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)%<span class="number">256</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后续使用中可以增加一个初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>; <span class="comment">//初始化函数的声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init(); <span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为里面的变量都是全局变量 以及在头文件中定义好了的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	tt=<span class="number">0</span>;</span><br><span class="line">    TOMD=<span class="number">0x01</span>;<span class="comment">//设置工作模式</span></span><br><span class="line">	THO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)/<span class="number">256</span>;</span><br><span class="line">    TLO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)%<span class="number">256</span>;</span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//开总断</span></span><br><span class="line">    ETO=<span class="number">1</span>;<span class="comment">//开定时器0中断</span></span><br><span class="line">    TRO=<span class="number">1</span>;<span class="comment">//启动定时器0 ,定时器加满进入一次中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里需要注意,中断函数和delay同时在主函数中时,可能会出现问题. 因为当中断到 <strong>tt=?</strong> 时,该程序可能还在delay函数中</p>
<hr>
<h1 id="动态显示"><a href="#动态显示" class="headerlink" title="动态显示"></a>动态显示</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>位选:控制哪个数码管亮</li>
<li>段选: 每个数码管abcdefg都相互连接起来, 控制亮什么</li>
</ul>
<p>分别控制需要的数码管亮,利用位选</p>
<p>利用段选控制数码管里亮的内容</p>
<p>减少数码管亮的延时时间,当小于人眼可以分辨的快慢时.相当于同时显示了需要的数码管,以及里面的内容</p>
<h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><p>这里是普中芯片使用三八译码器的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Gs P0</span></span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>; <span class="comment">//普中芯片的三八译码器</span></span><br><span class="line"></span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//用swich语句控制位选,选择哪个灯亮,此处普中芯片使用了三八译码器</span></span><br><span class="line">		Gs=GS[i];</span><br><span class="line">		delay(<span class="number">100</span>);</span><br><span class="line">		Gs=<span class="number">0x00</span>; <span class="comment">//这句代码是消影的过程,就是显示完之后让段选为什么都不显示的状态. 防止下次位选后直接                    显示值.</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		smg_display(); <span class="comment">//动态显示的子函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是郭天祥老师视频中使用寄存器的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line">wela= ;<span class="comment">//位选端口</span></span><br><span class="line">dula= ;<span class="comment">//段选端口</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		wela=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择第一个灯亮</span></span><br><span class="line">		wela=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		dula=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择亮的数字</span></span><br><span class="line">		dula=<span class="number">0</span>;</span><br><span class="line">        p0=<span class="number">0xff</span>;<span class="comment">//这句代码是消影的过程,就是显示完之后让段选为什么都不显示的状态. 防止下次位选后直接                   显示值. 这里郭天祥老师视频中什么都不显示是0xff,之后试验中具体内容具体分析</span></span><br><span class="line">        </span><br><span class="line">        delay(<span class="number">100</span>); <span class="comment">//延时一小段时间</span></span><br><span class="line">        </span><br><span class="line">        wela=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择第二个灯亮</span></span><br><span class="line">		wela=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		dula=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择亮的数字</span></span><br><span class="line">		dula=<span class="number">0</span>;</span><br><span class="line">        delay(<span class="number">100</span>);</span><br><span class="line">        p0=<span class="number">0xff</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后面需要加显示数码管 只需复制上面代码即可.</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态消影"><a href="#动态消影" class="headerlink" title="动态消影"></a>动态消影</h3><p>在段选显示数字后,的延时函数后面,加一句代码让显示的值处于没有的状态. 防止下一次段选后直接显示上一次的内容.</p>
<hr>
<h1 id="独立键盘和矩阵键盘的检测原理及实现"><a href="#独立键盘和矩阵键盘的检测原理及实现" class="headerlink" title="独立键盘和矩阵键盘的检测原理及实现"></a>独立键盘和矩阵键盘的检测原理及实现</h1><h2 id="键盘的分类"><a href="#键盘的分类" class="headerlink" title="键盘的分类"></a>键盘的分类</h2><ul>
<li>编码键盘</li>
<li>非编码键盘: 分为独立键盘和矩阵键盘</li>
</ul>
<h2 id="独立键盘的检测原理"><a href="#独立键盘的检测原理" class="headerlink" title="独立键盘的检测原理"></a>独立键盘的检测原理</h2><p>独立键盘的原理图 如图所示</p>
<p>本文用的是普中开发板</p>
<p>![独立键盘的原理](51 单片机的学习/独立键盘的原理.png)</p>
<p>当有按键按下时 相应端口会收到一个0的信号</p>
<p>检测的代码如图所示(使用普中开发板)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按下灯亮</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit K1=P3^<span class="number">1</span>;</span><br><span class="line">sbit D1=P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	D1=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(K1==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		D1=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按下灯亮加计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line">sbit K1=P3^<span class="number">1</span>;</span><br><span class="line">sbit D1=P2^<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Gs P0</span></span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line">u8 num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(K1==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">10</span>); <span class="comment">//消除振动的影响</span></span><br><span class="line">			<span class="keyword">if</span>(K1==<span class="number">0</span>) <span class="comment">//如果按下</span></span><br><span class="line">			&#123;</span><br><span class="line">				D1=<span class="number">0</span>;</span><br><span class="line">				num++;</span><br><span class="line">				<span class="keyword">if</span>(num==<span class="number">10</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					num=<span class="number">0</span>;</span><br><span class="line">				&#125;<span class="comment">//等价于 num=num%10;防止越界</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			D1=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(K1==<span class="number">0</span>); <span class="comment">//松手检测 松手了再加一</span></span><br><span class="line">		P0=GS[num];</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩阵键盘的检测原理"><a href="#矩阵键盘的检测原理" class="headerlink" title="矩阵键盘的检测原理"></a>矩阵键盘的检测原理</h2><p>矩阵键盘的原理图</p>
<p>![矩阵键盘原理图](51 单片机的学习/矩阵键盘原理图.png)</p>
<p>检测代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line">u8 temp,num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	num=<span class="number">17</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	 	P1=<span class="number">0x7f</span>;    <span class="comment">//第一行检测 先给第一行0,其他行 为1</span></span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>) <span class="comment">//检测第一行是否有按键按下去</span></span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1; <span class="comment">//防止抖动</span></span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">0</span>; <span class="comment">//第一个按键被按下去了,从原理图中可以看出</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">2</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">3</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第二行的检测</span></span><br><span class="line">	 	P1=<span class="number">0xbf</span>;</span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1;</span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">4</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">5</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">6</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">7</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第三行的检测</span></span><br><span class="line">	 	P1=<span class="number">0xdf</span>;</span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1;</span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">8</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">9</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">10</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">11</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">	 		<span class="comment">//第四行的检测</span></span><br><span class="line">	 	P1=<span class="number">0xef</span>;</span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1;</span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">12</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">13</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">14</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">15</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个主函数的内容写入子函数中,会出现一个,没有按下去时候不知道会显示什么东西的bug,<strong>还有待改进.</strong></p>
<hr>
<h1 id="AD-DA-的工作原理及其实现"><a href="#AD-DA-的工作原理及其实现" class="headerlink" title="AD,DA 的工作原理及其实现"></a>AD,DA 的工作原理及其实现</h1><p>AD DA ,D表示数字信号,A表示模拟信号</p>
<ul>
<li>DA即数字信号转换为模拟信号</li>
</ul>
<h2 id="T型电阻网络D-A转换器"><a href="#T型电阻网络D-A转换器" class="headerlink" title="T型电阻网络D/A转换器"></a>T型电阻网络D/A转换器</h2><p>![DA转换器](51 单片机的学习/DA转换器.png)</p>
<p>![1](51 单片机的学习/1.png)</p>
<p><strong>输出电压的大小与数据量有很大的关系</strong></p>
<h2 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h2><p>ADC（analog to digital converter）也称为模数转换器，是指一个将模拟信号转变为数字信号。单片机在采集模拟信号时，通常都需要在前端加上 A/D 芯片.下面我们看ADC的几个主要数据指标</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>ADC 的分辨率是指对于允许范围内的模拟信号，它能输出离散数字信号值的 个数。这些信号值通常用二进制数来存储，因此分辨率经常用比特作为单位，且 这些离散值的个数是 2 的幂指数。 例如：12 位 ADC 的分辨率就是 12 位，或者说分辨率为满刻度的 1/(2^12)。 一个 10V 满刻度的 12 位 ADC 能分辨输入电压变化最小值是</p>
<p>$10V×1/(2^{12})=2.4mV$</p>
<h3 id="转换误差"><a href="#转换误差" class="headerlink" title="转换误差"></a>转换误差</h3><p>转换误差通常是以输出误差的最大值形式给出。它表示 A/D 转换器实际输出 的数字量和理论上的输出数字量之间的差别。常用最低有效位的倍数表示。例如 给出相对误差≤±LSB/2，这就表明实际输出的数字量和理论上应得到的输出数 字量之间的误差小于最低位的半个字。</p>
<h3 id="转换速率"><a href="#转换速率" class="headerlink" title="转换速率"></a>转换速率</h3><p>ADC 的转换速率是能够重复进行数据转换的速度，即每秒转换的次数。而完 成一次 A/D 转换所需的时间（包括稳定时间），则是转换速率的倒数。</p>
<h3 id="串行和并行"><a href="#串行和并行" class="headerlink" title="串行和并行"></a>串行和并行</h3><ul>
<li>串行:先进行一个再进行另一个</li>
<li>并行:多个同时进行,但浪费IO口</li>
</ul>
<h3 id="DAC0832"><a href="#DAC0832" class="headerlink" title="DAC0832"></a>DAC0832</h3><ul>
<li>看一个芯片的资料我们可以去 <a href="www.21ic.com">网站</a> 查找他的相关资料</li>
<li>主要看</li>
</ul>
<ol>
<li>串行还是并行</li>
<li>接口的说明</li>
<li>转换位数和转换效率</li>
<li>操作时序</li>
</ol>
<h2 id="DAC0832-的使用"><a href="#DAC0832-的使用" class="headerlink" title="DAC0832 的使用"></a>DAC0832 的使用</h2><h3 id="DAC0832的电路图"><a href="#DAC0832的电路图" class="headerlink" title="DAC0832的电路图"></a>DAC0832的电路图</h3><p>![DA原理图](51 单片机的学习/DA原理图.png)</p>
<p>单片机通过控制D0到D7的0/1;来控死发光二极管的电流大小           </p>
<h2 id="XPT2046-芯片的使用"><a href="#XPT2046-芯片的使用" class="headerlink" title="XPT2046 芯片的使用"></a>XPT2046 芯片的使用</h2><p>因为手上的是普中的开发板，所以本文使用的是XPT2046来实现数模转换。</p>
<h3 id="XPT2046芯片管脚的说明"><a href="#XPT2046芯片管脚的说明" class="headerlink" title="XPT2046芯片管脚的说明"></a>XPT2046芯片管脚的说明</h3><p>![xpt2096](51 单片机的学习/xpt2096.png)</p>
<p>![xpt2096管脚说明](51 单片机的学习/xpt2096管脚说明.png)</p>
<h3 id="XPT2046-的输入配置"><a href="#XPT2046-的输入配置" class="headerlink" title="XPT2046 的输入配置"></a>XPT2046 的输入配置</h3><p>通过控制A2,A1,A0各个值来控制 接收哪一个引脚检测的的数值</p>
<p>![xpt2096输入配置](51 单片机的学习/xpt2096输入配置.png)</p>
<h3 id="XPT2046-控制位的命令"><a href="#XPT2046-控制位的命令" class="headerlink" title="XPT2046 控制位的命令"></a>XPT2046 控制位的命令</h3><p>![XPT制表位的命令](51 单片机的学习/XPT制表位的命令.png)</p>
<p>![2](51 单片机的学习/2.png)</p>
<h3 id="XPT2046的时序图"><a href="#XPT2046的时序图" class="headerlink" title="XPT2046的时序图"></a>XPT2046的时序图</h3><p>这是编程数模转换器的重点,通过看各个管脚的时序,来编程.</p>
<p>![](51 单片机的学习/xpt2096时序图.png)</p>
<h3 id="XPT2046的连接"><a href="#XPT2046的连接" class="headerlink" title="XPT2046的连接"></a>XPT2046的连接</h3><p>![xpt2046的连接](51 单片机的学习/xpt2046的连接.png)</p>
<h3 id="XPT2046的编程"><a href="#XPT2046的编程" class="headerlink" title="XPT2046的编程"></a>XPT2046的编程</h3><p>本文是将 XPT2046 的AIN0检测到的电压值,传输到单片机,并在数码管上显示出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">sbit CS=P3^<span class="number">5</span>;</span><br><span class="line">sbit DIN=P3^<span class="number">2</span>;</span><br><span class="line">sbit CLK=P3^<span class="number">6</span>;</span><br><span class="line">sbit DOUT=P3^<span class="number">7</span>;</span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">xpt2046_wirte_data</span><span class="params">(u8 cmd)</span> <span class="comment">//读取命令 控制XPT2046的模式</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	CLK=<span class="number">0</span>;</span><br><span class="line">	_nop_(); <span class="comment">//延时一微秒</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DIN=cmd&gt;&gt;<span class="number">7</span>; <span class="comment">//先读取高位</span></span><br><span class="line">		cmd&lt;&lt;=<span class="number">1</span>;		<span class="comment">//将下一位设置为最高位</span></span><br><span class="line">		CLK=<span class="number">1</span>;		<span class="comment">//CLK 由低到高产生一个上升沿，从而写入数据</span></span><br><span class="line">		_nop_();</span><br><span class="line">		CLK=<span class="number">0</span>;</span><br><span class="line">		_nop_();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 <span class="title function_">xpt2046_read_data</span><span class="params">()</span> <span class="comment">//从XPT2046中读取数据</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	u8 i;</span><br><span class="line">	u16 dat=<span class="number">0</span>;</span><br><span class="line">	CLK = <span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		CLK=<span class="number">1</span>;		<span class="comment">//CLK 由低到高产生一个上升沿，从而写入数据</span></span><br><span class="line">		_nop_();</span><br><span class="line">		CLK=<span class="number">0</span>;</span><br><span class="line">		_nop_();</span><br><span class="line">		dat|= DOUT;<span class="comment">//先读取高位，再读取低位</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 <span class="title function_">xpt2046_read_adc_value</span><span class="params">(u8 cmd)</span> <span class="comment">//在da模块读取到数据,函数整合</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u16 dat;</span><br><span class="line">	CS=<span class="number">0</span>;</span><br><span class="line">	CLK=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	xpt2046_wirte_data(cmd);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">6</span>;i&gt;<span class="number">0</span>;i--); <span class="comment">//延时一会等待命令结束</span></span><br><span class="line"></span><br><span class="line">	CLK = <span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	CLK = <span class="number">1</span>;<span class="comment">//发送一个时钟，清除 BUSY</span></span><br><span class="line">	_nop_();</span><br><span class="line"></span><br><span class="line">	dat=xpt2046_read_data(); <span class="comment">//读取数据</span></span><br><span class="line">	CS=<span class="number">1</span>; <span class="comment">//关闭</span></span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(u8 A[],u8 i)</span><span class="comment">//动态显示</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 pos = i;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//用swich语句控制位选,选择哪个灯亮,此处普中芯片使用了三八译码器</span></span><br><span class="line">		P0=A[i-pos];</span><br><span class="line">		delay(<span class="number">100</span>);</span><br><span class="line">		P0=<span class="number">0x00</span>; <span class="comment">//这句代码是消影的过程,就是显示完之后让段选为什么都不显示的状态. 防止下次位选后直接                    显示值.</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 cmd;</span><br><span class="line">	u16 dat;</span><br><span class="line">	<span class="type">float</span> dat_v;</span><br><span class="line">	u16 det_val;</span><br><span class="line">	u8 adc_buf[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	 	cmd=<span class="number">0x94</span>;	<span class="comment">//测量电位器</span></span><br><span class="line">		dat=xpt2046_read_adc_value(cmd);  </span><br><span class="line">		dat_v = dat*<span class="number">5.0</span>/<span class="number">4096</span>;  <span class="comment">//将读取的 AD 值转换成电压</span></span><br><span class="line">		det_val=dat_v*<span class="number">10</span>;	   <span class="comment">//读取前两位有效数字</span></span><br><span class="line">		adc_buf[<span class="number">0</span>]=	GS[det_val/<span class="number">10</span>]|<span class="number">0x80</span>; <span class="comment">//个位加上小数点</span></span><br><span class="line">		adc_buf[<span class="number">1</span>]=	GS[det_val%<span class="number">10</span>];		 <span class="comment">//小数点后一位</span></span><br><span class="line">		adc_buf[<span class="number">2</span>]=	<span class="number">0x3e</span>;				<span class="comment">//单位V</span></span><br><span class="line">		smg_display(adc_buf,<span class="number">5</span>);			<span class="comment">//动态显示</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="通信的分类"><a href="#通信的分类" class="headerlink" title="通信的分类"></a>通信的分类</h2><h3 id="串行通信与并行通信"><a href="#串行通信与并行通信" class="headerlink" title="串行通信与并行通信"></a>串行通信与并行通信</h3><ol>
<li>串行通信</li>
</ol>
<p>串行通信是指使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度.其只需要少数几条线就可以在系统间交换信息，特别适 用于计算机与计算机、计算机与外设之间的远距离通信.</p>
<p>特点: 传输线少，长距离传送时成本低，且可以利用电话网等现 成的设备，但数据的传送控制比并行通信复杂.</p>
<p>![img](51 单片机的学习/BSB]G}W5JNQ2}DPUXOT2L]H.png)</p>
<p>2.并行通信</p>
<p>并行通信通常是将数据字节的各位用多条数据线同时进行传送，通常是 8 位、16 位、32 位等数据一起传输。如下图所示：</p>
<p>并行通信的特点：控制简单、传输速度快；由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难，抗干扰能力差。</p>
<p>![image-20221222195204103](51 单片机的学习/image-20221222195204103.png)</p>
<h3 id="异步通信与同步通信"><a href="#异步通信与同步通信" class="headerlink" title="异步通信与同步通信"></a>异步通信与同步通信</h3><ol>
<li><strong>异步通信</strong>(比较常用)</li>
</ol>
<p>异步通信是指通信的发送与接收设备使用<strong>各自的时钟</strong>控制数据的发送和接收过程。为使双方的收发协调，要求发送和接收设备的时钟尽可能一致。</p>
<p>异步通信是以<strong>字符</strong>（构成的帧,8位）为单位进行传输，字符与字符之间<strong>的间隙（时间间隔）是任意的</strong>，但每个字符中的各位是以固定的时间传送的，即字符之间不 一定有“位间隔”的整数倍的关系，但同一字符内的各<strong>位之间的距离均为“ 位 间隔”的整数倍</strong>。如下图所示：</p>
<p>![image-20221222195408401](51 单片机的学习/image-20221222195408401.png)</p>
<p>一般启示位是0,即低电平; 终止位是1,即高电平.</p>
<p>终止位前有一个检验位,用于检验是否存在传输错误. 常用的有奇偶校验, 用的比较多的是代码和校验.</p>
<p>异步通信的特点：不要求收发双方时钟的严格一致，实现容易，设备开销较 小，但每个字符要附加 2～3 位用于起止位，各帧之间还有间隔，因此传输效率 不高。</p>
<ol start="2">
<li><strong>同步通信</strong></li>
</ol>
<p>同步通信时要建立发送方时钟对接收方时钟的直接控制，使双方达到完全同 步。此时，传输数据的位之间的距离均为“位间隔”的整数倍，同时传送的字符 间不留间隙，即保持位同步关系，也保持字符同步关系。发送方对接收方的同步 可以通过两种方法实现。</p>
<p>![image-20221222195716522](51 单片机的学习/image-20221222195716522.png)</p>
<h3 id="单工、半双工与全双工通信"><a href="#单工、半双工与全双工通信" class="headerlink" title="单工、半双工与全双工通信"></a>单工、半双工与全双工通信</h3><ol>
<li><strong>单工通信</strong></li>
</ol>
<p>单工是指数据传输仅能沿一个方向，不能实现反向传输。如下图所示：</p>
<p>![image-20221222195813958](51 单片机的学习/image-20221222195813958.png)</p>
<ol start="2">
<li><strong>半双工通信</strong></li>
</ol>
<p>半双工是指数据传输可以沿两个方向，但需要分时进行。如下图所示：</p>
<p>![image-20221222195858398](51 单片机的学习/image-20221222195858398.png)</p>
<p>3.<strong>全双工通信</strong></p>
<p>全双工是指数据可以同时进行双向传输。如下图所示：</p>
<p>![image-20221222195931136](51 单片机的学习/image-20221222195931136.png)</p>
<h2 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h2><p>传输速率又叫比特率, 比特率是每秒钟传输二进制代码的位数，单位是：位／秒（ bps）。</p>
<p><strong>波特率</strong>是每秒钟传输二进制代码的码数.</p>
<h2 id="单片机串口介绍"><a href="#单片机串口介绍" class="headerlink" title="单片机串口介绍"></a>单片机串口介绍</h2><h2 id="串口通信简介"><a href="#串口通信简介" class="headerlink" title="串口通信简介"></a>串口通信简介</h2><ol>
<li>接口标准</li>
</ol>
<p>这里我们就以 RS-232C 接口进行讲解。</p>
<p>RS-232C 接口规定使用 25 针连接器，简称 DB25，连接器的尺寸及每个插 针的排列位置都有明确的定义，如下图所示：</p>
<p>![image-20221222200845733](51 单片机的学习/image-20221222200845733.png)</p>
<p>并且会分为公头和母头(这里很好理解) 并且注意 公头和母头的引脚顺序是不一样的</p>
<p>![img](51 单片机的学习/D{YY7UPTU03`WY12{276DW.png)</p>
<p>每个引脚的功能如下所示: </p>
<p>![img](51 单片机的学习/7AIV49W9@6R%AKMC9}W0L43.png)</p>
<p>串口通信中还需要注意的是，串口数据收发线要交叉连接，计算机的 TXD 要对应单片机的 RXD，计算机的 RXD 要对应单片机的 TXD，并且共 GND，如下 图</p>
<p>![image-20221222201449669](51 单片机的学习/image-20221222201449669.png)</p>
<ol start="2">
<li><strong>通信协议</strong></li>
</ol>
<p>RS232 的通信协议比较简单，通常遵循 <strong>96-N-8-1</strong> 格式。</p>
<p> <strong>“96”表示的是通信波特率为 9600</strong>。串口通信中通常使用的是异步串口通 信，即没有时钟线，所以两个设备要通信，必须要保持一致的波特率，当然，波特率常用值还有 4800、 115200 等.</p>
<p><strong>“N”表示的是无校验位，</strong>由于串口通信相对更容易受到外部干扰导致传输 数据出现偏差，可以在传输过程加上校验位来解决这个问题。</p>
<p><strong>“8”表示的是数据位数为 8 位</strong></p>
<p><strong>“1”表示的是 1 位停止位</strong>，串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示，而数据包的停 止信号可由 0.5,1,1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可.</p>
<ol start="3">
<li><strong>串口的内部结构</strong></li>
</ol>
<p>![串口通信内部结构](51 单片机的学习/串口通信内部结构.png)</p>
<p>波特率 靠TH1,TL1 工作在定时器工作在模式2</p>
<p>TXD 对应的是 P3.1 管脚，RXD 对 应的是 P3.0 管脚。</p>
<p>输入和输出时注意读取SBUF缓存器</p>
<ol start="4">
<li><strong>串口控制寄存器 SCON</strong></li>
</ol>
<p>![3](51 单片机的学习/3.png)</p>
<p><strong>SM0 和 SM1</strong> 为工作方式选择位： 一般选择工作在<strong>方式一</strong></p>
<p>![4](51 单片机的学习/4.png)</p>
<p><strong>SM2</strong>：多机通信控制位，<strong>这里设置为0即可</strong> ,因为它主要用于方式 2 和方式3.</p>
<p><strong>REN</strong>：允许串行接收位。由软件置 <strong>REN=1</strong>，则启动串行口接收数据；若软件置 <strong>REN=0</strong>，则禁止接收.</p>
<p><strong>TB8</strong>：在方式 2 或方式 3 中，是发送数据的第 9 位，可以用软件规定其作用。 可以用作数据的奇偶校验位，或在多机通信中，作为地址帧/数据帧的标志位。 <strong>在方式 0 和方式 1 中，该位未用到,设置为0即可.</strong></p>
<p> <strong>RB8</strong>：在方式 2 或方式 3 中，是接收到数据的第 9 位，作为奇偶校验位或地 址帧/数据帧的标志位。<strong>在方式 1 时，若 SM2=0，则 RB8 是接收到的停止位。</strong></p>
<p><strong>TI</strong>：发送中断标志位。<strong>主要使用在方式0</strong>, 在方式 0 时，当串行发送第 8 位数据结束时，或在其 它方式，串行发送停止位的开始时，由内部硬件使 TI 置 1，向 CPU 发中断申请。 在中断服务程序中，必须用软件将其清 0，取消此中断申请。</p>
<p> <strong>RI</strong>：接收中断标志位, 主要使用在方式0。<strong>在方式 0 时</strong>，当串行接收第 8 位数据结束时，或在其 它方式，串行接收停止位的中间时，由内部硬件使 RI 置 1，向 CPU 发中断申请。 也必须在中断服务程序中，用软件将其清 0，取消此中断申请.</p>
<p>电源控制寄存器 PCON中只有SMOD的第一位有关. </p>
<p> <strong>SMOD</strong>：波特率倍增位。在串口方式 1、方式 2、方式 3 时，波特率与 SMOD 有 关，<strong>当 SMOD=1 时，波特率提高一倍</strong>。复位时，SMOD=0</p>
<h2 id="方式一的工作"><a href="#方式一的工作" class="headerlink" title="方式一的工作"></a>方式一的工作</h2><p>方式 1 是 10 位数据的异步通信口。</p>
<p>TXD 为数据发送引脚，RXD 为数据接收引 脚，传送一帧数据的格式如下所示</p>
<p>其中 1 位起始位, 8 位数据位1 位停止位.</p>
<p>![5](51 单片机的学习/5.png)</p>
<h2 id="波特率的计算"><a href="#波特率的计算" class="headerlink" title="波特率的计算"></a>波特率的计算</h2><p>方式 0 的波特率 = $fosc/12$</p>
<p> 方式 2 的波特率 =$（2^{SMOD} /64）· fosc $</p>
<p>方式 3 的波特率 =$（2^{SMOD}/32）·（T1 溢出率)$</p>
<p><strong>方式 1 的波特率 =$（2^{SMOD}/32）·（T1 溢出率） $</strong></p>
<p>可以用 <em>51 波特率初值设定.exe</em> 软件</p>
<h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>这里以普中开发板为例</p>
<p>![6](51 单片机的学习/6.png)</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(u8 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">	SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1</span></span><br><span class="line">	PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍</span></span><br><span class="line">	TH1=baud; <span class="comment">//计数器初始值设置</span></span><br><span class="line">	TL1=baud;</span><br><span class="line">	ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">	EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">	TR1=<span class="number">1</span>; <span class="comment">//打开计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">uart_init(<span class="number">0XFA</span>);<span class="comment">//波特率为 9600</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart</span><span class="params">()</span> interrupt 4 <span class="comment">//串口通信中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">u8 rec_data;</span><br><span class="line">RI = <span class="number">0</span>; <span class="comment">//清除接收中断标志位</span></span><br><span class="line">rec_data=SBUF; <span class="comment">//存储接收到的数据</span></span><br><span class="line">SBUF=rec_data; <span class="comment">//将接收到的数据放入到发送寄存器</span></span><br><span class="line"><span class="keyword">while</span>(!TI); <span class="comment">//等待发送数据完成</span></span><br><span class="line">TI=<span class="number">0</span>; <span class="comment">//清除发送完成标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电赛准备</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习（中级篇）</title>
    <url>/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="RCC的使用"><a href="#RCC的使用" class="headerlink" title="RCC的使用"></a>RCC的使用</h1><p>使用HSE、HSI来配置系统时钟</p>
<h2 id="RCC的功能框图"><a href="#RCC的功能框图" class="headerlink" title="RCC的功能框图"></a>RCC的功能框图</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/RCC002.png" alt="STM32时钟树"></p>
<h2 id="HSI-HSE-来配置系统时钟"><a href="#HSI-HSE-来配置系统时钟" class="headerlink" title="HSI/HSE 来配置系统时钟"></a>HSI/HSE 来配置系统时钟</h2><p>这块地方主要要求看懂代码，学会代码的移植即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码对照功能框图和系统文件来看</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HSI_SetSysClock</span><span class="params">(<span class="type">uint32_t</span> pllmul)</span></span><br><span class="line">&#123;</span><br><span class="line">    __IO <span class="type">uint32_t</span> HSIStartUpStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把RCC外设初始化成复位状态</span></span><br><span class="line">    RCC_DeInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能HSI</span></span><br><span class="line">    RCC_HSICmd(ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 HSI 就绪</span></span><br><span class="line">    HSIStartUpStatus = RCC-&gt;CR &amp; RCC_CR_HSIRDY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 HSI就绪之后则继续往下执行</span></span><br><span class="line">    <span class="keyword">if</span> (HSIStartUpStatus == RCC_CR_HSIRDY) &#123;</span><br><span class="line">    <span class="comment">//-------------------------------------------------------------//</span></span><br><span class="line">        <span class="comment">// 这两句是操作FLASH闪存用到的，如果不操作FLASH，这两个注释掉也没影响</span></span><br><span class="line">        <span class="comment">// 使能FLASH 预存取缓冲区</span></span><br><span class="line">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SYSCLK周期与闪存访问时间的比例设置，这里统一设置成2</span></span><br><span class="line">        <span class="comment">// 设置成2的时候，SYSCLK低于48M也可以工作，如果设置成0或者1的时候，</span></span><br><span class="line">        <span class="comment">// 如果配置的SYSCLK超出了范围的话，则会进入硬件错误，程序就死了</span></span><br><span class="line">        <span class="comment">// 0：0 &lt; SYSCLK &lt;= 24M</span></span><br><span class="line">        <span class="comment">// 1：24&lt; SYSCLK &lt;= 48M</span></span><br><span class="line">        <span class="comment">// 2：48&lt; SYSCLK &lt;= 72M</span></span><br><span class="line">        FLASH_SetLatency(FLASH_Latency_2);</span><br><span class="line">    <span class="comment">//------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AHB预分频因子设置为1分频，HCLK = SYSCLK</span></span><br><span class="line">        RCC_HCLKConfig(RCC_SYSCLK_Div1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// APB2预分频因子设置为1分频，PCLK2 = HCLK</span></span><br><span class="line">        RCC_PCLK2Config(RCC_HCLK_Div1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// APB1预分频因子设置为1分频，PCLK1 = HCLK/2</span></span><br><span class="line">        RCC_PCLK1Config(RCC_HCLK_Div2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-----------设置各种频率主要就是在这里设置-------------------//</span></span><br><span class="line">        <span class="comment">// 设置PLL时钟来源为HSE，设置PLL倍频因子</span></span><br><span class="line">        <span class="comment">// PLLCLK = 4MHz * pllmul</span></span><br><span class="line">        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, pllmul);</span><br><span class="line">    <span class="comment">//-- -----------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启PLL</span></span><br><span class="line">        RCC_PLLCmd(ENABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 PLL稳定</span></span><br><span class="line">        <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当PLL稳定之后，把PLL时钟切换为系统时钟SYSCLK</span></span><br><span class="line">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取时钟切换状态位，确保PLLCLK被选为系统时钟</span></span><br><span class="line">        <span class="keyword">while</span> (RCC_GetSYSCLKSource() != <span class="number">0x08</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果HSI开启失败，那么程序就会来到这里，用户可在这里添加出错的代码处理</span></span><br><span class="line">        <span class="comment">// 当HSE开启失败或者故障的时候，单片机会自动把HSI设置为系统时钟，</span></span><br><span class="line">        <span class="comment">// HSI是内部的高速时钟，8MHZ</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用HSE功能类似这里不多赘述.</p>
<hr>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断其实就是异常</p>
<p>系统出现异常时停止执行主程序 去执行中断服务程序,执行完中断服务程序之后再接着执行主程序的内容</p>
<p>这里中断可以嵌套,至于先执行哪一个中断,看中断优先级.</p>
<h2 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h2><ol>
<li>系统的异常,体现再内核</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr01.png" alt="F103系统异常清单"></p>
<ol start="2">
<li>外部中断,体现到外设中</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr02.png" alt="F103外部中断清单"></p>
<h2 id="中断的管理-NVIC"><a href="#中断的管理-NVIC" class="headerlink" title="中断的管理-NVIC"></a>中断的管理-NVIC</h2><p>NVIC(嵌套向量中断控制器):管理芯片中所有中断的部分 </p>
<p>中断服务固件库在 CMSIS文件夹中的 core_cm3.c 文件中和 misc.c中</p>
<h3 id="NVIC寄存器"><a href="#NVIC寄存器" class="headerlink" title="NVIC寄存器"></a>NVIC寄存器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置中断的时候我们一般只用ISER、ICER和IP这三个寄存器，ISER用来使能中断，ICER用来失能中断，IP用来设置中断优先级。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> ISER[<span class="number">8</span>];       <span class="comment">// 中断使能寄存器,相当于总开关</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED0[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ICER[<span class="number">8</span>];       <span class="comment">// 中断清除寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RSERVED1[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ISPR[<span class="number">8</span>];       <span class="comment">// 中断使能悬起寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED2[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ICPR[<span class="number">8</span>];       <span class="comment">// 中断清除悬起寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED3[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> IABR[<span class="number">8</span>];       <span class="comment">// 中断有效位寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED4[<span class="number">56</span>];</span><br><span class="line">    __IO <span class="type">uint8_t</span>  IP[<span class="number">240</span>];       <span class="comment">// 中断优先级寄存器(8Bit wide)</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED5[<span class="number">644</span>];</span><br><span class="line">    __O  <span class="type">uint32_t</span> STIR;          <span class="comment">// 软件触发中断寄存器</span></span><br><span class="line">&#125;  NVIC_Type;</span><br></pre></td></tr></table></figure>

<h2 id="中断优先级的定义"><a href="#中断优先级的定义" class="headerlink" title="中断优先级的定义"></a>中断优先级的定义</h2><p>在NVIC 有一个专门的寄存器：中断优先级寄存器NVIC_IPRx.<strong>在F103中,只有高四位有效.</strong></p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr04.png" alt="使用4bit表达优先级"></p>
<p>用于表达优先级的这4bit，又被分组成抢占优先级和子优先级。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行， 如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p>
<h3 id="优先级的分组"><a href="#优先级的分组" class="headerlink" title="优先级的分组"></a>优先级的分组</h3><p>优先级的分组由内核外设SCB的应用程序中断及复位控制寄存器AIRCR的PRIGROUP[10:8]位决定，F103分为了5组，具体如下：主优先级=抢占优先级</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr045.png" alt="img"></p>
<p>设置优先级分组可调用库函数NVIC_PriorityGroupConfig()实现，有关NVIC中断相关的库函数都在库文件misc.c和misc.h中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置中断优先级分组：抢占优先级和子优先级</span></span><br><span class="line"><span class="comment">* 形参如下：</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_0: 0bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            4 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_1: 1 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            3 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_2: 2 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            2 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_3: 3 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            1 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_4: 4 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            0 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @注意 如果优先级分组为0，则抢占优先级就不存在，优先级就全部由子优先级控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置优先级分组</span></span><br><span class="line">    SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr05.png" alt="优先级分组真值表"></p>
<h2 id="中断编程的步骤"><a href="#中断编程的步骤" class="headerlink" title="中断编程的步骤"></a>中断编程的步骤</h2><ol>
<li>使能中断请求,相当于打开总开关.–中断使能寄存器配置</li>
<li>配置中断优先级分组, 配置SCB_ARCR,—调用NVIC_PriorityGroupConfig();</li>
<li>配置NVIC寄存器, 并初始化NVIC_InitTypeDef 结构体— 1.配置中断源(文件在STM32f10x.h中的IRQ中) 2.抢占优先级的值(根据优先级组配置) 3. 子优先级 4.内部使能.</li>
<li>编写中断服务函数!!! 名称一定不能写错,每个函数的名称在启动文件中,写错了会死循环!</li>
</ol>
<p>为了管理方便将中断全部写到 stm32f10x.it.c的函数中</p>
<hr>
<h1 id="EXTI-外部中断控制器"><a href="#EXTI-外部中断控制器" class="headerlink" title="EXTI- 外部中断控制器"></a>EXTI- 外部中断控制器</h1><p>EXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的20个中断/事件线。 每个中断/事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。EXTI可以实现对每个中断/事件线进行单独配置， 可以单独配置为中断或者事件，以及触发事件的属性。</p>
<h2 id="EXTI的功能框图"><a href="#EXTI的功能框图" class="headerlink" title="EXTI的功能框图"></a>EXTI的功能框图</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI002.png" alt="EXTI功能框图"></p>
<blockquote>
<p>一个斜杠并标注“20”字样，这个表示在控制器内部类似的信号线路有20个.</p>
</blockquote>
<p>EXTI有20个中断/事件线，每个GPIO都可以被设置为输入线，占用EXTI0至EXTI15， 还有另外七根用于特定的外设事件</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI01.png" alt="EXTI中断/事件线"></p>
<p>EXTI0至EXTI15用于GPIO</p>
<h2 id="EXTI初始化结构体"><a href="#EXTI初始化结构体" class="headerlink" title="EXTI初始化结构体"></a>EXTI初始化结构体</h2><p>标准库函数对每个外设都建立了一个初始化结构体，比如EXTI_InitTypeDef，结构体成员用于设置外设工作参数，并由外设初始化配置函数， 比如EXTI_Init()调用，这些设定参数将会设置外设相应的寄存器，达到配置外设工作环境的目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> EXTI_Line;                 <span class="comment">// 中断/事件线</span></span><br><span class="line">    EXTIMode_TypeDef EXTI_Mode;         <span class="comment">// EXTI模式</span></span><br><span class="line">    EXTITrigger_TypeDef EXTI_Trigger;   <span class="comment">// 触发类型</span></span><br><span class="line">    FunctionalState EXTI_LineCmd;       <span class="comment">// EXTI使能</span></span><br><span class="line">&#125; EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h2 id="外部中断控制实验设计"><a href="#外部中断控制实验设计" class="headerlink" title="外部中断控制实验设计"></a>外部中断控制实验设计</h2><p>我们设计使用外接的按键来作为触发源，使得控制器产生中断，并在中断服务函数中实现控制RGB彩灯的任务。</p>
<h3 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI004.png" alt="按键电路设计"></p>
<h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><ol>
<li>初始化用来产生中断的GPIO；</li>
<li>初始化EXTI；</li>
<li>配置NVIC；</li>
<li>编写中断服务函数；</li>
</ol>
<ul>
<li>bsp_exti.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.配置NVIC</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NVIC_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_initstruct;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选择中断的位置</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选择优先级的分组为1</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">	<span class="comment">// 设置主优先级</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 设置子优先级</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//使能</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	</span><br><span class="line">	NVIC_Init(&amp;NVIC_initstruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化用来产生中断的GPIO---键盘</span></span><br><span class="line"><span class="comment">//2.初始化EXTI</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_KEY1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	EXTI_InitTypeDef EXTI_initstruct;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_PIN; </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_PORT, &amp;GPIO_KEY1_initstruct);</span><br><span class="line">	<span class="comment">//初始化NVIC</span></span><br><span class="line">	NVIC_Config();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//时钟打开！！！</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">	<span class="comment">//选择输入线</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//因为是PA0，所以选择line0</span></span><br><span class="line">	EXTI_initstruct.EXTI_Line = EXTI_Line0;</span><br><span class="line">	<span class="comment">//调节模式为中断模式</span></span><br><span class="line">	EXTI_initstruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	<span class="comment">//触发方式设置为 上升触发</span></span><br><span class="line">	EXTI_initstruct.EXTI_Trigger = EXTI_Trigger_Rising;</span><br><span class="line">	<span class="comment">//使能</span></span><br><span class="line">	EXTI_initstruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_exti. h文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_EXTI.H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_EXTI.H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_KEY1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY1 的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_EXTI.H*/</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>stm32f10x_it.c 中添加</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_G_TOGGLE;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line0);		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main 函数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_exti.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                     <span class="comment">//初始化LED灯</span></span><br><span class="line">	EXTI_KEY1_Config();                         <span class="comment">//打开中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Systick-系统定时器"><a href="#Systick-系统定时器" class="headerlink" title="Systick-系统定时器"></a>Systick-系统定时器</h1><p>系统定时器：24 位 递减 存在于内核中，systick的寄存器如图所示</p>
<p>![image-20230103164648793](STM32学习- 中级/image-20230103164648793.png)</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic01.png" alt="SysTick寄存器汇总"></p>
<p>其中CTRL寄存器 又有四个位来控制</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic02.png" alt="SysTick控制及状态寄存器"></p>
<p>另外两个常用的寄存器 如下图所示：</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic03.png" alt="SysTick重装载数值寄存器"></p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic04.png" alt="SysTick当前数值寄存器"></p>
<h2 id="定时函数的设计"><a href="#定时函数的设计" class="headerlink" title="定时函数的设计"></a>定时函数的设计</h2><h2 id="硬件设计-1"><a href="#硬件设计-1" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>SysTick属于单片机内部的外设，不需要额外的硬件电路，剩下的只需一个LED灯即可。</p>
<p><strong>notice:</strong> 一般把systick 优先级设置成15(最低), 如果其他中断和systick的中断设置的优先级一样,比较系统默认的优先级.</p>
<h2 id="软件设计-1"><a href="#软件设计-1" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="定时时间的计算"><a href="#定时时间的计算" class="headerlink" title="定时时间的计算"></a>定时时间的计算</h3><ul>
<li>计时的时间只于 RELOAD和CLK 有关</li>
<li>CLK：可以设置成系统时钟(默认72M),或者系统时钟/8(9M), 由CTRL寄存器控制</li>
<li>RELOAD,由我们自己控制</li>
</ul>
<p>$t=reload×(1/CLK)$</p>
<p>常用1us 1ms,将clk设置成72M,reload设置成72,72000即可.</p>
<h3 id="systick的配置"><a href="#systick的配置" class="headerlink" title="systick的配置"></a>systick的配置</h3><p>在core_cm3.h文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __INLINE <span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">//检查 tick是否大于24位</span></span><br><span class="line">  <span class="keyword">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class="keyword">return</span> (<span class="number">1</span>);            </span><br><span class="line">  <span class="comment">//设置reload的值                                                             </span></span><br><span class="line">  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//设置优先级,默认为15(最低) </span></span><br><span class="line">  NVIC_SetPriority (SysTick_IRQn, (<span class="number">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* Load the SysTick Counter Value */</span>  </span><br><span class="line">  SysTick-&gt;VAL   = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">//  配置systick时钟为72M, 使能中断, 使能systick,然后开始计数</span></span><br><span class="line">  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | </span><br><span class="line">                   SysTick_CTRL_TICKINT_Msk   | </span><br><span class="line">                   SysTick_CTRL_ENABLE_Msk;                    </span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                                  <span class="comment">/* Function successful */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><ul>
<li>bsp_systick.c文件 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">__IO u32 TimingDelay; <span class="comment">//定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_us</span><span class="params">(__IO u32 nTime)</span> <span class="comment">//us延时</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	SysTick_Config(<span class="number">72</span>); <span class="comment">//1us 延时一次</span></span><br><span class="line">	TimingDelay = nTime; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(TimingDelay != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_ms</span><span class="params">(__IO u32 nTime)</span> <span class="comment">//ms延时</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	SysTick_Config(<span class="number">72000</span>); <span class="comment">//1ms 延时一次</span></span><br><span class="line">	TimingDelay = nTime;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(TimingDelay != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TimingDelay_Decrement</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//定义中段服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TimingDelay != <span class="number">0x00</span>) </span><br><span class="line">	&#123;</span><br><span class="line">        TimingDelay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_systick.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_SYSTICK,H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_SYSTICK,H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_us</span><span class="params">(__IO u32 nTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_ms</span><span class="params">(__IO u32 nTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TimingDelay_Decrement</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_SYSTICK,H*/</span></span></span><br></pre></td></tr></table></figure>

<p>中断服务函数 stm32f10x_it.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TimingDelay_Decrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();     <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>); <span class="comment">//定时器延时</span></span><br><span class="line">		LED_GREEN;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="串口通信的概念"><a href="#串口通信的概念" class="headerlink" title="串口通信的概念"></a>串口通信的概念</h2><p>这里和之前的51学习中的串口通信概念差不多</p>
<p>为了巩固这里再写一遍.</p>
<p>串口通信是硬件与硬件的信息传输</p>
<h3 id="串行与并行"><a href="#串行与并行" class="headerlink" title="串行与并行"></a>串行与并行</h3><p>假设传八个数据</p>
<ul>
<li>串行:一根线一位一位传输</li>
<li>并行: 8根线 同时传输八位</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>串行</th>
<th>并行</th>
</tr>
</thead>
<tbody><tr>
<td>通讯距离</td>
<td>远</td>
<td>近</td>
</tr>
<tr>
<td>抗干扰能力</td>
<td>强</td>
<td>弱</td>
</tr>
<tr>
<td>传输速率</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>成本</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="全双工-半双工-单工"><a href="#全双工-半双工-单工" class="headerlink" title="全双工 半双工 单工"></a>全双工 半双工 单工</h3><ul>
<li>全双工: 可以双向同时收发数据</li>
<li>半双工: 可以双向收发数据,但需要分时</li>
<li>单工: 只能单向收发数据</li>
</ul>
<h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h3><ul>
<li><p>同步: 有时钟信号都是同步</p>
</li>
<li><p> 异步:  不需要时钟信号</p>
</li>
</ul>
<p><strong>异步有 数据的起始位,主体数据,校验位,通信停止位</strong></p>
<h3 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h3><p>比特率: 每秒传输的<strong>二进制位数</strong>.</p>
<p>波特率: 每秒传输的<strong>码元</strong>个数.</p>
<p>码元-等于一个二进制位数时,比特率等于波特率</p>
<h2 id="串口的通信协议"><a href="#串口的通信协议" class="headerlink" title="串口的通信协议"></a>串口的通信协议</h2><p>不只是针对STM32,对于其他处理器也适用</p>
<p>物理层:硬件部分</p>
<p>协议层:软件部分</p>
<p>三个常用串口协议,主要是电平的区别,STM32的电平为TTL电平</p>
<h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p>电平高:-15V,低:+15V</p>
<p>一般由于工业设备,静电比较多,粉尘比较多,容错率比较高</p>
<h3 id="USB-转串口"><a href="#USB-转串口" class="headerlink" title="USB 转串口"></a>USB 转串口</h3><p>TTL 电平转USB电平</p>
<p>常用芯片:CH340等.</p>
<h3 id="原生的串口转串口"><a href="#原生的串口转串口" class="headerlink" title="原生的串口转串口"></a>原生的串口转串口</h3><p>都是TTL电平,不需要电平转换芯片</p>
<p>比如一些蓝牙模块,wifi模块</p>
<h3 id="串口的数据包"><a href="#串口的数据包" class="headerlink" title="串口的数据包"></a>串口的数据包</h3><p>起始位: 1个0电位</p>
<p>数据位</p>
<p>检验位: </p>
<p>奇校验(1的个数是奇数),偶校验,0校验(校验位总为0),1校验.</p>
<p>结束位</p>
<h2 id="STM32的串口的功能"><a href="#STM32的串口的功能" class="headerlink" title="STM32的串口的功能"></a>STM32的串口的功能</h2><h3 id="串口功能框图"><a href="#串口功能框图" class="headerlink" title="串口功能框图"></a>串口功能框图</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART008.png" alt="USART功能框图"></p>
<p>TX：数据发送</p>
<p>RX：数据接收</p>
<p>SCLK：同步通讯使用时用的时钟</p>
<p>n：请求, 一般不使用</p>
<p>![STM32F103VET6芯片的USART引脚](STM32学习- 中级/USART03.png)</p>
<p>各个串口的引脚图,如图所示</p>
<p>这里注意串口1和其他串口接的总线位置不一样,如果需要查找详细的串口位置,需要查找官方的数据手册查找串口位置.</p>
<h3 id="各个数据寄存器"><a href="#各个数据寄存器" class="headerlink" title="各个数据寄存器"></a>各个数据寄存器</h3><ul>
<li><p>数据寄存器寄存器: USART_DR: 九位有效,具体多少位由USART_CR1控制</p>
</li>
<li><p>控制寄存器1 USART_CR1: 1. M,1:8位;0:9位 2. PCE,PS 控制校验位, PE看是否出现错误 3.PEIE: 控制中断使能</p>
</li>
</ul>
<p>4.</p>
<ul>
<li><p>控制寄存器2 USART_CR2: STOP</p>
</li>
<li><p>状态寄存器: USART_SR: TEX,TC,观测是否发送完成</p>
</li>
<li><p>波特比率寄存器(USART_BRR) :前面11位是整数部分,后面3位是小数部分</p>
</li>
</ul>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART010.png" alt="波特率计算"></p>
<p>fck要注意是哪个串口,是72M还是36M,</p>
<p>小数部分即为 1/16, 所以只需呀将小数部分*16即可得到小数部分</p>
<h2 id="中断接收和发送的实验设计"><a href="#中断接收和发送的实验设计" class="headerlink" title="中断接收和发送的实验设计"></a>中断接收和发送的实验设计</h2><h3 id="硬件设计-2"><a href="#硬件设计-2" class="headerlink" title="硬件设计"></a>硬件设计</h3><p>usb转串口</p>
<p>电脑是USB,单片机是TTL电平,所以需要这个CH340转电平,这里需要安装CH340的驱动</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART011.png" alt="USB转串口硬件设计"></p>
<p>RX和TX的连接, 开发板上通过跳帽 连接PA9和PA10,</p>
<p>如果需要连接其他串口需要拔掉跳帽通过杜邦线连接到其他串口</p>
<h3 id="软件设计-2"><a href="#软件设计-2" class="headerlink" title="软件设计"></a>软件设计</h3><ul>
<li><strong>USART的结构体介绍</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> USART_BaudRate;            <span class="comment">/*!&lt;用来存放波特率,这里只需要填写115200即可</span></span><br><span class="line"><span class="comment">                                           The baud rate is computed using the following formula:</span></span><br><span class="line"><span class="comment">                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct-&gt;USART_BaudRate)))</span></span><br><span class="line"><span class="comment">                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_WordLength;          <span class="comment">/*!&lt; 用来设置字长是8位还是9位</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Word_Length */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_StopBits;            <span class="comment">/*!&lt;选择结束位是1个停止位还是0.5,1.5,2个.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Stop_Bits */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_Parity;              <span class="comment">/*!&lt; 配置校验位.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Parity</span></span><br><span class="line"><span class="comment">                                           @note When parity is enabled, the computed parity is inserted</span></span><br><span class="line"><span class="comment">                                                 at the MSB position of the transmitted data (9th bit when</span></span><br><span class="line"><span class="comment">                                                 the word length is set to 9 data bits; 8th bit when the</span></span><br><span class="line"><span class="comment">                                                 word length is set to 8 data bits). */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">uint16_t</span> USART_Mode;                <span class="comment">/*!&lt;控制是使能发送模式还是使能接收模式 is enabled or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_HardwareFlowControl; <span class="comment">/*!&lt;硬件控制流</span></span><br><span class="line"><span class="comment">                                           or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */</span></span><br><span class="line">&#125; USART_InitTypeDef;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面的结构体和同步通信有关,不需要初始化,如果不需要使用同步通信</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>主要用到的函数</strong></li>
</ul>
<ol>
<li>结构体初始化函数</li>
<li>数据发送函数</li>
<li>数据接收函数</li>
<li>中断状态位获取函数,中断清除等</li>
</ol>
<ul>
<li><strong>编程的要点</strong></li>
</ul>
<ol>
<li>初始化串口用到的GPIO, PA9,PA10</li>
<li>初始化串口</li>
<li>配置中断(接收中断,中断优先级)</li>
<li>使能串口</li>
<li>编写发送和接收函数</li>
<li>编写中断服务函数</li>
</ol>
<ul>
<li>bsp_usart.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PIN     GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PORT    GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_CLK     RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PIN     GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PORT    GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_BT   115200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CLK  RCC_APB2Periph_USART1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_IRQ  USART1_IRQn</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_USART_H*/</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_usart.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化串口用到的GPIO, PA9,PA10,初始化串口,配置中断(接收中断,中断优先级),使能串口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NVIC_Configuration</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 嵌套向量中断控制器组选择 */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置USART为中断源 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = USART_IRQ;</span><br><span class="line">    <span class="comment">/* 抢断优先级为1 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 子优先级为1 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    <span class="comment">/* 初始化配置NVIC */</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	<span class="comment">//配置Rx GPIO的PA9</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RX_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = RX_PIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(RX_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配值TX GPIO的PA10</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = TX_PIN;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(TX_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置USART1</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(USART_CLK , ENABLE);</span><br><span class="line">	</span><br><span class="line">	USART_InitStructure.USART_BaudRate = USART_BT;</span><br><span class="line">	</span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;</span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	</span><br><span class="line">	USART_Init(USART1 , &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置中断</span></span><br><span class="line">	</span><br><span class="line">	NVIC_Configuration(); <span class="comment">// 串口中断优先级配置</span></span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); <span class="comment">//Receive Data register not empty interrupt</span></span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1, ENABLE);<span class="comment">// 使能串口 配置UE位,相当于打开了总开关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送字符函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送1B函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendByte</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(pUSARTx, data);</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送 2B函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Send2Byte</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint16_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> data_h = (data &amp; <span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span> ;</span><br><span class="line">	<span class="type">uint8_t</span> data_l = (data &amp; <span class="number">0x00ff</span>);</span><br><span class="line">	</span><br><span class="line">	USART_SendByte(pUSARTx, data_h );</span><br><span class="line">	USART_SendByte(pUSARTx, data_l );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 8位数据的数组的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendARRAY</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> *<span class="built_in">array</span>,<span class="type">uint8_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		USART_SendByte(pUSARTx, <span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendSTR</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		USART_SendByte(pUSARTx, *(str+i));</span><br><span class="line">		i++;</span><br><span class="line">	&#125;<span class="keyword">while</span>(*(str+i) != <span class="string">&#x27;\0&#x27;</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向c库函数printf到串口，重定向后可使用printf函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 发送一个字节数据到串口 */</span></span><br><span class="line">    USART_SendData(USART1, (<span class="type">uint8_t</span>) ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待发送完毕 */</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 等待串口输入数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)USART_ReceiveData(USART1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在换串口时要注意"><a href="#在换串口时要注意" class="headerlink" title="在换串口时要注意"></a>在换串口时要注意</h3><ol>
<li>时钟的总线</li>
<li>GPIO的引脚</li>
<li>中断的中断源, 函数名</li>
<li>硬件上: 将USB转串口 用杜邦线连接到新的串口上</li>
</ol>
<h3 id="窗口接收"><a href="#窗口接收" class="headerlink" title="窗口接收"></a>窗口接收</h3><p>在stm32f10x_it.c中,添加中断, 这样有了一个接收文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ucTemp;</span><br><span class="line">    <span class="keyword">if</span> (USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET) </span><br><span class="line">	&#123;</span><br><span class="line">        ucTemp = USART_ReceiveData( USART1 );</span><br><span class="line">        USART_SendData(USART1,ucTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="串口控制LED的开与关"><a href="#串口控制LED的开与关" class="headerlink" title="串口控制LED的开与关"></a>串口控制LED的开与关</h2><p>只需在main.c文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ch;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	USART1_Config();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LED text\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LED = %c\n&quot;</span>,ch);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;LED = %c\n&quot;</span>,ch);</span><br><span class="line">		<span class="keyword">switch</span>(ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: LED_RED;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;红灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: LED_GREEN;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绿灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: LED_BLUE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;蓝灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: LED_YELLOW;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;黄灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: LED_PURPLE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;紫灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: LED_CYAN;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;青灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: LED_WHITE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;白灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: LED_RGBOFF;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;熄灭\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="DMA直接存储器的简介"><a href="#DMA直接存储器的简介" class="headerlink" title="DMA直接存储器的简介"></a>DMA直接存储器的简介</h2><p>DMA(Direct Memory Access)—直接存储器存取</p>
<p>作用: 把数据从一个地方搬到另一个地方, 而且不占用CPU</p>
<p>DMA1:有7个通道,可以实现P-&gt;M, M-&gt;P, M-&gt;M</p>
<p>DMA2(只存在于大容量,或者互联型中):有5个通道,可以实现P-&gt;M, M-&gt;P, M-&gt;M</p>
<h3 id="DMA的功能框图"><a href="#DMA的功能框图" class="headerlink" title="DMA的功能框图"></a>DMA的功能框图</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DMA002.png" alt="DMA框图"></p>
<ol>
<li>DMA请求,由发送端,外设等产生</li>
<li>DMA通道,DMA1有7条,DMA2有5条</li>
<li>当多个通道同时发送请求映射,仲裁器(<strong>第一阶段</strong>: 先由DMA_CCRx的 PL控制优先级决定, <strong>第二阶段</strong>: 优先级相同时再串口通道的编号优先级决定)</li>
</ol>
<p>如果不适用DMA,系统会默认使用CPU</p>
<h3 id="固件库编程"><a href="#固件库编程" class="headerlink" title="固件库编程"></a>固件库编程</h3><ol>
<li>DMA结构体成员</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralBaseAddr;   <span class="comment">// 外设地址 DMA_CPAR寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryBaseAddr;       <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_DIR;                  <span class="comment">// 传输方向 DMA_CCR 的DIR: P-&gt;M, M-&gt;P, </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_BufferSize;           <span class="comment">// 传输数目            </span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralInc;        <span class="comment">// 外设地址增量模式   DMA_CCR 的PINC,由普通和循环2个模式</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryInc;            <span class="comment">// 存储器地址增量模式  DMA_CCR 的MINC</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralDataSize;   <span class="comment">// 外设数据宽度    DMA_CCR 的MSIZE和PSIZE确定</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryDataSize;       <span class="comment">// 存储器数据宽度</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> DMA_Mode;                 <span class="comment">// 模式选择 DMA_ISR </span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_Priority;             <span class="comment">// 通道优先级</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_M2M;                  <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">&#125; DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>固件库函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="comment">//结构体初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="comment">//使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="M-to-M实验设计"><a href="#M-to-M实验设计" class="headerlink" title="M to M实验设计"></a>M to M实验设计</h2><p>FLASH to SRAM </p>
<h3 id="硬件设计-3"><a href="#硬件设计-3" class="headerlink" title="硬件设计"></a>硬件设计</h3><p>这里不需要其他的外设要求</p>
<h3 id="软件设计-3"><a href="#软件设计-3" class="headerlink" title="软件设计"></a>软件设计</h3><ul>
<li>编程要点: </li>
</ul>
<ol>
<li>定义一个变量存储再FLASH文件中， 再定义存储在SRAM中的变量</li>
<li>初始化DMA结构体</li>
<li>使能DMA时钟；</li>
<li>配置DMA数据参数；</li>
<li>使能DMA，进行传输；</li>
<li>等待传输完成，并对源数据和目标地址数据进行比较。</li>
</ol>
<ol>
<li>定义一个变量存储再FLASH文件中， 再定义存储在SRAM中的变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x01020304</span>,<span class="number">0x05060708</span>,<span class="number">0x090A0B0C</span>,<span class="number">0x0D0E0F10</span>,</span><br><span class="line">    <span class="number">0x11121314</span>,<span class="number">0x15161718</span>,<span class="number">0x191A1B1C</span>,<span class="number">0x1D1E1F20</span>,</span><br><span class="line">    <span class="number">0x21222324</span>,<span class="number">0x25262728</span>,<span class="number">0x292A2B2C</span>,<span class="number">0x2D2E2F30</span>,</span><br><span class="line">    <span class="number">0x31323334</span>,<span class="number">0x35363738</span>,<span class="number">0x393A3B3C</span>,<span class="number">0x3D3E3F40</span>,</span><br><span class="line">    <span class="number">0x41424344</span>,<span class="number">0x45464748</span>,<span class="number">0x494A4B4C</span>,<span class="number">0x4D4E4F50</span>,</span><br><span class="line">    <span class="number">0x51525354</span>,<span class="number">0x55565758</span>,<span class="number">0x595A5B5C</span>,<span class="number">0x5D5E5F60</span>,</span><br><span class="line">    <span class="number">0x61626364</span>,<span class="number">0x65666768</span>,<span class="number">0x696A6B6C</span>,<span class="number">0x6D6E6F70</span>,</span><br><span class="line">    <span class="number">0x71727374</span>,<span class="number">0x75767778</span>,<span class="number">0x797A7B7C</span>,<span class="number">0x7D7E7F80</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义DMA传输目标存储器</span></span><br><span class="line"><span class="comment">* 存储在内部的SRAM中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br></pre></td></tr></table></figure>

<p>2.初始化DMA结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_MTM_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打开DMA的时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(DMA1_CLK, ENABLE);</span><br><span class="line">	<span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)aSRC_Const_Buffer; <span class="comment">// 外设地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)aDST_Buffer;           <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                      <span class="comment">//从Flash 中 Sourse发出 </span></span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE;                         <span class="comment">//传输数目  </span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;         <span class="comment">// 外设地址增量模式：    使能</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 <span class="comment">// 存储器地址增量模式：  使能</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; <span class="comment">// 外设数据宽度：   一个字：32位</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;         <span class="comment">// 存储器数据宽度： 一个字：32位</span></span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           <span class="comment">// 模式选择 普通模式</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     <span class="comment">// 通道优先级 这里只有一个通道随意配置</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;                             <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结构体初始化以及使能</span></span><br><span class="line">	DMA_Init(DMA1_Channel, &amp;DMA_InitStructure);</span><br><span class="line">    DMA_ClearFlag(DMA1_FLAG);<span class="comment">// 给一个完成标志位</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.头文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DSP_DMA_MTM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DSP_DMA_MTM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE     32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_CLK        RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_Channel    DMA1_Channel6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_FLAG       DMA1_FLAG_HT6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_MTM_Config</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Buffercmp</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span>* pBuffer,<span class="type">uint32_t</span>* pBuffer1, <span class="type">uint16_t</span> BufferLength)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__DSP_DMA_MTM_H*/</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>数据比较函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">Buffercmp</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span>* pBuffer,</span></span><br><span class="line"><span class="params">                <span class="type">uint32_t</span>* pBuffer1, <span class="type">uint16_t</span> BufferLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 数据长度递减 */</span></span><br><span class="line">    <span class="keyword">while</span> (BufferLength--) &#123;</span><br><span class="line">        <span class="comment">/* 判断两个数据源是否对应相等 */</span></span><br><span class="line">        <span class="keyword">if</span> (*pBuffer != *pBuffer1) &#123;</span><br><span class="line">            <span class="comment">/* 对应数据源不相等马上退出函数，并返回0 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 递增两个数据源的地址指针 */</span></span><br><span class="line">        pBuffer++;</span><br><span class="line">        pBuffer1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 完成判断并且对应数据相对 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.主函数中显示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_dma_mtm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span> s = <span class="number">0</span>;</span><br><span class="line">	LED_GPIO_G_Config();</span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;</span><br><span class="line">	</span><br><span class="line">	DMA_MTM_Config();</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG)== RESET);</span><br><span class="line">	</span><br><span class="line">	s = Buffercmp(aSRC_Const_Buffer,aDST_Buffer, BUFFER_SIZE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_GREEN; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="M-to-P-实验设计"><a href="#M-to-P-实验设计" class="headerlink" title="M to P 实验设计"></a>M to P 实验设计</h2><p><strong>编程要点</strong></p>
<ol>
<li>初始化串口</li>
<li>配置DMA初始化结构体</li>
<li>编写主函数 开启串口,发送DMA请求</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.初始化串口只需要拷贝之前的初始化串口内容即可这里就不多写了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置DMA初始化结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_DMA_MTP_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打开DMA的时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(DMA1_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;            <span class="comment">// 外设地址  DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)SendBuff;              <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;                      <span class="comment">//从Flash 中 Sourse发出 </span></span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;                        <span class="comment">//传输数目  </span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;         <span class="comment">// 外设地址增量模式：    使能</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                  <span class="comment">// 存储器地址增量模式：  使能</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  <span class="comment">// 外设数据宽度：   一个字节：8位</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;      <span class="comment">// 存储器数据宽度： 一个字节：8位</span></span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           <span class="comment">// 模式选择 普通模式</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     <span class="comment">// 通道优先级 这里只有一个通道随意配置</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable ;                           <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结构体初始化以及使能</span></span><br><span class="line">	</span><br><span class="line">	DMA_Init(USART_DMA1_Channel, &amp;DMA_InitStructure);</span><br><span class="line">	DMA_ClearFlag(USART_DMA1_FLAG);</span><br><span class="line">	DMA_Cmd(USART_DMA1_Channel, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面再加一个printf的使用</span></span><br></pre></td></tr></table></figure>

<p>2.头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_DMA_MTP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_DMA_MTP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_CLK                 RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_DMA1_Channel       DMA1_Channel4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_DMA1_FLAG          DMA1_FLAG_HT4</span></span><br><span class="line"><span class="comment">// 外设寄存器地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  USART_DR_ADDRESS        (USART1_BASE+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENDBUFF_SIZE            5000</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面是配置串口使用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PIN     GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PORT    GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_CLK     RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PIN     GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PORT    GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_BT   115200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CLK  RCC_APB2Periph_USART1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_IRQ  USART1_IRQn</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_DMA_MTP_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/*__BSP_DMA_MTP_H*/</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_dma_mtp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;</span><br><span class="line">	</span><br><span class="line">	USART1_Config(); <span class="comment">//初始化串口</span></span><br><span class="line">	</span><br><span class="line">    USART1_DMA_MTP_Config(); <span class="comment">//初始化DMA</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;SENDBUFF_SIZE ; i++) <span class="comment">//把M 填满</span></span><br><span class="line">	&#123;</span><br><span class="line">		SendBuff[i]=<span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE); <span class="comment">//发送请求</span></span><br><span class="line">	<span class="comment">//现象可以边闪烁边发送数据</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_GREEN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="常用的存储器"><a href="#常用的存储器" class="headerlink" title="常用的存储器"></a>常用的存储器</h1><h2 id="存储器的种类"><a href="#存储器的种类" class="headerlink" title="存储器的种类"></a>存储器的种类</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag002.jpeg" alt="基本存储器种类"></p>
<p>易失性: 掉电数据是否容易丢失</p>
<p>易失性存储器:相对来说读写速度较快</p>
<ul>
<li>内存条</li>
</ul>
<p>不易失性存储器:</p>
<ul>
<li>硬盘</li>
</ul>
<h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>random access memory, 随意存储, 存储位置和读取速度没有关系</p>
<ul>
<li>DRAM: 动态的RAM (电容构成 )会通过不断充电放电,保持0/1的稳定</li>
<li>SRAM : 静态的RAM (锁存器构成)</li>
</ul>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag01.png" alt="DRAM与SRAM对比"></p>
<h3 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag02.png" alt="NOR_FLASH与NAND_FLASH特性对比"></p>
<p>FLASH存储器又称为闪存，它也是可重复擦写的储器</p>
<p>坏块：</p>
<p>XIP： 以字节的方式读写 直接读取数据</p>
<hr>
<h1 id="读写EEPROM"><a href="#读写EEPROM" class="headerlink" title="读写EEPROM"></a>读写EEPROM</h1><h2 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h2><h3 id="I2C的物理层"><a href="#I2C的物理层" class="headerlink" title="I2C的物理层"></a>I2C的物理层</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C002.png" alt="常见的I2C通讯系统"></p>
<ul>
<li>“总线”指多个设备共用的信号线。在一个I2C通讯总线中， 可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机。</li>
</ul>
<p>注意:iic在同一时间只能和一个设备通信</p>
<p>SCL：串行时钟线， </p>
<p>SDA： 双线串行数据线</p>
<p>每个连接到总线的数据都有一个独立地址，主机可以通过这个地址来实现不同地址的访问</p>
<p>总线通过接一个上拉店主街道电源. 使得处于不和主机通讯的空闲状态时,会输出高阻态. 方便实现线与 以及防止数据冲突 </p>
<blockquote>
<p>高阻态，目的是为了阻抗匹配，高阻态的时候获取外部信号的能力非常强，这样不会错过外部的电平变化</p>
</blockquote>
<blockquote>
<blockquote>
<p>需要高阻态。即：有一个设备输出高阻态时，总线就被拉成0V，若空闲为0，工作为1，则空闲设备相当于接地。后果是把总线上的电压拉成了0V，其他设备的电压会流入该设备，造成设备短路.主机由此知道总线正在被占用。而只有当所有设备都空闲，都输出高阻态时，总线才能检测到高电平（上拉电阻的作用）</p>
</blockquote>
</blockquote>
<p>I2C的传输速度: 标准模式传输速率为100kbit/s ，快速模式为400kbit/s ， 高速模式下可达 3.4Mbit/s，</p>
<h3 id="I2C的协议层"><a href="#I2C的协议层" class="headerlink" title="I2C的协议层"></a>I2C的协议层</h3><p>I2C的协议定义了 通讯的<strong>起始和停止信号</strong>、<strong>数据有效性</strong>、<strong>响应</strong>、<strong>仲裁</strong>、<strong>时钟同步</strong>和<strong>地址广播</strong>等环节。</p>
<h4 id="I2C的基本读写过程"><a href="#I2C的基本读写过程" class="headerlink" title="I2C的基本读写过程"></a>I2C的基本读写过程</h4><ol>
<li><strong>主机写数据到从机</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C003.jpg" alt="主机写数据到从机"></p>
<p>数据方向: 主机到从机</p>
<p>主机每传输一个字节, 从机会返回一个A的应答信号, 从机接收不了时会发送一个A非信号告诉中止</p>
<ol start="2">
<li><strong>主机从从机读数据</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C004.jpg" alt="主机由从机中读数据"></p>
<p>数据方向: 从机到总机</p>
<p>灰色部分由主机产生</p>
<ol start="3">
<li><strong>通讯复合格式</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C005.jpeg" alt="I2C通讯复合格式"></p>
<p>在第一次传输中， 主机通过SLAVE_ADDRESS寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与SLAVE_ADDRESS的区别)； 在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。</p>
<h4 id="通讯的起始和停止信号"><a href="#通讯的起始和停止信号" class="headerlink" title="通讯的起始和停止信号"></a>通讯的起始和停止信号</h4><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C008.jpg" alt="起始和停止信号"></p>
<p>起始信号: 在SCL为高电平时,SDA一个下降沿</p>
<p>停止信号: 在SCL为高电平时,SDA一个上升沿</p>
<h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C009.jpg" alt="数据有效性"></p>
<ul>
<li>一个时钟传输一个数据位, </li>
</ul>
<p>SCL位高电平时,表示读入SDA的数据</p>
<p>SCL为低电平时, 可以让SDA进行数据切换(有效防止数据传输的延时问题)</p>
<h4 id="地址及数据方向"><a href="#地址及数据方向" class="headerlink" title="地址及数据方向"></a>地址及数据方向</h4><p>I2C协议规定设备地址可以是7位或10位，实际中<strong>7位</strong>的地址应用比较广泛</p>
<p>紧跟设备地址的<strong>一个数据位</strong>用来表示数据传输方向, 确认是读还是写—0(读),1(写)</p>
<p>这里就构成了一个字节</p>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>I2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C011.jpg" alt="响应与非响应信号"></p>
<h2 id="STM32的I2C特性及架构"><a href="#STM32的I2C特性及架构" class="headerlink" title="STM32的I2C特性及架构"></a>STM32的I2C特性及架构</h2><ul>
<li>“软件模拟协议” </li>
</ul>
<p>直接控制STM32的两个GPIO引脚，分别用作SCL及SDA，按照上述信号的时序要求， 直接像控制LED灯那样控制引脚的输出(若是接收数据时则读取SDA电平)，就可以实现I2C通讯。</p>
<ul>
<li>“硬件协议” </li>
</ul>
<p>STM32的I2C片上外设专门负责实现I2C通讯协议， 只要配置好该外设，它就会自动根据协议要求产生通讯信号，收发数据并缓存起来， CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。</p>
<ul>
<li>STM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。</li>
</ul>
<h3 id="STM32的I2C架构剖析"><a href="#STM32的I2C架构剖析" class="headerlink" title="STM32的I2C架构剖析"></a>STM32的I2C架构剖析</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C012.jpg" alt="I2C架构图"></p>
<ol>
<li>通信引脚</li>
</ol>
<p>STM32F10x的I2C引脚,根据数据手册查出</p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>I2C1</th>
<th>I2C2</th>
</tr>
</thead>
<tbody><tr>
<td>SCL</td>
<td>PB6 / PB8(重映射)</td>
<td>PB10</td>
</tr>
<tr>
<td>SDA</td>
<td>PB7 / PB9(重映射)</td>
<td>PB11</td>
</tr>
</tbody></table>
<p>SMBA用的比较少这里不多做说明</p>
<ol start="2">
<li>时钟控制逻辑</li>
</ol>
<p>SCL线的时钟信号，由I2C接口根据时钟控制寄存器(CCR)控制， 控制的参数主要为时钟频率。配置I2C的CCR寄存器可修改通讯速率相关的参数：</p>
<p>此处计算只需要了解即可,后面计算时钟频率时有响应的库函数</p>
<p><strong>标准模式：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = CCR</em>T_{PCLK1}$</p>
<p><strong>快速模式中</strong> DUTY:  $T_{low}/T_{high}=2$  <strong>时：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = 2</em> CCR*T_{PCLK1}$</p>
<p><strong>快速模式中</strong> DUTY: $T_{low}/T_{high}=16/9$ <strong>时：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = 16</em>CCR*T_{PCLK1}$</p>
<p>PCLK1 表示 APB1上挂的时钟</p>
<ol start="3">
<li>数据控制逻辑</li>
</ol>
<p>数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC寄存器以及SDA数据线</p>
<p>比较器通过比较传来的地址和自身地址寄存器的内容进行比较,从而知道是不是叫自己</p>
<h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C013.jpg" alt="主发送器通讯过程"></p>
<p>这里是使用状态寄存器 I2C_SR1</p>
<p>响应的信号发送成功后, 数据状态寄存器会发生响应的状态</p>
<p>动作寄存器做一个内容之后, 下面的状态寄存器会做出响应的响应,确保工作的状态</p>
<p>因为STM32的传输速度比I2C速度快很多</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C014.jpg" alt="主接收器过程"></p>
<p>主接收器和主发送器的内容几乎一样</p>
<p>$A^{(1)}$是表示STM32接收到了数据做出的响应</p>
<p>EV7_1,要比EV7多设置一点步骤</p>
<p>NA: 非应答响应</p>
<h2 id="I2C的库函数"><a href="#I2C的库函数" class="headerlink" title="I2C的库函数"></a>I2C的库函数</h2><ol>
<li>I2C的初始化结构体</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> I2C_ClockSpeed;       <span class="comment">/*!&lt; 设置SCL时钟频率，此值要低于400000*/</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_Mode;             <span class="comment">/*!&lt; 指定工作模式，可选I2C模式及SMBUS模式 */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_DutyCycle;        <span class="comment">/*指定时钟占空比，可选low/high = 2:1及16:9模式*/</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_OwnAddress1;      <span class="comment">/*!&lt; 指定自身的I2C设备地址 */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_Ack;                 <span class="comment">/*!&lt; 使能或关闭响应(一般都要使能) */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_AcknowledgedAddress; <span class="comment">/*!&lt; 指定地址的长度，可为7位及10位 */</span></span><br><span class="line">&#125; I2C_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h2 id="I2C—读写EEPROM实验"><a href="#I2C—读写EEPROM实验" class="headerlink" title="I2C—读写EEPROM实验"></a>I2C—读写EEPROM实验</h2><h3 id="硬件设计-4"><a href="#硬件设计-4" class="headerlink" title="硬件设计"></a>硬件设计</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C015.png" alt="EEPROM硬件连接图"></p>
<h3 id="软件设计-4"><a href="#软件设计-4" class="headerlink" title="软件设计"></a>软件设计</h3><p>编程要点:</p>
<ol>
<li><p>初始化IIC相关的GPIO – PB6， PB7</p>
</li>
<li><p>配置IIC外设的工作模式</p>
</li>
<li><p>编写IIC写入EEPROM Byte write        的函数</p>
</li>
<li><p>编写IIC读入EEPROM RANDOM read的函数</p>
</li>
<li><p>使用read函数以及write函数进行校验</p>
</li>
<li><p>编写初始化结构体</p>
</li>
</ol>
<p><code>.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_i2c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置SCL GPIO的PA9</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(SCL_CLK , ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = SCL_PIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(SCL_PORT , &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配值SAD GPIO的PA10</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = SAD_PIN;</span><br><span class="line">	GPIO_Init(SAD_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置I2C1</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(I2C_CLK , ENABLE);</span><br><span class="line"></span><br><span class="line">	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit ;</span><br><span class="line">	I2C_InitStructure.I2C_ClockSpeed = I2C_BT;</span><br><span class="line">	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class="line">	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">	I2C_InitStructure.I2C_OwnAddress1 = I2Cx_OWN_ADDRESS7;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化与使能</span></span><br><span class="line">	I2C_Init(I2C1, &amp;I2C_InitStructure );</span><br><span class="line">	I2C_Cmd(I2C1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>.h</code>文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//PB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_PIN     GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_PORT    GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_CLK     RCC_APB2Periph_GPIOB</span></span><br><span class="line"><span class="comment">//PB7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAD_PIN     GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAD_PORT    GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_BT   400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLK  RCC_APB1Periph_I2C1</span></span><br><span class="line"><span class="comment">/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2Cx_OWN_ADDRESS7      0X0A</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_USART_H*/</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写 字节发送函数</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C013.jpg" alt="主发送器通讯过程"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//关于这函数的编写由于有点复杂，所以先不放在这了，仔细看给的工程文件代码</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于后面是关于数据存储FLASH，和数据的发送</p>
<p>关于这块内容，数电还没有跟上，而且和EEPROM有比较强的相似性</p>
<p>打算后面用到了再回过头学习，接下来先学习高级篇</p>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电赛准备</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习（入门篇）</title>
    <url>/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<p>本文使用的是野火生产的[STM32-指南针]([关于本项目 — <a href="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/README.html">野火]STM32库开发实战指南——基于野火指南者开发板 文档 (embedfire.com)</a>)，观看野火教程的<a href="%5B3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8DAP%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Xs411g7Aj?p=1&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">学习视频</a>的学习笔记</p>
<h1 id="DAP仿真软件的配置"><a href="#DAP仿真软件的配置" class="headerlink" title="DAP仿真软件的配置"></a>DAP仿真软件的配置</h1><p>这里观看这里的教程：[DAP仿真器与串口下载程序 — <a href="https://doc.embedfire.com/stm32_products/must_read/zh/latest/doc/quickstart/DAP/DAP.html">野火]STM32开发板必读说明 文档 (embedfire.com)</a></p>
<p><img src="https://doc.embedfire.com/stm32_products/must_read/zh/latest/_images/DAP_0.png" alt="../../../_images/DAP_0.png"></p>
<p>左侧不出现，注意换一个USB口。右侧不出现，DAP插入开发板时，换成SWD</p>
<p>普通DAP注意connect：under Reset 。Reset 选择HW RESET或者 VECTRESTET </p>
<p>注意配置，配置好后，DAP仿真器应该亮绿灯。</p>
<p>编译完成后点击LOAD即可下载程序。</p>
<hr>
<h1 id="什么是STM32"><a href="#什么是STM32" class="headerlink" title="什么是STM32"></a>什么是STM32</h1><h2 id="STM32的引脚说明"><a href="#STM32的引脚说明" class="headerlink" title="STM32的引脚说明"></a>STM32的引脚说明</h2><table>
<thead>
<tr>
<th>引脚分类</th>
<th>引脚说明说明</th>
</tr>
</thead>
<tbody><tr>
<td>电源</td>
<td>(VBAT)、(VDD Vss)、(VDDA VSSA)、(VREF+VREF-)等</td>
</tr>
<tr>
<td>晶振IO</td>
<td>主晶振IO，RTC晶振IO</td>
</tr>
<tr>
<td>下载IO</td>
<td>用于JTAG下载的IO:JTMS、JTCK、JTDI、JTDO、NJTRST</td>
</tr>
<tr>
<td>BOOT IO</td>
<td>BOOTo、BOOT1，用于设置系统的启动方式</td>
</tr>
<tr>
<td>复位IO</td>
<td>NRST，用于外部复位</td>
</tr>
<tr>
<td></td>
<td>上面5部分IO组成的系统我们也叫做最小系统</td>
</tr>
<tr>
<td>GPIO</td>
<td>专用器件接到专用的总线，比如I2C，SPI，SDIO，FSMC，DCMI这些总线的器件需要接到专用的IO</td>
</tr>
<tr>
<td>GPIO</td>
<td>普通的元器件接到GPIO，比如蜂鸣器，LED，按键等元器件用普通的GPIO即</td>
</tr>
<tr>
<td>GPIO</td>
<td>如果还有剩下的IO，可根据项目需要引出或者不引出</td>
</tr>
</tbody></table>
<p>具体引脚的功能说明见 数据手册(最好读英文)</p>
<hr>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h2><p>意义： 给有特殊意义的地址取了一个别名</p>
<p>STM32中的 头文件 <code>#include &quot;stm32f10x.h&quot;</code></p>
<p>以及51单片机中的 头文件<code>#inclde &quot;reg51.h&quot;</code></p>
<p>中都是存放着寄存器映射</p>
<h2 id="以GPIOB口为例子"><a href="#以GPIOB口为例子" class="headerlink" title="以GPIOB口为例子"></a>以GPIOB口为例子</h2><p>我们找到GPIOB端口的输出数据寄存器ODR的地址是0x40010C0C</p>
<blockquote>
<p>(在官方参考手册的 2.3存储器映像中找到起始位置)</p>
</blockquote>
<p>ODR寄存器是32bit，低16bit有效，对应着16个外部IO，写0/1对应的的IO则输出低/高电平。</p>
<p>通过下面语句将其全部置为一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0x4001</span> <span class="number">0</span>C0C) = <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">// 我们对位操作时通常使用位操作符 |,&amp;的形式 在之后会介绍</span></span><br></pre></td></tr></table></figure>

<p>我们给<code>*(unsigned int*)(0x4001 0C0C)</code>定义一个别名,就是寄存器映射</p>
<p>上面所讲的头文件实际上就是对 各个特殊意义的地址取了别名后进行封装</p>
<hr>
<hr>
<h1 id="新建工程模板"><a href="#新建工程模板" class="headerlink" title="新建工程模板"></a>新建工程模板</h1><h2 id="点亮一盏灯-简易版"><a href="#点亮一盏灯-简易版" class="headerlink" title="点亮一盏灯(简易版)"></a>点亮一盏灯(简易版)</h2><ol>
<li>首先看电路原理图</li>
</ol>
<p>通过PB0端口来控制绿灯的点亮</p>
<p>![img](STM32 学习/SVF7QMT2%$O`06832X``8EQ.png)</p>
<p>PB0 由GPIOB_ODR(output data register) 端口输出寄存器控制</p>
<ul>
<li><p>找到 GPIOB的地址为 <code>0X4001 0C00 </code></p>
</li>
<li><p>ODR的地址偏移：0C h</p>
</li>
<li><p>点亮灯-让最低位输出零</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X4001</span> <span class="number">0</span>C0C) &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"><span class="comment">//这步骤是 让最后一位置零,并且不影响其他位的取值</span></span><br><span class="line"><span class="comment">//注意ODR的复位值：0x0000 0000,不进行这步,灯也会亮,但是为了可读一定要加上这一句</span></span><br></pre></td></tr></table></figure>

<p>但是STM32比51单片机高级的地方在于PB0口既可以当作输入 又可以当作输出,而且默认为输入</p>
<p>这里我们要将它 <strong>配置IO口为输出</strong></p>
<p>![image-20221226223404869](STM32 学习/image-20221226223404869.png)</p>
<p>PB0是0 所以是最后四位</p>
<p>使用 通用推挽输出模式[0,0]</p>
<p>模式控制速度这里选择10MHZ</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X4001</span> <span class="number">0</span>C00) &amp;= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>然后我们发现要控制GPIOB打开 还得控制时钟打开</p>
<p>![](STM32 学习/image-20221226223936675.png)</p>
<p>由寄存器组起始地址表中,查到RCC的地址是 0x4002 1000</p>
<p>然后再APB2 外设时钟使能寄存器(RCC_APB2ENR)中看到</p>
<p>![image-20221226224355093](STM32 学习/image-20221226224355093.png)</p>
<p>![image-20221226224416328](STM32 学习/image-20221226224416328.png)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X0</span>x4002 <span class="number">1018</span>) &amp;= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//亮绿灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40021018</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C00</span>) |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));<span class="comment">//4*1-蓝灯 4*5红灯</span></span><br><span class="line">	<span class="comment">// 控制ODR寄存器 让灯亮</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) &amp;= ~(<span class="number">0</span>&lt;&lt;<span class="number">0</span>)<span class="comment">//&lt;&lt;1-蓝灯,&lt;&lt;5红灯	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> SystemInit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//闪烁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">400</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">400</span>;j++);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40021018</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C00</span>) |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 控制ODR寄存器 让灯亮</span></span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		delay();</span><br><span class="line">		<span class="comment">// 控制ODR寄存器 让灯灭</span></span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		delay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用寄存器点亮一盏灯"><a href="#使用寄存器点亮一盏灯" class="headerlink" title="使用寄存器点亮一盏灯"></a>使用寄存器点亮一盏灯</h1><h2 id="读GPIO的系统框图"><a href="#读GPIO的系统框图" class="headerlink" title="读GPIO的系统框图"></a>读GPIO的系统框图</h2><p>![7](STM32 学习/7.png)</p>
<ul>
<li><p>上半部分是输入部分</p>
</li>
<li><p>下半部分是输出部分</p>
</li>
</ul>
<p>圈2这个位置是选择工作模式</p>
<p>通常选择推挽工作模式</p>
<p>开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中，或者是电平不匹配的场合</p>
<p>圈3这个位置就是我们的ODR控制输出，也可以通过BSRR 位设置、清除寄存器控制</p>
<p>输入部分</p>
<p>首先是一个上拉下拉 在端口配置低寄存器中选择上拉/下拉模式</p>
<p>然后是TTL 也称为0/1转换器来实现数模转换</p>
<p>圈5是IDR</p>
<p>圈6读取数字信号</p>
<p>圈7读取模拟信号</p>
<h2 id="自己写寄存器映射到头文件中"><a href="#自己写寄存器映射到头文件中" class="headerlink" title="自己写寄存器映射到头文件中"></a>自己写寄存器映射到头文件中</h2><p>打开头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义总线的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2 (unsigned int)0x40010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABH  (unsigned int)0x40020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB1 (unsigned int)0x40000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据寄存器偏移确定外设的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB (APB2+0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSS   (ABH +0x1000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制特定的寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRL  *(unsigned int*)(GPIOB+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRH  *(unsigned int*)(GPIOB+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR  *(unsigned int*)(GPIOB+0x0C)</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR *(unsigned int*)(RSS+0x18)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*片上外设基地址  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE         ((unsigned int)0x40000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*总线基地址，GPIO都挂载到APB2上 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/* AHB总线基地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHBPERIPH_BASE      (PERIPH_BASE + 0x20000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIOB外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE          (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIOB寄存器地址,强制转换成指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRL           *(unsigned int*)(GPIOB_BASE+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRH           *(unsigned int*)(GPIOB_BASE+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_IDR           *(unsigned int*)(GPIOB_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR           *(unsigned int*)(GPIOB_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BSRR          *(unsigned int*)(GPIOB_BASE+0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BRR           *(unsigned int*)(GPIOB_BASE+0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_LCKR          *(unsigned int*)(GPIOB_BASE+0x18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*RCC外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE           (AHBPERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="comment">/*RCC的AHB1时钟使能寄存器地址,强制转换成指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR        *(unsigned int*)(RCC_BASE+0x18)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	RCC_APB2ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	GPIOB_CRL |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 控制GPIOB_BSRR, GPIOB_BRR寄存器 让灯亮</span></span><br><span class="line">	GPIOB_BRR  |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	GPIOB_BSRR |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="构建STM32库函数的雏形"><a href="#构建STM32库函数的雏形" class="headerlink" title="构建STM32库函数的雏形"></a>构建STM32库函数的雏形</h1><h2 id="通过结构体来访问地址"><a href="#通过结构体来访问地址" class="headerlink" title="通过结构体来访问地址"></a>通过结构体来访问地址</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*片上外设基地址  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE         ((unsigned int)0x40000000)</span></span><br><span class="line"><span class="comment">/*总线基地址，GPIO都挂载到APB2上 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/*GPIOB外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE          (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 寄存器结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">uint32_t</span> CRL;       <span class="comment">// 端口配置低寄存器，     地址偏移0X00</span></span><br><span class="line">   <span class="type">uint32_t</span> CRH;       <span class="comment">// 端口配置高寄存器，     地址偏移0X04</span></span><br><span class="line">   <span class="type">uint32_t</span> IDR;       <span class="comment">// 端口数据输入寄存器，   地址偏移0X08</span></span><br><span class="line">   <span class="type">uint32_t</span> ODR;       <span class="comment">// 端口数据输出寄存器，   地址偏移0X0C</span></span><br><span class="line">   <span class="type">uint32_t</span> BSRR;      <span class="comment">// 端口位设置/清除寄存器，地址偏移0X10</span></span><br><span class="line">   <span class="type">uint32_t</span> BRR;       <span class="comment">// 端口位清除寄存器，     地址偏移0X14</span></span><br><span class="line">   <span class="type">uint32_t</span> LCKR;      <span class="comment">// 端口配置锁定寄存器，   地址偏移0X18</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GBIO ((GPIO_TypeDef*)GPIOB_BASE)</span></span><br><span class="line"><span class="comment">//之后就可以用 GBIO-&gt;CRL来访问CRL</span></span><br></pre></td></tr></table></figure>

<h2 id="通过建立库函数来控制GPIO"><a href="#通过建立库函数来控制GPIO" class="headerlink" title="通过建立库函数来控制GPIO"></a>通过建立库函数来控制GPIO</h2><ol>
<li>在工程文件下 新建一个<code>.h</code>的头文件和同名的<code>.c</code>文件 并加到工程文件中</li>
<li>在新建的<code>.c</code>文件中调用<code>.h</code>文件</li>
<li><code>.h</code>文件中要采取固定方式书写,防止重复调用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F10X_GPIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F10X_GPIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分别定义每个引脚 置1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_0              (uint16_t)0x0001)  <span class="comment">/*!&lt; 选择Pin0 (1&lt;&lt;0) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_1              ((uint16_t)0x0002)  <span class="comment">/*!&lt; 选择Pin1 (1&lt;&lt;1)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_2              ((uint16_t)0x0004)  <span class="comment">/*!&lt; 选择Pin2 (1&lt;&lt;2)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_3              ((uint16_t)0x0008)  <span class="comment">/*!&lt; 选择Pin3 (1&lt;&lt;3)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_4              ((uint16_t)0x0010)  <span class="comment">/*!&lt; 选择Pin4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_5              ((uint16_t)0x0020)  <span class="comment">/*!&lt; 选择Pin5 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6              ((uint16_t)0x0040)  <span class="comment">/*!&lt; 选择Pin6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7              ((uint16_t)0x0080)  <span class="comment">/*!&lt; 选择Pin7 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8              ((uint16_t)0x0100)  <span class="comment">/*!&lt; 选择Pin8 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_9              ((uint16_t)0x0200)  <span class="comment">/*!&lt; 选择Pin9 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_10             ((uint16_t)0x0400)  <span class="comment">/*!&lt; 选择Pin10 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_11             ((uint16_t)0x0800)  <span class="comment">/*!&lt; 选择Pin11 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_12             ((uint16_t)0x1000)  <span class="comment">/*!&lt; 选择Pin12 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_13             ((uint16_t)0x2000)  <span class="comment">/*!&lt; 选择Pin13 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_14             ((uint16_t)0x4000)  <span class="comment">/*!&lt; 选择Pin14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_15             ((uint16_t)0x8000)  <span class="comment">/*!&lt; 选择Pin15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_All            ((uint16_t)0xFFFF)  <span class="comment">/*!&lt; 选择全部引脚 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面可以加函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*__STM32F10X_GPIO_H*/</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>.c</code>文件中写函数</p>
<ol start="4">
<li>最后只需在<code>main.c</code>声明 <code>#include XX.h</code>即可使用函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建初始化函数"><a href="#构建初始化函数" class="headerlink" title="构建初始化函数"></a>构建初始化函数</h2><ol>
<li>定义结构体存放初始化的配置</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;      <span class="comment">/*!&lt; 选择要配置的GPIO引脚 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Speed;    <span class="comment">/*!&lt; 选择GPIO引脚的速率 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Mode;     <span class="comment">/*!&lt; 选择GPIO引脚的工作模式 */</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义枚举类型 对每一个模式进行赋值</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel004.png" alt="端口配置低寄存器"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* GPIO输出速率枚举定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Speed_10MHz = <span class="number">1</span>,         <span class="comment">// 10MHZ        (01)b</span></span><br><span class="line">    GPIO_Speed_2MHz,              <span class="comment">// 2MHZ         (10)b</span></span><br><span class="line">    GPIO_Speed_50MHz              <span class="comment">// 50MHZ        (11)b</span></span><br><span class="line">&#125; GPIOSpeed_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* GPIO工作模式枚举定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Mode_AIN = <span class="number">0x0</span>,           <span class="comment">// 模拟输入     (0000 0000)b</span></span><br><span class="line">    GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,  <span class="comment">// 浮空输入     (0000 0100)b</span></span><br><span class="line">    GPIO_Mode_IPD = <span class="number">0x28</span>,          <span class="comment">// 下拉输入     (0010 1000)b</span></span><br><span class="line">    GPIO_Mode_IPU = <span class="number">0x48</span>,          <span class="comment">// 上拉输入     (0100 1000)b</span></span><br><span class="line"></span><br><span class="line">    GPIO_Mode_Out_OD = <span class="number">0x14</span>,       <span class="comment">// 开漏输出     (0001 0100)b</span></span><br><span class="line">    GPIO_Mode_Out_PP = <span class="number">0x10</span>,       <span class="comment">// 推挽输出     (0001 0000)b</span></span><br><span class="line">    GPIO_Mode_AF_OD = <span class="number">0x1C</span>,        <span class="comment">// 复用开漏输出  (0001 1100)b</span></span><br><span class="line">    GPIO_Mode_AF_PP = <span class="number">0x18</span>         <span class="comment">// 复用推挽输出  (0001 1000)b</span></span><br><span class="line">&#125; GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义GPIO初始化函数,来实现寄存器配置</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel006.png" alt="GPIO引脚工作模式真值表分析"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*函数功能：初始化引脚模式</span></span><br><span class="line"><span class="comment">*参数说明：GPIOx，该参数为GPIO_TypeDef类型的指针，指向GPIO端口的地址</span></span><br><span class="line"><span class="comment">*         GPIO_InitTypeDef:GPIO_InitTypeDef结构体指针，指向初始化变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> currentmode =<span class="number">0x00</span>,currentpin = <span class="number">0x00</span>,pinpos = <span class="number">0x00</span>,pos = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">uint32_t</span> tmpreg = <span class="number">0x00</span>, pinmask = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*---------------- GPIO 模式配置 -------------------*/</span></span><br><span class="line">    <span class="comment">// 把输入参数GPIO_Mode的低四位暂存在currentmode</span></span><br><span class="line">    currentmode = ((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp;</span><br><span class="line">                ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bit4是1表示输出，bit4是0则是输入</span></span><br><span class="line">    <span class="comment">// 判断bit4是1还是0，即首选判断是输入还是输出模式</span></span><br><span class="line">    <span class="keyword">if</span> ((((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp;</span><br><span class="line">            ((<span class="type">uint32_t</span>)<span class="number">0x10</span>)) != <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出模式则要设置输出速度</span></span><br><span class="line">        currentmode |= (<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*-----GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- ----*/</span></span><br><span class="line">    <span class="comment">// 配置端口低8位，即Pin0~Pin7</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Pin &amp;</span><br><span class="line">            ((<span class="type">uint32_t</span>)<span class="number">0x00FF</span>)) != <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先备份CRL寄存器的值</span></span><br><span class="line">        tmpreg = GPIOx-&gt;CRL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环，从Pin0开始配对，找出具体的Pin</span></span><br><span class="line">        <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pos的值为1左移pinpos位</span></span><br><span class="line">            pos = ((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 令pos与输入参数GPIO_PIN作位与运算</span></span><br><span class="line">            currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">            <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚</span></span><br><span class="line">                pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">                pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">                tmpreg &amp;= ~pinmask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">                tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 下拉输入模式,引脚默认置0,对BRR寄存器写1对引脚置0</span></span><br><span class="line">                    GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">                    <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 上拉输入模式,引脚默认值为1,对BSRR寄存器写1对引脚置1</span></span><br><span class="line">                        GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前面处理后的暂存值写入到CRL寄存器之中</span></span><br><span class="line">        GPIOx-&gt;CRL = tmpreg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*--------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----*/</span></span><br><span class="line">    <span class="comment">// 配置端口高8位，即Pin8~Pin15</span></span><br><span class="line">    <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class="number">0x00FF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// // 先备份CRH寄存器的值</span></span><br><span class="line">        tmpreg = GPIOx-&gt;CRH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环，从Pin8开始配对，找出具体的Pin</span></span><br><span class="line">        <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pos与输入参数GPIO_PIN作位与运算</span></span><br><span class="line">            currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">            <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚</span></span><br><span class="line">                pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">                pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">                tmpreg &amp;= ~pinmask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">                tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 下拉输入模式,引脚默认置0,对BRR寄存器写1可对引脚置0</span></span><br><span class="line">                    GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 上拉输入模式,引脚默认值为1,对BSRR寄存器写1可对引脚置1</span></span><br><span class="line">                    GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前面处理后的暂存值写入到CRH寄存器之中</span></span><br><span class="line">        GPIOx-&gt;CRH = tmpreg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提高代码的可移植性"><a href="#提高代码的可移植性" class="headerlink" title="提高代码的可移植性"></a>提高代码的可移植性</h2><p>涉及到GPIO端口时候利用 宏来进行替换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_GPIO_PORT GPIOB <span class="comment">//将点亮的端口用宏替代</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK_ENABLE (RCC-&gt;APB2ENR |=((1)&lt;&lt;3)) <span class="comment">//点亮对应端口的时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_GPIO_PIN GPIO_pin_0 <span class="comment">//LED_G对应PB0是第一个引脚</span></span></span><br></pre></td></tr></table></figure>

<p>将后面的代码用宏来替代</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>直接操作内存-&gt;寄存器映射-&gt;利用寄存器结构体方便访问结构体成员-&gt;加强可读性(编写函数)-&gt;定义初始化结构体(将所有要配置的参数枚举出来)-&gt;利用宏定义增强可移植性</p>
<hr>
<h1 id="固件库编程"><a href="#固件库编程" class="headerlink" title="固件库编程"></a>固件库编程</h1><h2 id="分析固件库内容"><a href="#分析固件库内容" class="headerlink" title="分析固件库内容"></a>分析固件库内容</h2><ol>
<li>汇编语言编写的启动文件(简单)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">startup_stm32f10x_hd.c: 设置堆栈指针,设置PC指针,初始化中断向量表,配置系统时钟,对用C库函数,进入C语言的环境</span><br><span class="line">hd,表示大小</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer01.png" alt="详细说明见表"></p>
<ol start="2">
<li>时钟配置文件(简单)</li>
</ol>
<p>system_stm32f10zx.c: 把系统时钟HSE=8M, 经过PLL 倍频为PLL=72M</p>
<ol start="3">
<li><strong>stm32f10x.h</strong> </li>
</ol>
<p>ST生产的外设相关的: 实现寄存器映射</p>
<p>XXX: GPIO,USRAT,I2C,SPI,FSMC</p>
<p>stm32f10x_XX.h :存放外设初始化结构体,外设初始化结构体成员的参数列表,外设固件库函数声明</p>
<p>stm32f10x_XX.c :外设驱动函数库文件</p>
<ol start="4">
<li><strong>core_cm.h</strong></li>
</ol>
<p>内核映射: 内核相关的寄存器映射</p>
<p>core_cm.c: 内核外设的驱动固件库</p>
<p>NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器)</p>
<p>misc.h</p>
<p>misc.c</p>
<ol start="5">
<li>在main函数里面定义使用的<strong>头文件</strong></li>
</ol>
<p>为了方便定义了 头文件配置文件: 实现外设所以的文件的声明</p>
<p><strong>stm32f10x_conf.h</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">使用什么外设 就取消什么注释</span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>专门存放中断服务函数的C文件</li>
</ol>
<p>stm32f10x_it.h</p>
<p>stm32f10x_it.c</p>
<p>这个函数可以随意放在其他的地方,并不一定要放到stm32f10x_it.c 中</p>
<h2 id="固件库的内容"><a href="#固件库的内容" class="headerlink" title="固件库的内容"></a>固件库的内容</h2><p>看固件库的头文件来分析函数的作用</p>
<hr>
<h1 id="建立带固件库的工程模板"><a href="#建立带固件库的工程模板" class="headerlink" title="建立带固件库的工程模板"></a>建立带固件库的工程模板</h1><p>基本上看着视频操作，或者书本就可</p>
<p>但是有一点特别注意</p>
<p>![8](STM32 学习/8.png)</p>
<p>将这个版本设置成5，不然不仅编译慢还疯狂报错</p>
<hr>
<h1 id="利用固件库编程点亮LED"><a href="#利用固件库编程点亮LED" class="headerlink" title="利用固件库编程点亮LED"></a>利用固件库编程点亮LED</h1><h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><p>1.主函数内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(LED_G_PORT, LED_G_PIN);    <span class="comment">//set函数将引脚上的 置为1</span></span><br><span class="line">	GPIO_ResetBits(LED_G_PORT, LED_G_PIN);  <span class="comment">//reset函数将引脚上的 置为1</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.bsp_led.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_initstruct; <span class="comment">//定义一个结构体初始化绿灯的内容</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_G_CLK, ENABLE); <span class="comment">//打开绿灯的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//定义绿灯为推挽输出</span></span><br><span class="line">	GPIO_initstruct.GPIO_Pin = LED_G_PIN;          <span class="comment">//将引脚对应为绿灯的引脚</span></span><br><span class="line">	GPIO_initstruct.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//定义速度为50M</span></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_initstruct);            <span class="comment">//使用初始化函数配置到GPIO_CLR</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.bsp_led.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PIN  GPIO_Pin_0                    <span class="comment">// 宏定义绿灯的管脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PORT GPIOB                         <span class="comment">// 宏定义绿灯的端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK  RCC_APB2Periph_GPIOB          <span class="comment">//宏定义绿灯的时钟</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BEP_LED_H*/</span></span></span><br></pre></td></tr></table></figure>

<h2 id="实现流水灯"><a href="#实现流水灯" class="headerlink" title="实现流水灯"></a>实现流水灯</h2><ol>
<li>主函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_GREEN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bsp_led.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_G_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_G_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_G_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_G_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_G_initstruct.GPIO_Pin = LED_G_PIN; </span><br><span class="line">	GPIO_G_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_G_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_B_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_B_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_B_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_B_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_B_initstruct.GPIO_Pin = LED_B_PIN; </span><br><span class="line">	GPIO_B_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_B_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_R_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_R_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_R_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_R_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_R_initstruct.GPIO_Pin = LED_R_PIN; </span><br><span class="line">	GPIO_R_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_R_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>bsp_led.h</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_PIN  GPIO_Pin_1 <span class="comment">//只有端口不同的区别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//红灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_PIN  GPIO_Pin_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开绿灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_G_PORT, LED_G_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_G_PORT, LED_G_PIN); </span></span><br><span class="line"><span class="comment">//开蓝灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_B_PORT, LED_B_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_B_PORT, LED_B_PIN); </span></span><br><span class="line"><span class="comment">//开蓝灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_R_PORT, LED_R_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_R_PORT, LED_R_PIN); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示红色</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RED  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_GREEN       \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_BLUE    \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//黄(红+绿)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_YELLOW  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"><span class="comment">//紫(红+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PURPLE  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//青(绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_CYAN \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//白(红+绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WHITE   \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//黑(全部关闭)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RGBOFF  \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BEP_LED_H*/</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="GPIO输入-按键检测"><a href="#GPIO输入-按键检测" class="headerlink" title="GPIO输入- 按键检测"></a>GPIO输入- 按键检测</h1><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIOin003.png" alt="按键原理图"></p>
<p>这里采用了连接<strong>电容</strong>的方式来<strong>物理消抖</strong></p>
<p>R57和R15的作用都是保护电路</p>
<p>如果按键按下就会 读到高电平 按键不按下的时候会得到低电平</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><ol>
<li>对引脚进行初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在.h文件中</span></span><br><span class="line"><span class="comment">//KEY1宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="comment">//在.c文件中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_G_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct; <span class="comment">//定义KEY1的结构体</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_G_CLK, ENABLE); <span class="comment">//打开KEY1对应的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//设置模式为浮空输入模式</span></span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_G_PIN;   <span class="comment">//设置KEY1对应的引脚</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_G_PORT, &amp;GPIO_KEY1_initstruct); <span class="comment">//调用初始化函数配置到寄存器中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写按键检测函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span> <span class="comment">//传入对应的端口和引脚</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON ) <span class="comment">//是否按下 按下为1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON);<span class="comment">//松手检测</span></span><br><span class="line">		<span class="keyword">return</span> KEY_ON;  <span class="comment">//返回按下</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> KEY_OFF; <span class="comment">//返回没有按下</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>灯状态变化函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LED_G_TOGGLE; <span class="comment">//宏定义函数 相当于对 对应位取反</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_TOGGLE &#123;LED_G_PORT-&gt;ODR ^= LED_G_PIN ;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写好的文件"><a href="#编写好的文件" class="headerlink" title="编写好的文件"></a>编写好的文件</h2><ol>
<li>main 函数中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;keyscan.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化LED灯</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;        <span class="comment">//亮黑灯,相当于把所有灯关上</span></span><br><span class="line">	</span><br><span class="line">	KEY1_GPIO_Config();                     <span class="comment">//初始化按键1</span></span><br><span class="line">	KEY2_GPIO_Config();                     <span class="comment">//初始化按键2</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(KEY_Scan( KEY1_PORT, KEY1_PIN) == KEY_ON) <span class="comment">//检测按键1是否按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			LED_G_TOGGLE; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(KEY_Scan( KEY2_PORT, KEY2_PIN) == KEY_ON)<span class="comment">//检测按键2是否按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			LED_B_TOGGLE; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bsp_key.h  文件中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//KEY1定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY2定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PIN  GPIO_Pin_13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PORT GPIOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_CLK  RCC_APB2Periph_GPIOC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ON  1 <span class="comment">//把按下宏定义为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_OFF 0 <span class="comment">//把未按下宏定义为0</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的声明</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY2_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*__BEP_KEY_H */</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>bsp_key.c 文件中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;keyscan.h&quot;</span></span></span><br><span class="line"><span class="comment">//按键1初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct; <span class="comment">//定义按键1对应的结构体</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_CLK, ENABLE); <span class="comment">//打开按键1对应的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//将模式设置为浮空输入模式</span></span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_PIN; <span class="comment">//设置按键1对应管脚</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_PORT, &amp;GPIO_KEY1_initstruct); <span class="comment">//调用初始化函数,穿入对应的端口中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按键2初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY2_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY2_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY2_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_KEY2_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_KEY2_initstruct.GPIO_Pin = KEY2_PIN; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY2_PORT, &amp;GPIO_KEY2_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span> <span class="comment">//按键检测函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON ) <span class="comment">//判断按键是否按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON);<span class="comment">//松手检测</span></span><br><span class="line">		<span class="keyword">return</span> KEY_ON;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> KEY_OFF;</span><br><span class="line">&#125;+-</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="GPIO的输入与输出"><a href="#GPIO的输入与输出" class="headerlink" title="GPIO的输入与输出"></a>GPIO的输入与输出</h1><h2 id="类比51-总线操作和位操作"><a href="#类比51-总线操作和位操作" class="headerlink" title="类比51 总线操作和位操作"></a>类比51 总线操作和位操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在51单片机中,让LED1输出低电平有两个操作</span><br><span class="line">P0=0xFE; //这是总线操作,直接操作P0端口</span><br><span class="line">P0^0=0;  //这是位操作,控制LED1对应的端口</span><br></pre></td></tr></table></figure>

<p>在STM32中 <code>GPIOB-&gt;ODR $= (0&lt;&lt;0) </code> 就类似于51单片机中的总线操作</p>
<p>51单片机中通过关键字sbit来实现位定义， STM32没有这样的关键字，而是通过访问位带别名区来实现.</p>
<h2 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h2><p>STM32中，有两个位置可以实现此操作，分别是部分片上外设和部分片上SRAM.</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIObi002.png" alt="STM32位带示意图"></p>
<ol>
<li>外设外带区的地址为：0X40000000~0X40100000，大小为1MB</li>
</ol>
<p>这1MB的大小在103系列大/中/小容量型号的单片机中包含了片上外设的全部寄存器， </p>
<p>这些寄存器的地址为：0X40000000-0X40029FFF。</p>
<p>外设位带区经过膨胀后的位带别名区地址为：0X42000000-0X43FFFFFF， </p>
<p>这个地址仍然在CM3 片上外设的地址空间中</p>
<ol start="2">
<li>SRAM的位带区的地址为：0X2000 0000<del>X2010 0000，大小为1MB，经过膨胀后的位带别名区地址为：0X2200 0000</del>0X23FF FFFF， 大小为32MB。这个位操作用得比较少</li>
</ol>
<h2 id="位带地区和外设别名取的转换："><a href="#位带地区和外设别名取的转换：" class="headerlink" title="位带地区和外设别名取的转换："></a>位带地区和外设别名取的转换：</h2><p>关键：1个位膨胀成32个位</p>
<h4 id="外设位带别名区地址"><a href="#外设位带别名区地址" class="headerlink" title="外设位带别名区地址"></a>外设位带别名区地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x42000000</span>+ (A<span class="number">-0x40000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>0X42000000是外设位带别名区的起始地址，0x40000000是外设位带区的起始地址，（A-0x40000000）表示该比特前面有多少个字节， 一个字节有8位，所以<em>8，一个位膨胀后是4个字节，所以</em>4，n表示该比特在A地址的序号，因为一个位经过膨胀后是四个字节，所以也*4。</p>
<h4 id="SRAM位带别名区地址"><a href="#SRAM位带别名区地址" class="headerlink" title="SRAM位带别名区地址"></a>SRAM位带别名区地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x22000000</span>+ (A<span class="number">-0x20000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>统一公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把“位带地址+位序号”转换成别名地址的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x00FFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>

<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><p>LED的电亮</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置好环境后,即时钟打开,模式调整好后</span></span><br><span class="line"><span class="comment">//只需要将最后一步,点灯改为位操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR (GPIO_BASE + 0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBout(n) ((GPIOB_ODR &amp; 0xF0000000)+0x02000000+(( GPIOB_ODR &amp; 0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class="line"></span><br><span class="line">PBout(<span class="number">0</span>)=<span class="number">0</span>; <span class="comment">//开灯</span></span><br><span class="line">PBout(<span class="number">0</span>)=<span class="number">1</span>; <span class="comment">//关灯</span></span><br><span class="line"><span class="comment">//这里是绿灯,改为其他灯只需改成其他灯的初始化文件,如何将n改为1-&gt;蓝灯,n=5-&gt;红灯</span></span><br></pre></td></tr></table></figure>

<p>KEY 的检测</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置好环境后,即时钟打开,模式调整好后</span></span><br><span class="line"><span class="comment">//只需要将最后一步,检测改为位操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR (GPIOA_BASE + 0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAin(n) ((GPIOA_IDR &amp; 0xF0000000)+0x02000000+(( GPIOA_IDR &amp; 0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PAin(n) == KEY_ON)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(PAin(n) == KEY_ON);</span><br><span class="line">	LED_G_TEDDLE;<span class="comment">//此处写控制灯的电位发生反转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="启动文件-了解"><a href="#启动文件-了解" class="headerlink" title="启动文件(了解)"></a>启动文件(了解)</h1><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer01.png" alt="详细说明见表"></p>
<p>此处以最常用的hd为例,讲解启动文件</p>
<p>参考资料 中文手册 第九章, 开发手册(英文)</p>
<p>启动文件是上电之后第一个执行的文件</p>
<h2 id="启动文件的作用"><a href="#启动文件的作用" class="headerlink" title="启动文件的作用"></a>启动文件的作用</h2><ol>
<li>初始化堆栈指针()</li>
<li>设置PC指针(程序每执行一步,PC指针加一)</li>
</ol>
<p>让PC指针 = Reset handler</p>
<ol start="3">
<li>初始化中断向量表</li>
<li>配置系统时钟</li>
<li>调用C库函数_main,最终到C的世界</li>
</ol>
<h2 id="启动文件的内容"><a href="#启动文件的内容" class="headerlink" title="启动文件的内容"></a>启动文件的内容</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu01.png" alt="启动文件使用的ARM汇编指令汇总"></p>
<ol>
<li>配置栈 - 放变量(局部变量) 函数调用的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400                         ;1k</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3 ;分配1KB空间 不初始化 可读可写 8字节对齐 </span><br><span class="line">Stack_Mem       SPACE   Stack_Size                        </span><br><span class="line">__initial_sp    ;紧跟着SPCE语句,表示出栈</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置堆 - 主要用于动态内存的分配, malloc()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap_Size     EQU     0x00000200 ;512Byte</span><br><span class="line"></span><br><span class="line">            AREA    HEAP, NOINIT, READWRITE, ALIGN=3 </span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem      SPACE   Heap_Size ;分配空间</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">PRESERVE 8 ;表示当前堆栈以8字节对齐</span><br><span class="line">TUHUMB     ;兼容老版本?</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化中断向量表</li>
</ol>
<p>当内核响应了一个发生的异常,对应的异常服务例程(ESR)执行. 根据每个向量(数字)对应一个异常,每个向量表对应一个地址,通过这个地址来访问中断服务程序.</p>
<p>数字越小,中断优先级越高</p>
<p>灰色代表内核,白色代表外设</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu02.png" alt="F103向量表"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA    RESET, DATA, READONLY</span><br><span class="line">EXPORT  __Vectors       ; </span><br><span class="line">EXPORT  __Vectors_End  </span><br><span class="line">EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">; 函数名对应的就是地址</span><br><span class="line">__Vectors  DCD   __initial_sp        ;栈顶地址</span><br><span class="line">        DCD   Reset_Handler       ;复位程序地址</span><br><span class="line">        DCD   NMI_Handler         ;不可屏蔽中断 和上面的表一致</span><br><span class="line">        DCD   HardFault_Handler</span><br><span class="line">        DCD   MemManage_Handler</span><br><span class="line">        DCD   BusFault_Handler</span><br><span class="line">        DCD   UsageFault_Handler</span><br><span class="line">        DCD   0                    ; 0 表示保留</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   SVC_Handler</span><br><span class="line">        DCD   DebugMon_Handler</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   PendSV_Handler</span><br><span class="line">        DCD   SysTick_Handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;外部中断开始</span><br><span class="line">        DCD   WWDG_IRQHandler</span><br><span class="line">        DCD   PVD_IRQHandler</span><br><span class="line">        DCD   TAMPER_IRQHandler</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">        DCD   DMA2_Channel2_IRQHandler</span><br><span class="line">        DCD   DMA2_Channel3_IRQHandler</span><br><span class="line">        DCD   DMA2_Channel4_5_IRQHandler</span><br><span class="line">__Vectors_End</span><br><span class="line">__Vectors_Size EQU __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>复位程序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA |.text|, CODE, READONLY</span><br></pre></td></tr></table></figure>

<p>定义一个名称为.text的代码段，可读。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reset_Handler PROC ;定义子程序</span><br><span class="line">            EXPORT  Reset_Handler    [WEAK] ;弱定义, 这个可以由C语言实现,如果用户没定义</span><br><span class="line">            IMPORT  SystemInit       ;插入 相对于C中的extern </span><br><span class="line">            IMPORT  __main           ;插入 C库函数- 初始化堆栈 最终调用我们写的main函数 实现从汇编到C语言的世界</span><br><span class="line"></span><br><span class="line">            LDR     R0, =SystemInit  ;系统时钟配置函数,用户配置</span><br><span class="line">            BLX     R0               ;BX执行完返回</span><br><span class="line">            LDR     R0, =__main</span><br><span class="line">            BX      R0               ;BX执行完不用返回</span><br><span class="line">            ENDP    ;结束子程序,于PROC一起使用</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu03.png" alt="CM4内核的指令"></p>
<ol start="5">
<li>中断服务函数</li>
</ol>
<p>都是可以自己修改的,因为是[weak]弱定义,如果我们自己写了会执行我们自己写的,如果没有的写的话就会执行汇编语言自己写的,这里注意 如果我们自己写的话 函数名一定要写对!!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NMI_Handler     PROC    ;系统异常</span><br><span class="line">                EXPORT  NMI_Handler           [WEAK]</span><br><span class="line">                B       .  ;这个表示可以无限循环,可以被其他函数调用 这函数可以在C语言中实现</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler       [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC    ;外部中断</span><br><span class="line">                EXPORT  WWDG_IRQHandler       [WEAK]</span><br><span class="line">                EXPORT  PVD_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  TAMP_STAMP_IRQHandler [WEAK]</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">LTDC_IRQHandler</span><br><span class="line">LTDC_ER_IRQHandler</span><br><span class="line">DMA2D_IRQHandler</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>堆栈的初始化</li>
</ol>
<p>程序的开头我们分配了堆和栈的大小,以及起始地址和结束地址</p>
<p>这里是用C语言来实现初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ALIGN</span><br><span class="line"></span><br><span class="line">ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示4字节对齐。</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;用户栈和堆初始化,由C库函数_main来完成</span><br><span class="line">IF      :DEF:__MICROLIB  ;这个宏在KEIL里面开启,开发环境ide;TARGET-MICROLIB 这个勾勾上</span><br><span class="line"></span><br><span class="line">EXPORT  __initial_sp ;知道栈和堆的地址</span><br><span class="line">EXPORT  __heap_base </span><br><span class="line">EXPORT  __heap_limit</span><br><span class="line"> </span><br><span class="line">ELSE ;如果</span><br><span class="line"></span><br><span class="line">IMPORT  __use_two_region_memory  ; 这个函数由用户自己实现</span><br><span class="line">EXPORT  __user_initial_stackheap </span><br><span class="line"></span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">LDR     R0, =  Heap_Mem                   ;这是CPU的暂存寄存器,CPU执行程序用的</span><br><span class="line">LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">LDR     R3, = Stack_Mem</span><br><span class="line">BX      LR</span><br><span class="line"></span><br><span class="line">ALIGN</span><br><span class="line"></span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>分配栈,堆的空间</p>
</li>
<li><p>中断向量表 </p>
</li>
<li><p>复位程序- 系统上电执行的第一个程序</p>
</li>
<li><p>中断服务程序,防止用户中断服务程序编写错误,进入无限循环</p>
</li>
<li><p>用户堆和栈的初始化</p>
</li>
<li><p>最后就进入到c的世界                    </p>
</li>
</ul>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电赛准备</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Markdown+ Typora</title>
    <url>/2022/12/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown-Typora/</url>
    <content><![CDATA[<h1 id="如何使用Markdown-Typora"><a href="#如何使用Markdown-Typora" class="headerlink" title="如何使用Markdown+ Typora"></a>如何使用Markdown+ Typora</h1><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以 <code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 $\LaTeX$, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势. </p>
<p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 <strong>Markdown</strong> 语法. 如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).</p>
<hr>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p>
<p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰, 层次分明.</p>
<p>用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告, 代码的 <code>README.md</code> … 包括本教程文档.</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Markdown 只是一种语法. </p>
<p>那么用来写 Markdown 文本编辑器: <strong>Typora</strong> , <strong>VS Code</strong></p>
<p>本文是用typora来写的.链接的地址是我朋友给的不知道为什么不收钱哈哈哈</p>
<h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown 语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将 <code>.md</code> 导出成多种文件, 如 <code>.pdf</code>, <code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p>
<h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VS Code 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All in One</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载 Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>大部分IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法, 在此不多赘述.</p>
<p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora 所包含的扩展语法.</p>
<hr>
<h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p>当有多种标记方法时我会倾向其中一种. </p>
<p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code <strong>本地生效</strong>, 在大多数平台上<strong>并不认可</strong>.</p>
<h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 <code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的, 也是无法转义的. </p>
<p>所以写 Markdown 的时候都用半角标点, 即英文标点, 如 <code>,.?!()[]:;&quot;&quot;</code>. 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.</p>
<p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> + <code>.(这是个句号)</code>, 切换标点的全角与半角. 这样即可中文输入+半角标点.</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>[数个 “#” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>标题会在目录与大纲分级显示, 可以跳转. </p>
<p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为 <code>#标题</code>, 应为 <code># 标题</code>. </p>
<p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容. </p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>[用 “**” 或 “__” 包围]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**欢迎报考海南大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考海南大学!__</span><br></pre></td></tr></table></figure>

<p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>. </p>
<p>例子:</p>
<p>欢迎报考海南大学! </p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>[用 “*” 或 “_” 包围]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*老师菜菜捞捞* (我喜欢用这种)</span><br><span class="line">_老师菜菜捞捞_</span><br></pre></td></tr></table></figure>

<p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>. </p>
<p>例子:</p>
<p><em>老师菜菜捞捞</em></p>
<p>(P.S. <em><strong>斜体并强调</strong></em> [用 “***” 或 “___” 包围])</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>[用 “~~” 包围]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~牛~~</span><br></pre></td></tr></table></figure>

<p>E.G. </p>
<p><del>牛</del></p>
<h3 id="高亮"><a href="#高亮" class="headerlink" title="*高亮"></a>*高亮</h3><p>[用 “==” 包围]</p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==牛==</span><br></pre></td></tr></table></figure>

<p>E.G.</p>
<p>==牛== </p>
<p>???为什么这里无高亮????</p>
<p>我不理解</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>[用 “`” 包围]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`print(hello world);`</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<p><code>print(hello world);</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>[按三个 “`” 并敲回车]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">​``` //这里先敲三个`</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int mian() </span><br><span class="line">&#123;</span><br><span class="line">    printf（“Hello, world!\n&quot;）;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 这里就可以开始输入你要的代码了</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> //在右下角可以选择语言</span></span><br></pre></td></tr></table></figure>

<p><code>或者用这样c </code></p>
<p> // (这三个”`”文本编辑器会帮你自动补全 一般不用手动输)</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[“&gt;” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引用是可以嵌套的!</span><br><span class="line"></span><br><span class="line">&gt; 我是个小孩</span><br><span class="line">&gt; &gt; 我才18岁</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<blockquote>
<p>我是个小孩</p>
<blockquote>
<p>我才18岁</p>
</blockquote>
</blockquote>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>[“-“ 或  “+” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 明天回家了 (我喜欢用这种)</span><br><span class="line"></span><br><span class="line">+ 坐飞机回家</span><br><span class="line"></span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br><span class="line"></span><br><span class="line">三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 `Tab` 会缩进一级. </span><br></pre></td></tr></table></figure>
<p>例子:</p>
<ul>
<li>明天回家了 (我喜欢用这种)</li>
</ul>
<ul>
<li>坐飞机回家</li>
</ul>
<ul>
<li>(其实这种也可以, 不过由于在 Typora 中很难单个输入,就是懒!!!!!)</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>[数字 + “.” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">敲回车会自动补全, 敲回车后按下 `Tab` 会缩进一级.在 数字＋. 后按下回车会取消空格</span><br><span class="line">1. 第一点</span><br><span class="line">2. 第二点</span><br><span class="line">3. 这是第三点</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<ol>
<li>第一点</li>
<li>第二点</li>
<li>这是第三点</li>
</ol>
<h3 id="上标"><a href="#上标" class="headerlink" title="*上标"></a>*上标</h3><p>[用 “^” 包围]</p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C语言中 `int` 的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure>
<p>好尴尬啊为什么没有? 难道是我的设置问题???</p>
<p>C语言中 <code>int</code> 的上限是 2^31^ - 1 = 2147483647</p>
<h3 id="下标"><a href="#下标" class="headerlink" title="*下标"></a>*下标</h3><p><strong>[用 “~” 包围]</strong></p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E.G. </span><br><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure>
<p>H<del>2</del>O 是剧毒的!</p>
<p>???这里我也显示不出来? 我明明点了扩展语法了!!!!</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="*注释"></a>*注释</h3><p><strong>[“[^]” 后置]</strong></p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要在文末写上注释对应的内容</span><br><span class="line">&gt; 今天你到这,是为了学习 Markdown 的使用, 它的教程对于你而言, 值得金钱的支持鼓励!![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure>
<p>[今天你到这,是为了学习 Markdown 的使用, 它的教程对于你而言, 值得金钱的支持鼓励![^1]</p>
<p>[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>[常用 “[ ]” + “( )” 分别包围文本与链接]</strong></p>
<p><strong>(注意: 文内跳转为扩展用法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">支持网页链接与文内跳转, 按住 `Ctrl` 并 `单击鼠标左键` 即可跳转.</span><br><span class="line"></span><br><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sugarchen7)</span><br><span class="line"></span><br><span class="line">[基础教程: 12. 下标](#12. *下标 )</span><br><span class="line"></span><br><span class="line">只需要在#后面加上该行的内容即可</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Sugarchen7">来看看我贫瘠的仓库罢</a></p>
<p>[基础教程: 12. 下标](#12. *下标 )</p>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p> <strong>[“- [ ]” + 空格 前置]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用 `x` 代替 `[ ]` 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.</span><br><span class="line">这个功能对喜欢写todolist的人比如我!很好!!!!</span><br><span class="line"></span><br><span class="line">TodoList:</span><br><span class="line"></span><br><span class="line">- [ ] 吃饭</span><br><span class="line">- [ ] 上厕所</span><br><span class="line">- [x] 早起</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<p>TodoList:</p>
<ul>
<li><input disabled="" type="checkbox"> 吃饭</li>
<li><input disabled="" type="checkbox"> 上厕所</li>
<li><input checked="" disabled="" type="checkbox"> 早起</li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p> <strong>[用 “|” 绘制表格边框]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据</span><br><span class="line">可以直接右键插入表格,十分方便,也可以手敲!和latex有点类似.</span><br><span class="line"></span><br><span class="line">| 学号 | 姓名 | 年龄 |</span><br><span class="line">| :--: | :--- | ---: |</span><br><span class="line">|  1   | 小陈 |   18 |</span><br><span class="line">|  2   | 老陈 |   30 |</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="left">姓名</th>
<th align="right">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">小陈</td>
<td align="right">18</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">老陈</td>
<td align="right">30</td>
</tr>
</tbody></table>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p> <strong>[直接拖进来或者复制粘贴]</strong></p>
<p>注意偏好设置,不然别人不好观看!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">或者会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式. </span><br><span class="line">![](图片的位置)</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<p><img src="E:\markdown\图像.png" alt="图像该如何设置"></p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p><strong>[按三个 “*” 或 “-“ 或 “_” 并敲回车]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">由于 `*` 与 `_` 均会自动补全, 所以我觉得 `-` 最为方便.</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">___</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<p>效果就是上面所示啦</p>
<h3 id="😁Emoji表情"><a href="#😁Emoji表情" class="headerlink" title="😁Emoji表情"></a>😁Emoji表情</h3><h4 id="“-”-前置"><a href="#“-”-前置" class="headerlink" title="[“:” 前置]"></a>[“:” 前置]</h4><p><strong>(注意: 英文输入为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji 的英文名. </span><br><span class="line"></span><br><span class="line">当然 window用户可以 win+. 直接打开emo库插入</span><br><span class="line"></span><br><span class="line">:sweat_smile: </span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line"></span><br><span class="line">对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里分享一个可以复制[全Emoji的网站](https://emojipedia.org/apple/)</span><br></pre></td></tr></table></figure>
<p>这里分享一个可以复制<a href="https://emojipedia.org/apple/">全Emoji的网站</a></p>
<p>E.G. </p>
<p>😅🤤🤡</p>
<hr>
<h2 id="进阶教程"><a href="#进阶教程" class="headerlink" title="进阶教程"></a>进阶教程</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><strong>[自动生成]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br><span class="line"></span><br><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure>
<h3 id="内联-HTML-代码"><a href="#内联-HTML-代码" class="headerlink" title="内联 HTML 代码"></a>内联 HTML 代码</h3><p> [用 “&lt;&gt; &lt;/&gt;” 包围] 可以用一些快捷键</p>
<div style="text-align:center">
  <font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font>
</div>


<center>简单的文字居中也可以这样</center>

<p><u>我差点忘了还有下划线这东西…</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">只要你会写, 你完全可以把 Markdown 当作 **HTML** 来写.</span><br><span class="line"></span><br><span class="line">同时, `.md` 文件可以直接导出成一个网页.</span><br><span class="line"></span><br><span class="line">下划线可以选中想要下划的文字按下 `Ctrl` + `U`. </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>E.G. </p>
<div style="text-align:center">
  <font style="color:red">我不会 HTML 呜呜呜...</font>
</div>



<center>简单的文字居中也可以这样</center>

<p><u>我差点忘了还有下划线这东西…</u></p>
<h3 id="Typora-的常用快捷键"><a href="#Typora-的常用快捷键" class="headerlink" title="*Typora 的常用快捷键"></a>*Typora 的常用快捷键</h3><table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">效果</th>
<th align="center">按键</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Ctrl</code> + <code>D</code></td>
<td align="center">选中当前词</td>
<td align="center"><code>Ctrl</code> + <code>L</code></td>
<td align="center">选中当前句/行</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>E</code></td>
<td align="center">选中当前区块</td>
<td align="center"><code>Ctrl</code> + <code>F</code></td>
<td align="center">搜索当前选中</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>B</code></td>
<td align="center">加粗当前选中</td>
<td align="center"><code>Ctrl</code> + <code>H</code></td>
<td align="center">替换当前选中</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>I</code></td>
<td align="center">倾斜当前选中</td>
<td align="center"><code>Ctrl</code> + <code>U</code></td>
<td align="center">下划当前选中</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>K</code></td>
<td align="center">将当前选中生成链接</td>
<td align="center"><code>Ctrl</code> + <code>J</code></td>
<td align="center">滚动屏幕将选中滚至顶部</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>W</code></td>
<td align="center">关闭当前窗口</td>
<td align="center"><code>Ctrl</code> + <code>N</code></td>
<td align="center">打开新窗口</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>O</code></td>
<td align="center">打开文件</td>
<td align="center"><code>Ctrl</code> + <code>P</code></td>
<td align="center">搜索文件并打开</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>回车</code></td>
<td align="center">表格下方插入行</td>
<td align="center"><code>Ctrl</code> + <code>,</code></td>
<td align="center">打开偏好设置</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>.</code></td>
<td align="center">切换全角/半角标点</td>
<td align="center"><code>Ctrl</code> + <code>/</code></td>
<td align="center">切换正常/源代码视图</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td>
<td align="center">缩小视图缩放</td>
<td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td>
<td align="center">放大视图缩放</td>
</tr>
</tbody></table>
<h3 id="Typora-的主题样式与检查元素"><a href="#Typora-的主题样式与检查元素" class="headerlink" title="*Typora 的主题样式与检查元素"></a>*Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故Typora的主题样式本质就是 CSS 文件.</p>
<p>可以下载各种好看的主题给 Typora换上, 同时也可以自己调整对应的 CSS 文件, 或者自己手搓. </p>
<p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开 <code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML 来编辑.</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此, <strong>Markdown + Typora / VSCode</strong> 的手册教程也告一段落. </p>
<p>不知你看完这么长的教程/手册, 是否能体会到 Markdown 的精妙简洁之处呢? </p>
<p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown 之后对于理解 HTML 也有帮助, 对于用 $\LaTeX$ 来写论文也有帮助. 标记语言正是为了摆脱 Word 那种虽然”所见即所得”, 但又过于花哨浮华, 很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的”所写即所得”时, 你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p>
]]></content>
      <tags>
        <tag>Tyraro</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2022/12/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="这是我的第一篇博客-2022-12-18"><a href="#这是我的第一篇博客-2022-12-18" class="headerlink" title="这是我的第一篇博客 2022-12-18"></a>这是我的第一篇博客 2022-12-18</h1><h2 id="我创建博客的初衷"><a href="#我创建博客的初衷" class="headerlink" title="我创建博客的初衷"></a><strong>我创建博客的初衷</strong></h2><p>​    markdown的写电子笔记来加深自己对于学习各门课程的建议。建立起自己的知识清单。</p>
<h2 id="第二点是为了记录走过的坑"><a href="#第二点是为了记录走过的坑" class="headerlink" title="第二点是为了记录走过的坑"></a><strong>第二点是为了记录走过的坑</strong></h2><p>​    是作为一个电子的学生，学习很多东西都会才不少坑，我会通过博客的形式记录下来。让自己更加生科认识到自己犯的错误！如果有人犯了和我一样的错误时，也可以通过博客的形式找到解决方法。</p>
<h2 id="第三点是提高自己的写作水平，结交认识的朋友"><a href="#第三点是提高自己的写作水平，结交认识的朋友" class="headerlink" title="第三点是提高自己的写作水平，结交认识的朋友"></a><strong>第三点是提高自己的写作水平，结交认识的朋友</strong></h2><p>​    把自己学会的东西写下来，让别人能够看懂，然后做出同样的结果。才是真正的学会了。    </p>
<p>​    一个人可以走多远关键在于与谁同行。希望在网上学习的过程中可以碰到很多志同道合的朋友一起学习。这一直是我所期盼的。</p>
<h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a><strong>寄语</strong></h2><p>​    我是一位纯小白，可能有地方会出现问题，还希望大家发现之后多多指正。也希望大家可以给我指出一些建议，让我的博客做得更好！</p>
]]></content>
  </entry>
  <entry>
    <title>网站搭建以及优化改造</title>
    <url>/2022/12/17/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E5%B9%B6%E4%BB%A5Next%E4%B8%BB%E9%A2%98%E4%B8%BA%E4%BE%8B%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E6%94%B9%E9%80%A0/</url>
    <content><![CDATA[<h1 id="为什么我想搭建一个博客"><a href="#为什么我想搭建一个博客" class="headerlink" title="为什么我想搭建一个博客"></a>为什么我想搭建一个博客</h1><p>这里可以看这个视频:<a href="%5B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2?%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%86%99?%E5%8D%9A%E5%AE%A2%E5%9C%A8%E9%9D%A2%E8%AF%95%E6%97%B6%E7%9A%84%E5%8A%A0%E5%88%86%E5%8F%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E7%82%B9%E7%82%B9,%E5%88%AB%E5%86%8D%E7%8A%B9%E8%B1%AB%E4%BA%86,%E5%BF%AB%E8%A1%8C%E5%8A%A8%E8%B5%B7%E6%9D%A5!_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Px411d74c/?spm_id_from=333.880.my_history.page.click&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">为什么程序员必须写技术博客?以及如何写?博客在面试时的加分可不是一点点,别再犹豫了,快行动起来!</a> 建议配套视频同步搭建博客</p>
<h1 id="如何用hexo搭建一个网站"><a href="#如何用hexo搭建一个网站" class="headerlink" title="如何用hexo搭建一个网站"></a>如何用hexo搭建一个网站</h1><h2 id="需要下载的工具"><a href="#需要下载的工具" class="headerlink" title="需要下载的工具"></a>需要下载的工具</h2><p>node：javascript运行环境</p>
<p>vscode：代码编辑器</p>
<p>git：版本控制工具</p>
<h2 id="hexo的安装"><a href="#hexo的安装" class="headerlink" title="hexo的安装"></a>hexo的安装</h2><p>按下 win+R，输入cmd，打开系统的终端，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org	#安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v	#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v	#查看hexo版本</span><br></pre></td></tr></table></figure>

<h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><p>按下 win+R，输入cmd，打开系统的终端，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir blog	#创建blog目录</span><br><span class="line">cd blog	 #进入blog目录</span><br><span class="line">hexo init 	#生成博客 初始化博客</span><br></pre></td></tr></table></figure>

<h4 id="预览博客"><a href="#预览博客" class="headerlink" title="预览博客"></a>预览博客</h4><p>在终端处输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>此时 可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 本地访问地址,这里面会生成一个默认的文章</p>
<h4 id="创建一篇新的文章"><a href="#创建一篇新的文章" class="headerlink" title="创建一篇新的文章"></a>创建一篇新的文章</h4><p>一般用终端 在blog目录下输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot; #创建新的文章 &quot;里面是文章名称&quot;</span><br></pre></td></tr></table></figure>

<h4 id="将blog远程部署到GitHub上"><a href="#将blog远程部署到GitHub上" class="headerlink" title="将blog远程部署到GitHub上"></a>将blog远程部署到GitHub上</h4><p>这样可以使别人在别人的电脑上就可以浏览你的博客</p>
<ul>
<li>创建一个GitHub账号</li>
<li>Github创建一个新的仓库: 此时的仓库名必须是:YourGithubName.github.io</li>
<li>按下 win+R，输入cmd，打开系统的终端，输入<code>cd blog</code>进入blog文件下</li>
<li>输入<code>cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</code></li>
<li>输入<code>_config.yml </code>#配置_config.yml ,一般使用记事本或者VSCODE打开 这里推荐VScode</li>
</ul>
<p>找到最后的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line"> 		type: git</span><br><span class="line">		repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line"> 		branch: main </span><br></pre></td></tr></table></figure>

<p>划重点!!!!!注意缩进 并且:后面有一个空格!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在部署博客前,win10用户注意!先输入</span><br><span class="line">git config --global user.email &quot;xxx&quot; #GitHub上的邮箱账号</span><br><span class="line">git config --global user.name &quot;xxx&quot;	#GitHub的名字</span><br><span class="line"># 然后再</span><br><span class="line">hexo d	#部署到Github仓库里</span><br><span class="line">https://YourGithubName.github.io/  #访问这个地址可以查看博客</span><br></pre></td></tr></table></figure>

<p>之后更改了_config.yml的内容,需要重新部署到远程,只需要执行下面的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c	#清理一下</span><br><span class="line">hexo g	#生成</span><br><span class="line">hexo d	#部署到远程Github仓库</span><br><span class="line">https://YourGithubName.github.io/  #查看博客</span><br></pre></td></tr></table></figure>

<p>一般部署成功后会收到一个邮件,然后等一会儿刷新就可以看到了!</p>
<hr>
<h1 id="如何美化博客"><a href="#如何美化博客" class="headerlink" title="如何美化博客"></a>如何美化博客</h1><ul>
<li>本文使用的美化主题是butterfly,真的很好看!狠狠地安利了!!!!</li>
</ul>
<p>安装教程直接看官方教程就行,还会实时更新!!!</p>
<p>这里是链接: <a href="https://butterfly.js.org/posts/21cfbf15/">官方教程</a></p>
<p>这里也有: <a href="%5B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E5%AD%A6(7)%7C%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1d64y1q7KS/?spm_id_from=333.788&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">配套视频</a></p>
<p><strong>真的很详细!!!</strong></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
