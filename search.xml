<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51单片机学习笔记</title>
    <url>/2022/12/22/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本文是<a href="%5B%E6%97%A0%E9%BC%A0%E6%A0%87%E5%A3%B0%E9%9F%B3__%E6%9C%80%E5%85%A8__%E9%83%AD%E5%A4%A9%E7%A5%A5%E5%8D%81%E5%A4%A9%E5%B8%A6%E4%BD%A0%E7%B2%BE%E9%80%9A51%E5%8D%95%E7%89%87%E6%9C%BA__%E5%B8%A6%E6%A0%87%E9%A2%98__%E5%B8%A6%E7%BD%91%E7%9B%98%E8%B5%84%E6%96%99_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1DW411a7mz/?spm_id_from=333.337.search-card.all.click&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">郭天祥老师的课堂</a>笔记</p>
<h1 id="预备知识：C51的基本语法"><a href="#预备知识：C51的基本语法" class="headerlink" title="预备知识：C51的基本语法"></a>预备知识：C51的基本语法</h1><h2 id="变量类型的大小"><a href="#变量类型的大小" class="headerlink" title="变量类型的大小"></a>变量类型的大小</h2><table>
<thead>
<tr>
<th align="center">变量类型</th>
<th align="center">位数</th>
<th align="center">范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">16</td>
<td align="center">$2^{-15} - 2^{15}-1$</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">32</td>
<td align="center">$2^{-31} - 2^{31}-1$</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">8</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">doubt</td>
<td align="center">64</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">16</td>
<td align="center">$0-2^{16}-1$</td>
</tr>
<tr>
<td align="center">unsigned char</td>
<td align="center">8</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">unsigned long</td>
<td align="center">32</td>
<td align="center">$0-2^{32}-1$</td>
</tr>
</tbody></table>
<p>一般会使用 <code>typedef</code>改名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br></pre></td></tr></table></figure>

<h2 id="C51特有的类型"><a href="#C51特有的类型" class="headerlink" title="C51特有的类型"></a>C51特有的类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sfr		<span class="comment">//特殊功能寄存器声明 长度:8位	0-255</span></span><br><span class="line">sfr16	<span class="comment">//特殊功能寄存器声明 长度:16位	0-65535</span></span><br><span class="line">sbit	<span class="comment">//特殊功能位声明 长度:1位  这个用的比较多</span></span><br><span class="line">bit		<span class="comment">//位变量声明 长度:1位  </span></span><br></pre></td></tr></table></figure>

<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般使用以下两个头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="51单片机学习的重点"><a href="#51单片机学习的重点" class="headerlink" title="51单片机学习的重点"></a>51单片机学习的重点</h1><ul>
<li>51单片机能够运行的基本要求: 电源, 晶振(相当于人的心脏), 复位电路</li>
<li>如何控制输入输出的高低电平</li>
<li>定时器</li>
<li>中断</li>
<li>串口通信</li>
</ul>
<hr>
<h1 id="电亮一盏灯"><a href="#电亮一盏灯" class="headerlink" title="电亮一盏灯"></a>电亮一盏灯</h1><p>本文使用的软件是KEIL4, 端口烧录使用的是: PZ-ISP(不需要冷启动)</p>
<ul>
<li>首先观察开发板上第一个发光二极管的接口是P2^0</li>
<li>创建一个程序和 <code>.c</code>文件</li>
<li>在.<code>c</code>文件中编写代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span> <span class="comment">//定义51单片机的各个串口</span></span></span><br><span class="line">sbit D1=P2^<span class="number">0</span>;  \\把串口P2^<span class="number">0</span>赋值给D1</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	D1=0; //这里是低电平高效 让D1等于0的时候灯亮</span></span><br><span class="line">	P2=<span class="number">0xFE</span>;  <span class="comment">//也可以之间控制端口的值,控制第一个发光二极管亮</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="灯的闪烁和流水灯"><a href="#灯的闪烁和流水灯" class="headerlink" title="灯的闪烁和流水灯"></a>灯的闪烁和流水灯</h1><h2 id="延时函数的编写"><a href="#延时函数的编写" class="headerlink" title="延时函数的编写"></a>延时函数的编写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写延时函数注意不要超过变量的范围</span></span><br><span class="line"><span class="comment">//可以用二重函数编写</span></span><br><span class="line"><span class="comment">//编写后将晶振改为11.0592进行调试,一般不是很准确.</span></span><br></pre></td></tr></table></figure>

<p>灯的闪烁只需要，让灯亮如何延时一段时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">sbit D1=P2^<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		D1=<span class="number">0</span>;</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">		D1=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流水灯的编写"><a href="#流水灯的编写" class="headerlink" title="流水灯的编写"></a>流水灯的编写</h3><p>这里需要调用一个位变换函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line">a=_crol_(a,b)//让a左移b位</span><br></pre></td></tr></table></figure>

<p>流水灯编写如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 temp=<span class="number">0xfe</span>;</span><br><span class="line">	P2=temp;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp=_crol_(temp,<span class="number">1</span>);</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">		P2=temp;</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------</span><br><span class="line"><span class="comment">//不使用该函数的方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 t=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">		&#123;</span><br><span class="line">				P2=~(<span class="number">0x01</span>&lt;&lt;t);</span><br><span class="line">			delay(<span class="number">50000</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="蜂鸣器-的使用"><a href="#蜂鸣器-的使用" class="headerlink" title="蜂鸣器 的使用"></a>蜂鸣器 的使用</h1><p><strong>这里是无源蜂鸣器</strong></p>
<p>普中开发板上使用的蜂鸣器是无源蜂鸣器，属于压电式蜂鸣器类型。这里说的有源和无源，并不是指电源的意思，而是指蜂鸣器内部是否含有振荡电路，有源蜂鸣器内部自带振荡电路，只需提供电源即可发声，而无源蜂鸣器则需提供一 定频率的脉冲信号才能发声，频率大小通常在 1.5-5KHz 之间。</p>
<p>普中的板子使用了五线四项步进电机控制蜂鸣器,接在了P25上</p>
<p>让<strong>无源</strong>蜂鸣器响的操作如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是无源蜂鸣器的代码!</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u8;</span><br><span class="line">sbit beep=P2^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u16 t = <span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(t--)</span><br><span class="line">		&#123;</span><br><span class="line">			beep=!beep;</span><br><span class="line">			delay(<span class="number">100</span>);</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="51单片机各个引脚的功能"><a href="#51单片机各个引脚的功能" class="headerlink" title="51单片机各个引脚的功能"></a>51单片机各个引脚的功能</h1><ul>
<li>1-8: P1 端口</li>
<li>9：复位</li>
<li>10-17:P3端口（注意它有第二功能）见书本P16</li>
<li>18，19分别对应X1，X2，是晶振</li>
<li>20: Vss接电源</li>
<li>21-28: P2端口</li>
<li>29：PSEN: 一般不用</li>
<li>30：ALE: 会输出$1/6$的时针周期方波,接到示波器,识别单片机是否工作正常</li>
<li>31:</li>
<li>32-39: P0端口, 一般接入上拉电阻</li>
<li>40: VCC</li>
</ul>
<hr>
<h1 id="静态数码管的显示"><a href="#静态数码管的显示" class="headerlink" title="静态数码管的显示"></a>静态数码管的显示</h1><h2 id="数码管的显示"><a href="#数码管的显示" class="headerlink" title="数码管的显示"></a>数码管的显示</h2><p>数字8每一个位置放了一个发光二极管, 通过控制不同位置发光二极管的亮灭来显示不同的数字</p>
<p>数码管有两种接法</p>
<ol>
<li>共阴极接法:给高电平有效,即通过输入1来控制</li>
<li>共阳极接法:给低电平有效,即通过输入0来控制</li>
</ol>
<p>以共阴极接法为例不同数字的16进制编码如下所示</p>
<p>![数码管](51 单片机的学习/数码管.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d,</span><br><span class="line">0      1     2     3     4     5</span><br><span class="line">0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c,</span><br><span class="line">6       7     8     9     A    B</span><br><span class="line">0x39, 0x5e, 0x79, 0x71,  0x00,</span><br><span class="line">C       D     E     F    无显示</span><br></pre></td></tr></table></figure>

<h3 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可用此代码</span></span><br><span class="line">u8 code[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="静态显示"><a href="#静态显示" class="headerlink" title="静态显示"></a>静态显示</h2><ul>
<li>位选:控制哪个数码管亮</li>
<li>段选: 每个数码管abcdefg都相互连接起来, 控制亮什么</li>
</ul>
<p>普中开发板利用的是三八译码器</p>
<p>郭天祥视频教程使用是寄存器控制方法大同小异</p>
<p>本文中介绍锁存器的存储方式: 先给高电平,然后放入数据,再给低电平.完成输出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wela= ;<span class="comment">//位选端口</span></span><br><span class="line">dula= ;<span class="comment">//段选端口</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		wela=<span class="number">1</span>;</span><br><span class="line">		P0=   ;选择哪个灯亮</span><br><span class="line">		wela=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		dula=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择亮的数字</span></span><br><span class="line">		dula=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><ol>
<li>处理main函数的A时,发生了B</li>
<li>停止处理A,开始处理中断程序B</li>
<li>B处理完成后,接着继续处理A</li>
</ol>
<p>![中断](51 单片机的学习/中断.png)</p>
<p>![中断流程](51 单片机的学习/中断流程.png)</p>
<h2 id="中断允许寄存器-IE"><a href="#中断允许寄存器-IE" class="headerlink" title="中断允许寄存器 IE"></a>中断允许寄存器 IE</h2><p>MCS-51的CPU对中断源的开放或屏蔽,是由片内的中断允许寄存器E控制的。E的字节地址为A8H,可进行位寻址。<br>中断允许寄存器E对中断的开放和关闭实现两级控制。所谓两级控制,就是有一个总的开关中断控制位EA(E.7位),<strong>当EA=0时,所有的中断请求被屏蔽</strong>,CPU对任何中断请求都不接受;<strong>当EA= 1时,CPU开放中断,但五个中断源的中断请求是否允许,还要由企中的低5位所对应的5个中断请求允许控制位的状态来决定</strong>.<a href="%E9%83%AD%E5%A4%A9%E7%A5%A5%E6%95%99%E7%A8%8BP55">^1</a></p>
<p>AH8表示可以直接控制每个位的值</p>
<p>![中断允许控制位](51 单片机的学习/中断允许控制位.png)</p>
<h2 id="中断处理的优先级"><a href="#中断处理的优先级" class="headerlink" title="中断处理的优先级"></a>中断处理的优先级</h2><p>![中断处理的优先级](51 单片机的学习/中断处理的优先级.png)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这上面的优先级从高到低分别对应 0 1 2 3 4</span><br><span class="line">用于写中断服务程序中的interrupt ?  后面的数字</span><br></pre></td></tr></table></figure>

<h2 id="中断响应的条件"><a href="#中断响应的条件" class="headerlink" title="中断响应的条件"></a>中断响应的条件</h2><p>一个中断源的中断请求被响应,需满足以下条件:</p>
<ol>
<li>该中断源发出中断请求。</li>
<li>CPU开中断,即中断总允许位EA = 1。</li>
<li>申请中断的中断源的中断允许位=1,即该中断没有被屏蔽。</li>
<li>无同级或更高级中断正在被服务。</li>
</ol>
<h2 id="外部中断器功能的选择"><a href="#外部中断器功能的选择" class="headerlink" title="外部中断器功能的选择"></a>外部中断器功能的选择</h2><p>外部中断的触发有两种触发方式:电平触发方式和跳沿触发方式。</p>
<h3 id="电平触发方式-默认"><a href="#电平触发方式-默认" class="headerlink" title="电平触发方式(默认)"></a>电平触发方式(默认)</h3><p>若外部中断定义为电平触发方式,外部中断申请触发器的状态随着CPU在每个机器周期采样到的外部中断输入线的电平变化而变化,这能提高CPU对外部中断请求的响应速度。<strong>当外部中断源被设定为电平触发方式时,在中断服务程序返回之前,外部中断请求输人必须无效(即变为高电平),否则CPU返回主程序后会再次响应中断。</strong>所以电平触发方式适合于外部中断以低电平输人而且中断服务程序能清除外部中断请求源(即外部中断输入电平又变为高电平)的情况。</p>
<h3 id="跳沿触发方式"><a href="#跳沿触发方式" class="headerlink" title="跳沿触发方式"></a>跳沿触发方式</h3><p>外部中断若定义为跳沿触发方式,外部中断申请触发器能锁存外部中断输人线上的负跳变。即便是CPU暂时不能响应,中断申请标志也不会丢失。在这种方式里,如果相继连续两次采样，<strong>一个机器周期采样到外部中断输人为高，下一个机器周期采样为低,则置“1”中断申请触发器,直到CPU响应此中断时才清0。</strong>这样不会丢失中断,但输人的负脉冲宽度至少<strong>保持12个时钟周期</strong>(若晶振频率为6MHz,则为2pS),才能被CPU采样到。外部中断的跳沿触发方式适合于以负脉冲形式输入的外部中断请求。</p>
<h2 id="中断程序的编写"><a href="#中断程序的编写" class="headerlink" title="中断程序的编写"></a>中断程序的编写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">EA=<span class="number">1</span>; <span class="comment">//开启总中断</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//打开外部中断0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//主程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">extero</span><span class="params">()</span> interrupt 0</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//中断服务程序,无需声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="定时器的工作模式"><a href="#定时器的工作模式" class="headerlink" title="定时器的工作模式"></a>定时器的工作模式</h2><p>51单片机内有两个可编程的定时器/计数器T1、T0,。两个定时器/计数器都具有定时器和计数器两种工作模式.</p>
<ol>
<li><strong>定时工作模式</strong></li>
</ol>
<ul>
<li><p>定时功能也是通过计数器的计数来实现的,不过此时的计数脉冲来自单片机的内部,即每个机器周期产生一个计数脉冲,也就是每经过1个机器周期的时间,计数器加1。如果MCS -51采用12MHz晶体,则计数频率为1MHz,即每过1us的时间计数器加1。这样可以根据计数值计算出定时时间,也可根据定时时间的要求计算出计数器的初值。</p>
</li>
<li><p>MCS-51单片机的定时器/计数器具有4种工作方式(方式0、方式1、方式2和方式3),其控制字均在相应的特殊功能寄存器中,通过对特殊功能寄存器的编程,用户可方便地选择定时器/计数器两种工作模式和4种工作方式。</p>
</li>
</ul>
<ol start="2">
<li>计数工作模式</li>
</ol>
<ul>
<li>计数功能是对外来脉冲进行计数。MCS -51芯片有TD(P3.4)和TI(P3.5)两个输入引脚分别是这两个计数器的计数脉冲输入端。每当外部输人的脉冲发生负跳变时,计数器加1。</li>
</ul>
<h2 id="定时器的结构"><a href="#定时器的结构" class="headerlink" title="定时器的结构"></a>定时器的结构</h2><p> 51单片机的定时器/计数器结构.<strong>定时器/计数器TO</strong>由特殊功能寄存器**THO(高四位)、TLO(低四位)**构成,定时器/计数器T1由特殊功能寄存器TH1、TL1构成。</p>
<p>![定时器的结构](51 单片机的学习/定时器的结构.png)</p>
<p>特殊功能寄存器<strong>TMOD</strong>用于选择<strong>定时器/计数器TO、T1</strong>的工作模式和工作方式。</p>
<p>特殊功能寄存器<strong>TCON</strong>用于控制TO、T1的<strong>启动和停止计数</strong>,同时包含了TO、T1的状态。</p>
<p><strong>TMOD、TCON这两个寄存器的内容由软件设置</strong>。单片机复位时,两个寄存器的所有位都被清0。</p>
<h3 id="TMOD工作方式寄存器"><a href="#TMOD工作方式寄存器" class="headerlink" title="TMOD工作方式寄存器"></a>TMOD工作方式寄存器</h3><p>工作方式寄存器‘<strong>TMOD</strong>用于<strong>选择</strong>定时器/计数器的<strong>工作模式和工作方式</strong>,它的字节地址为89H,不能进行位寻址。TMOD一共有八位</p>
<p>前四位为M1,后四位为M2, 控制M1,M2的编码可以选择工作方式</p>
<table>
<thead>
<tr>
<th align="center">M1</th>
<th align="center">M0</th>
<th align="center">工作方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">方式0,为13位定时器/计数器</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center"><strong>方式1,为16位定时器/计数器</strong></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">方式2,8位初值自动重新装人的8位定时器/计数器</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">方式3,仅适用于T0,分成两个8位计数器，T1停止计数</td>
</tr>
</tbody></table>
<h3 id="定时器-计数器控制寄存器TCON"><a href="#定时器-计数器控制寄存器TCON" class="headerlink" title="定时器/计数器控制寄存器TCON"></a>定时器/计数器控制寄存器TCON</h3><p>TCON一共有八位</p>
<p>工作方式的不同,tocn的功能也就不同</p>
<p>TCOC是在不同方式下,</p>
<p>计数溢出标志位: 如果装满即功能位全都是1时,进入中断服务程序.</p>
<h2 id="定时器的工作方式"><a href="#定时器的工作方式" class="headerlink" title="定时器的工作方式"></a>定时器的工作方式</h2><p>四种见郭天祥老师教程的70页</p>
<ul>
<li>当前视频使用的是方式1</li>
</ul>
<p>TLO是低8位, THO是高8位</p>
<p> $X(计数个数)=2^{16}-N(计数初值)$</p>
<p>控制计数初值的大小,来控制定时的时间</p>
<p>t为时间</p>
<p>$THO=(2^{16}-t)/256$ ,即取前四位</p>
<p>$TLO=(2^{16}-t)$ % $256$ ,即取后四位</p>
<h2 id="定时器的使用步骤"><a href="#定时器的使用步骤" class="headerlink" title="定时器的使用步骤"></a>定时器的使用步骤</h2><p><strong>初始化程序应完成如下工作:</strong></p>
<ol>
<li><p>对TMOD赋值，以确定TO和T1的工作方式。</p>
</li>
<li><p>计算初值,并将其写入THO、TLO或TH1、TL1。</p>
</li>
<li><p>中断方式时，则对IE赋值，开放中断。</p>
</li>
<li><p>使TRO或TR1置位，启动定时/计数器定时或计数。</p>
</li>
</ol>
<p><strong>以方式1为例</strong>:</p>
<ol>
<li><p>对TMOD赋值: TMOD=0x01; 选择方式1 定时器0</p>
</li>
<li><p>计算THO和TLO: 控制定时器的时间 t=50000时候为50ms</p>
</li>
<li><p>开启中断: EA=1(开启总中断) ETO1=1(开启定时器0) 这里看优先级就知道是ETO</p>
</li>
<li><p>TRO=1 启动定时器0</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	tt=<span class="number">0</span>;</span><br><span class="line">    TOMD=<span class="number">0x01</span>;<span class="comment">//设置工作模式</span></span><br><span class="line">	THO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)/<span class="number">256</span>;</span><br><span class="line">    TLO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)%<span class="number">256</span>;</span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//开总断</span></span><br><span class="line">    ETO=<span class="number">1</span>;<span class="comment">//开定时器0中断</span></span><br><span class="line">    TRO=<span class="number">1</span>;<span class="comment">//启动定时器0 ,定时器加满进入一次中断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tt=?)<span class="comment">//进入中断的次数 即tt个50ms</span></span><br><span class="line">        &#123;</span><br><span class="line">            tt=<span class="number">0</span>; <span class="comment">//tt清零 方便下次进入</span></span><br><span class="line">            <span class="comment">//执行程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">exter0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">	tt++;</span><br><span class="line">    THO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)/<span class="number">256</span>;</span><br><span class="line">    TLO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)%<span class="number">256</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后续使用中可以增加一个初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>; <span class="comment">//初始化函数的声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    init(); <span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为里面的变量都是全局变量 以及在头文件中定义好了的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	tt=<span class="number">0</span>;</span><br><span class="line">    TOMD=<span class="number">0x01</span>;<span class="comment">//设置工作模式</span></span><br><span class="line">	THO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)/<span class="number">256</span>;</span><br><span class="line">    TLO=(<span class="number">2</span>^&#123;<span class="number">16</span>&#125;-t)%<span class="number">256</span>;</span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//开总断</span></span><br><span class="line">    ETO=<span class="number">1</span>;<span class="comment">//开定时器0中断</span></span><br><span class="line">    TRO=<span class="number">1</span>;<span class="comment">//启动定时器0 ,定时器加满进入一次中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里需要注意,中断函数和delay同时在主函数中时,可能会出现问题. 因为当中断到 <strong>tt=?</strong> 时,该程序可能还在delay函数中</p>
<hr>
<h1 id="动态显示"><a href="#动态显示" class="headerlink" title="动态显示"></a>动态显示</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li>位选:控制哪个数码管亮</li>
<li>段选: 每个数码管abcdefg都相互连接起来, 控制亮什么</li>
</ul>
<p>分别控制需要的数码管亮,利用位选</p>
<p>利用段选控制数码管里亮的内容</p>
<p>减少数码管亮的延时时间,当小于人眼可以分辨的快慢时.相当于同时显示了需要的数码管,以及里面的内容</p>
<h2 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h2><p>这里是普中芯片使用三八译码器的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Gs P0</span></span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>; <span class="comment">//普中芯片的三八译码器</span></span><br><span class="line"></span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//用swich语句控制位选,选择哪个灯亮,此处普中芯片使用了三八译码器</span></span><br><span class="line">		Gs=GS[i];</span><br><span class="line">		delay(<span class="number">100</span>);</span><br><span class="line">		Gs=<span class="number">0x00</span>; <span class="comment">//这句代码是消影的过程,就是显示完之后让段选为什么都不显示的状态. 防止下次位选后直接                    显示值.</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		smg_display(); <span class="comment">//动态显示的子函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是郭天祥老师视频中使用寄存器的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line">wela= ;<span class="comment">//位选端口</span></span><br><span class="line">dula= ;<span class="comment">//段选端口</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		wela=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择第一个灯亮</span></span><br><span class="line">		wela=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		dula=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择亮的数字</span></span><br><span class="line">		dula=<span class="number">0</span>;</span><br><span class="line">        p0=<span class="number">0xff</span>;<span class="comment">//这句代码是消影的过程,就是显示完之后让段选为什么都不显示的状态. 防止下次位选后直接                   显示值. 这里郭天祥老师视频中什么都不显示是0xff,之后试验中具体内容具体分析</span></span><br><span class="line">        </span><br><span class="line">        delay(<span class="number">100</span>); <span class="comment">//延时一小段时间</span></span><br><span class="line">        </span><br><span class="line">        wela=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择第二个灯亮</span></span><br><span class="line">		wela=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		dula=<span class="number">1</span>;</span><br><span class="line">		P0=   ;<span class="comment">//选择亮的数字</span></span><br><span class="line">		dula=<span class="number">0</span>;</span><br><span class="line">        delay(<span class="number">100</span>);</span><br><span class="line">        p0=<span class="number">0xff</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//后面需要加显示数码管 只需复制上面代码即可.</span></span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态消影"><a href="#动态消影" class="headerlink" title="动态消影"></a>动态消影</h3><p>在段选显示数字后,的延时函数后面,加一句代码让显示的值处于没有的状态. 防止下一次段选后直接显示上一次的内容.</p>
<hr>
<h1 id="独立键盘和矩阵键盘的检测原理及实现"><a href="#独立键盘和矩阵键盘的检测原理及实现" class="headerlink" title="独立键盘和矩阵键盘的检测原理及实现"></a>独立键盘和矩阵键盘的检测原理及实现</h1><h2 id="键盘的分类"><a href="#键盘的分类" class="headerlink" title="键盘的分类"></a>键盘的分类</h2><ul>
<li>编码键盘</li>
<li>非编码键盘: 分为独立键盘和矩阵键盘</li>
</ul>
<h2 id="独立键盘的检测原理"><a href="#独立键盘的检测原理" class="headerlink" title="独立键盘的检测原理"></a>独立键盘的检测原理</h2><p>独立键盘的原理图 如图所示</p>
<p>本文用的是普中开发板</p>
<p>![独立键盘的原理](51 单片机的学习/独立键盘的原理.png)</p>
<p>当有按键按下时 相应端口会收到一个0的信号</p>
<p>检测的代码如图所示(使用普中开发板)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按下灯亮</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit K1=P3^<span class="number">1</span>;</span><br><span class="line">sbit D1=P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	D1=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(K1==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		D1=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按下灯亮加计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line">sbit K1=P3^<span class="number">1</span>;</span><br><span class="line">sbit D1=P2^<span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Gs P0</span></span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line">u8 num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(K1==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">10</span>); <span class="comment">//消除振动的影响</span></span><br><span class="line">			<span class="keyword">if</span>(K1==<span class="number">0</span>) <span class="comment">//如果按下</span></span><br><span class="line">			&#123;</span><br><span class="line">				D1=<span class="number">0</span>;</span><br><span class="line">				num++;</span><br><span class="line">				<span class="keyword">if</span>(num==<span class="number">10</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					num=<span class="number">0</span>;</span><br><span class="line">				&#125;<span class="comment">//等价于 num=num%10;防止越界</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			D1=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(K1==<span class="number">0</span>); <span class="comment">//松手检测 松手了再加一</span></span><br><span class="line">		P0=GS[num];</span><br><span class="line">		delay(<span class="number">20000</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩阵键盘的检测原理"><a href="#矩阵键盘的检测原理" class="headerlink" title="矩阵键盘的检测原理"></a>矩阵键盘的检测原理</h2><p>矩阵键盘的原理图</p>
<p>![矩阵键盘原理图](51 单片机的学习/矩阵键盘原理图.png)</p>
<p>检测代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line">u8 temp,num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	num=<span class="number">17</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	 	P1=<span class="number">0x7f</span>;    <span class="comment">//第一行检测 先给第一行0,其他行 为1</span></span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>) <span class="comment">//检测第一行是否有按键按下去</span></span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1; <span class="comment">//防止抖动</span></span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">0</span>; <span class="comment">//第一个按键被按下去了,从原理图中可以看出</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">2</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">3</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第二行的检测</span></span><br><span class="line">	 	P1=<span class="number">0xbf</span>;</span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1;</span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">4</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">5</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">6</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">7</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第三行的检测</span></span><br><span class="line">	 	P1=<span class="number">0xdf</span>;</span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1;</span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">8</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">9</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">10</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">11</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">	 		<span class="comment">//第四行的检测</span></span><br><span class="line">	 	P1=<span class="number">0xef</span>;</span><br><span class="line">		temp=P1;</span><br><span class="line">		temp=temp&amp;<span class="number">0x0f</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			delay(<span class="number">20</span>);</span><br><span class="line">			temp=<span class="number">0x0f</span>;</span><br><span class="line">			temp=temp&amp;P1;</span><br><span class="line">			<span class="keyword">if</span>(temp!=<span class="number">0x0f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span>(temp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x07</span>: num=<span class="number">12</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0b</span>: num=<span class="number">13</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0d</span>: num=<span class="number">14</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="number">0x0e</span>: num=<span class="number">15</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		P0=GS[num];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这个主函数的内容写入子函数中,会出现一个,没有按下去时候不知道会显示什么东西的bug,<strong>还有待改进.</strong></p>
<hr>
<h1 id="AD-DA-的工作原理及其实现"><a href="#AD-DA-的工作原理及其实现" class="headerlink" title="AD,DA 的工作原理及其实现"></a>AD,DA 的工作原理及其实现</h1><p>AD DA ,D表示数字信号,A表示模拟信号</p>
<ul>
<li>DA即数字信号转换为模拟信号</li>
</ul>
<h2 id="T型电阻网络D-A转换器"><a href="#T型电阻网络D-A转换器" class="headerlink" title="T型电阻网络D/A转换器"></a>T型电阻网络D/A转换器</h2><p>![DA转换器](51 单片机的学习/DA转换器.png)</p>
<p>![1](51 单片机的学习/1.png)</p>
<p><strong>输出电压的大小与数据量有很大的关系</strong></p>
<h2 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h2><p>ADC（analog to digital converter）也称为模数转换器，是指一个将模拟信号转变为数字信号。单片机在采集模拟信号时，通常都需要在前端加上 A/D 芯片.下面我们看ADC的几个主要数据指标</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>ADC 的分辨率是指对于允许范围内的模拟信号，它能输出离散数字信号值的 个数。这些信号值通常用二进制数来存储，因此分辨率经常用比特作为单位，且 这些离散值的个数是 2 的幂指数。 例如：12 位 ADC 的分辨率就是 12 位，或者说分辨率为满刻度的 1/(2^12)。 一个 10V 满刻度的 12 位 ADC 能分辨输入电压变化最小值是</p>
<p>$10V×1/(2^{12})=2.4mV$</p>
<h3 id="转换误差"><a href="#转换误差" class="headerlink" title="转换误差"></a>转换误差</h3><p>转换误差通常是以输出误差的最大值形式给出。它表示 A/D 转换器实际输出 的数字量和理论上的输出数字量之间的差别。常用最低有效位的倍数表示。例如 给出相对误差≤±LSB/2，这就表明实际输出的数字量和理论上应得到的输出数 字量之间的误差小于最低位的半个字。</p>
<h3 id="转换速率"><a href="#转换速率" class="headerlink" title="转换速率"></a>转换速率</h3><p>ADC 的转换速率是能够重复进行数据转换的速度，即每秒转换的次数。而完 成一次 A/D 转换所需的时间（包括稳定时间），则是转换速率的倒数。</p>
<h3 id="串行和并行"><a href="#串行和并行" class="headerlink" title="串行和并行"></a>串行和并行</h3><ul>
<li>串行:先进行一个再进行另一个</li>
<li>并行:多个同时进行,但浪费IO口</li>
</ul>
<h3 id="DAC0832"><a href="#DAC0832" class="headerlink" title="DAC0832"></a>DAC0832</h3><ul>
<li>看一个芯片的资料我们可以去 <a href="www.21ic.com">网站</a> 查找他的相关资料</li>
<li>主要看</li>
</ul>
<ol>
<li>串行还是并行</li>
<li>接口的说明</li>
<li>转换位数和转换效率</li>
<li>操作时序</li>
</ol>
<h2 id="DAC0832-的使用"><a href="#DAC0832-的使用" class="headerlink" title="DAC0832 的使用"></a>DAC0832 的使用</h2><h3 id="DAC0832的电路图"><a href="#DAC0832的电路图" class="headerlink" title="DAC0832的电路图"></a>DAC0832的电路图</h3><p>![DA原理图](51 单片机的学习/DA原理图.png)</p>
<p>单片机通过控制D0到D7的0/1;来控死发光二极管的电流大小           </p>
<h2 id="XPT2046-芯片的使用"><a href="#XPT2046-芯片的使用" class="headerlink" title="XPT2046 芯片的使用"></a>XPT2046 芯片的使用</h2><p>因为手上的是普中的开发板，所以本文使用的是XPT2046来实现数模转换。</p>
<h3 id="XPT2046芯片管脚的说明"><a href="#XPT2046芯片管脚的说明" class="headerlink" title="XPT2046芯片管脚的说明"></a>XPT2046芯片管脚的说明</h3><p>![xpt2096](51 单片机的学习/xpt2096.png)</p>
<p>![xpt2096管脚说明](51 单片机的学习/xpt2096管脚说明.png)</p>
<h3 id="XPT2046-的输入配置"><a href="#XPT2046-的输入配置" class="headerlink" title="XPT2046 的输入配置"></a>XPT2046 的输入配置</h3><p>通过控制A2,A1,A0各个值来控制 接收哪一个引脚检测的的数值</p>
<p>![xpt2096输入配置](51 单片机的学习/xpt2096输入配置.png)</p>
<h3 id="XPT2046-控制位的命令"><a href="#XPT2046-控制位的命令" class="headerlink" title="XPT2046 控制位的命令"></a>XPT2046 控制位的命令</h3><p>![XPT制表位的命令](51 单片机的学习/XPT制表位的命令.png)</p>
<p>![2](51 单片机的学习/2.png)</p>
<h3 id="XPT2046的时序图"><a href="#XPT2046的时序图" class="headerlink" title="XPT2046的时序图"></a>XPT2046的时序图</h3><p>这是编程数模转换器的重点,通过看各个管脚的时序,来编程.</p>
<p>![](51 单片机的学习/xpt2096时序图.png)</p>
<h3 id="XPT2046的连接"><a href="#XPT2046的连接" class="headerlink" title="XPT2046的连接"></a>XPT2046的连接</h3><p>![xpt2046的连接](51 单片机的学习/xpt2046的连接.png)</p>
<h3 id="XPT2046的编程"><a href="#XPT2046的编程" class="headerlink" title="XPT2046的编程"></a>XPT2046的编程</h3><p>本文是将 XPT2046 的AIN0检测到的电压值,传输到单片机,并在数码管上显示出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrins.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">sbit CS=P3^<span class="number">5</span>;</span><br><span class="line">sbit DIN=P3^<span class="number">2</span>;</span><br><span class="line">sbit CLK=P3^<span class="number">6</span>;</span><br><span class="line">sbit DOUT=P3^<span class="number">7</span>;</span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 GS[]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(time--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">xpt2046_wirte_data</span><span class="params">(u8 cmd)</span> <span class="comment">//读取命令 控制XPT2046的模式</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	CLK=<span class="number">0</span>;</span><br><span class="line">	_nop_(); <span class="comment">//延时一微秒</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		DIN=cmd&gt;&gt;<span class="number">7</span>; <span class="comment">//先读取高位</span></span><br><span class="line">		cmd&lt;&lt;=<span class="number">1</span>;		<span class="comment">//将下一位设置为最高位</span></span><br><span class="line">		CLK=<span class="number">1</span>;		<span class="comment">//CLK 由低到高产生一个上升沿，从而写入数据</span></span><br><span class="line">		_nop_();</span><br><span class="line">		CLK=<span class="number">0</span>;</span><br><span class="line">		_nop_();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 <span class="title function_">xpt2046_read_data</span><span class="params">()</span> <span class="comment">//从XPT2046中读取数据</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	u8 i;</span><br><span class="line">	u16 dat=<span class="number">0</span>;</span><br><span class="line">	CLK = <span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		CLK=<span class="number">1</span>;		<span class="comment">//CLK 由低到高产生一个上升沿，从而写入数据</span></span><br><span class="line">		_nop_();</span><br><span class="line">		CLK=<span class="number">0</span>;</span><br><span class="line">		_nop_();</span><br><span class="line">		dat|= DOUT;<span class="comment">//先读取高位，再读取低位</span></span><br><span class="line">		dat&lt;&lt;=<span class="number">1</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 <span class="title function_">xpt2046_read_adc_value</span><span class="params">(u8 cmd)</span> <span class="comment">//在da模块读取到数据,函数整合</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u16 dat;</span><br><span class="line">	CS=<span class="number">0</span>;</span><br><span class="line">	CLK=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	xpt2046_wirte_data(cmd);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">6</span>;i&gt;<span class="number">0</span>;i--); <span class="comment">//延时一会等待命令结束</span></span><br><span class="line"></span><br><span class="line">	CLK = <span class="number">0</span>;</span><br><span class="line">	_nop_();</span><br><span class="line">	CLK = <span class="number">1</span>;<span class="comment">//发送一个时钟，清除 BUSY</span></span><br><span class="line">	_nop_();</span><br><span class="line"></span><br><span class="line">	dat=xpt2046_read_data(); <span class="comment">//读取数据</span></span><br><span class="line">	CS=<span class="number">1</span>; <span class="comment">//关闭</span></span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(u8 A[],u8 i)</span><span class="comment">//动态显示</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 pos = i;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:LSA=<span class="number">1</span>;LSB=<span class="number">1</span>;LSC=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//用swich语句控制位选,选择哪个灯亮,此处普中芯片使用了三八译码器</span></span><br><span class="line">		P0=A[i-pos];</span><br><span class="line">		delay(<span class="number">100</span>);</span><br><span class="line">		P0=<span class="number">0x00</span>; <span class="comment">//这句代码是消影的过程,就是显示完之后让段选为什么都不显示的状态. 防止下次位选后直接                    显示值.</span></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 cmd;</span><br><span class="line">	u16 dat;</span><br><span class="line">	<span class="type">float</span> dat_v;</span><br><span class="line">	u16 det_val;</span><br><span class="line">	u8 adc_buf[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	 	cmd=<span class="number">0x94</span>;	<span class="comment">//测量电位器</span></span><br><span class="line">		dat=xpt2046_read_adc_value(cmd);  </span><br><span class="line">		dat_v = dat*<span class="number">5.0</span>/<span class="number">4096</span>;  <span class="comment">//将读取的 AD 值转换成电压</span></span><br><span class="line">		det_val=dat_v*<span class="number">10</span>;	   <span class="comment">//读取前两位有效数字</span></span><br><span class="line">		adc_buf[<span class="number">0</span>]=	GS[det_val/<span class="number">10</span>]|<span class="number">0x80</span>; <span class="comment">//个位加上小数点</span></span><br><span class="line">		adc_buf[<span class="number">1</span>]=	GS[det_val%<span class="number">10</span>];		 <span class="comment">//小数点后一位</span></span><br><span class="line">		adc_buf[<span class="number">2</span>]=	<span class="number">0x3e</span>;				<span class="comment">//单位V</span></span><br><span class="line">		smg_display(adc_buf,<span class="number">5</span>);			<span class="comment">//动态显示</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="通信的分类"><a href="#通信的分类" class="headerlink" title="通信的分类"></a>通信的分类</h2><h3 id="串行通信与并行通信"><a href="#串行通信与并行通信" class="headerlink" title="串行通信与并行通信"></a>串行通信与并行通信</h3><ol>
<li>串行通信</li>
</ol>
<p>串行通信是指使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度.其只需要少数几条线就可以在系统间交换信息，特别适 用于计算机与计算机、计算机与外设之间的远距离通信.</p>
<p>特点: 传输线少，长距离传送时成本低，且可以利用电话网等现 成的设备，但数据的传送控制比并行通信复杂.</p>
<p>![img](51 单片机的学习/BSB]G}W5JNQ2}DPUXOT2L]H.png)</p>
<p>2.并行通信</p>
<p>并行通信通常是将数据字节的各位用多条数据线同时进行传送，通常是 8 位、16 位、32 位等数据一起传输。如下图所示：</p>
<p>并行通信的特点：控制简单、传输速度快；由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难，抗干扰能力差。</p>
<p>![image-20221222195204103](51 单片机的学习/image-20221222195204103.png)</p>
<h3 id="异步通信与同步通信"><a href="#异步通信与同步通信" class="headerlink" title="异步通信与同步通信"></a>异步通信与同步通信</h3><ol>
<li><strong>异步通信</strong>(比较常用)</li>
</ol>
<p>异步通信是指通信的发送与接收设备使用<strong>各自的时钟</strong>控制数据的发送和接收过程。为使双方的收发协调，要求发送和接收设备的时钟尽可能一致。</p>
<p>异步通信是以<strong>字符</strong>（构成的帧,8位）为单位进行传输，字符与字符之间<strong>的间隙（时间间隔）是任意的</strong>，但每个字符中的各位是以固定的时间传送的，即字符之间不 一定有“位间隔”的整数倍的关系，但同一字符内的各<strong>位之间的距离均为“ 位 间隔”的整数倍</strong>。如下图所示：</p>
<p>![image-20221222195408401](51 单片机的学习/image-20221222195408401.png)</p>
<p>一般启示位是0,即低电平; 终止位是1,即高电平.</p>
<p>终止位前有一个检验位,用于检验是否存在传输错误. 常用的有奇偶校验, 用的比较多的是代码和校验.</p>
<p>异步通信的特点：不要求收发双方时钟的严格一致，实现容易，设备开销较 小，但每个字符要附加 2～3 位用于起止位，各帧之间还有间隔，因此传输效率 不高。</p>
<ol start="2">
<li><strong>同步通信</strong></li>
</ol>
<p>同步通信时要建立发送方时钟对接收方时钟的直接控制，使双方达到完全同 步。此时，传输数据的位之间的距离均为“位间隔”的整数倍，同时传送的字符 间不留间隙，即保持位同步关系，也保持字符同步关系。发送方对接收方的同步 可以通过两种方法实现。</p>
<p>![image-20221222195716522](51 单片机的学习/image-20221222195716522.png)</p>
<h3 id="单工、半双工与全双工通信"><a href="#单工、半双工与全双工通信" class="headerlink" title="单工、半双工与全双工通信"></a>单工、半双工与全双工通信</h3><ol>
<li><strong>单工通信</strong></li>
</ol>
<p>单工是指数据传输仅能沿一个方向，不能实现反向传输。如下图所示：</p>
<p>![image-20221222195813958](51 单片机的学习/image-20221222195813958.png)</p>
<ol start="2">
<li><strong>半双工通信</strong></li>
</ol>
<p>半双工是指数据传输可以沿两个方向，但需要分时进行。如下图所示：</p>
<p>![image-20221222195858398](51 单片机的学习/image-20221222195858398.png)</p>
<p>3.<strong>全双工通信</strong></p>
<p>全双工是指数据可以同时进行双向传输。如下图所示：</p>
<p>![image-20221222195931136](51 单片机的学习/image-20221222195931136.png)</p>
<h2 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h2><p>传输速率又叫比特率, 比特率是每秒钟传输二进制代码的位数，单位是：位／秒（ bps）。</p>
<p><strong>波特率</strong>是每秒钟传输二进制代码的码数.</p>
<h2 id="单片机串口介绍"><a href="#单片机串口介绍" class="headerlink" title="单片机串口介绍"></a>单片机串口介绍</h2><h2 id="串口通信简介"><a href="#串口通信简介" class="headerlink" title="串口通信简介"></a>串口通信简介</h2><ol>
<li>接口标准</li>
</ol>
<p>这里我们就以 RS-232C 接口进行讲解。</p>
<p>RS-232C 接口规定使用 25 针连接器，简称 DB25，连接器的尺寸及每个插 针的排列位置都有明确的定义，如下图所示：</p>
<p>![image-20221222200845733](51 单片机的学习/image-20221222200845733.png)</p>
<p>并且会分为公头和母头(这里很好理解) 并且注意 公头和母头的引脚顺序是不一样的</p>
<p>![img](51 单片机的学习/D{YY7UPTU03`WY12{276DW.png)</p>
<p>每个引脚的功能如下所示: </p>
<p>![img](51 单片机的学习/7AIV49W9@6R%AKMC9}W0L43.png)</p>
<p>串口通信中还需要注意的是，串口数据收发线要交叉连接，计算机的 TXD 要对应单片机的 RXD，计算机的 RXD 要对应单片机的 TXD，并且共 GND，如下 图</p>
<p>![image-20221222201449669](51 单片机的学习/image-20221222201449669.png)</p>
<ol start="2">
<li><strong>通信协议</strong></li>
</ol>
<p>RS232 的通信协议比较简单，通常遵循 <strong>96-N-8-1</strong> 格式。</p>
<p> <strong>“96”表示的是通信波特率为 9600</strong>。串口通信中通常使用的是异步串口通 信，即没有时钟线，所以两个设备要通信，必须要保持一致的波特率，当然，波特率常用值还有 4800、 115200 等.</p>
<p><strong>“N”表示的是无校验位，</strong>由于串口通信相对更容易受到外部干扰导致传输 数据出现偏差，可以在传输过程加上校验位来解决这个问题。</p>
<p><strong>“8”表示的是数据位数为 8 位</strong></p>
<p><strong>“1”表示的是 1 位停止位</strong>，串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示，而数据包的停 止信号可由 0.5,1,1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可.</p>
<ol start="3">
<li><strong>串口的内部结构</strong></li>
</ol>
<p>![串口通信内部结构](51 单片机的学习/串口通信内部结构.png)</p>
<p>波特率 靠TH1,TL1 工作在定时器工作在模式2</p>
<p>TXD 对应的是 P3.1 管脚，RXD 对 应的是 P3.0 管脚。</p>
<p>输入和输出时注意读取SBUF缓存器</p>
<ol start="4">
<li><strong>串口控制寄存器 SCON</strong></li>
</ol>
<p>![3](51 单片机的学习/3.png)</p>
<p><strong>SM0 和 SM1</strong> 为工作方式选择位： 一般选择工作在<strong>方式一</strong></p>
<p>![4](51 单片机的学习/4.png)</p>
<p><strong>SM2</strong>：多机通信控制位，<strong>这里设置为0即可</strong> ,因为它主要用于方式 2 和方式3.</p>
<p><strong>REN</strong>：允许串行接收位。由软件置 <strong>REN=1</strong>，则启动串行口接收数据；若软件置 <strong>REN=0</strong>，则禁止接收.</p>
<p><strong>TB8</strong>：在方式 2 或方式 3 中，是发送数据的第 9 位，可以用软件规定其作用。 可以用作数据的奇偶校验位，或在多机通信中，作为地址帧/数据帧的标志位。 <strong>在方式 0 和方式 1 中，该位未用到,设置为0即可.</strong></p>
<p> <strong>RB8</strong>：在方式 2 或方式 3 中，是接收到数据的第 9 位，作为奇偶校验位或地 址帧/数据帧的标志位。<strong>在方式 1 时，若 SM2=0，则 RB8 是接收到的停止位。</strong></p>
<p><strong>TI</strong>：发送中断标志位。<strong>主要使用在方式0</strong>, 在方式 0 时，当串行发送第 8 位数据结束时，或在其 它方式，串行发送停止位的开始时，由内部硬件使 TI 置 1，向 CPU 发中断申请。 在中断服务程序中，必须用软件将其清 0，取消此中断申请。</p>
<p> <strong>RI</strong>：接收中断标志位, 主要使用在方式0。<strong>在方式 0 时</strong>，当串行接收第 8 位数据结束时，或在其 它方式，串行接收停止位的中间时，由内部硬件使 RI 置 1，向 CPU 发中断申请。 也必须在中断服务程序中，用软件将其清 0，取消此中断申请.</p>
<p>电源控制寄存器 PCON中只有SMOD的第一位有关. </p>
<p> <strong>SMOD</strong>：波特率倍增位。在串口方式 1、方式 2、方式 3 时，波特率与 SMOD 有 关，<strong>当 SMOD=1 时，波特率提高一倍</strong>。复位时，SMOD=0</p>
<h2 id="方式一的工作"><a href="#方式一的工作" class="headerlink" title="方式一的工作"></a>方式一的工作</h2><p>方式 1 是 10 位数据的异步通信口。</p>
<p>TXD 为数据发送引脚，RXD 为数据接收引 脚，传送一帧数据的格式如下所示</p>
<p>其中 1 位起始位, 8 位数据位1 位停止位.</p>
<p>![5](51 单片机的学习/5.png)</p>
<h2 id="波特率的计算"><a href="#波特率的计算" class="headerlink" title="波特率的计算"></a>波特率的计算</h2><p>方式 0 的波特率 = $fosc/12$</p>
<p> 方式 2 的波特率 =$（2^{SMOD} /64）· fosc $</p>
<p>方式 3 的波特率 =$（2^{SMOD}/32）·（T1 溢出率)$</p>
<p><strong>方式 1 的波特率 =$（2^{SMOD}/32）·（T1 溢出率） $</strong></p>
<p>可以用 <em>51 波特率初值设定.exe</em> 软件</p>
<h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>这里以普中开发板为例</p>
<p>![6](51 单片机的学习/6.png)</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(u8 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">	SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1</span></span><br><span class="line">	PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍</span></span><br><span class="line">	TH1=baud; <span class="comment">//计数器初始值设置</span></span><br><span class="line">	TL1=baud;</span><br><span class="line">	ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">	EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">	TR1=<span class="number">1</span>; <span class="comment">//打开计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">uart_init(<span class="number">0XFA</span>);<span class="comment">//波特率为 9600</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart</span><span class="params">()</span> interrupt 4 <span class="comment">//串口通信中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">u8 rec_data;</span><br><span class="line">RI = <span class="number">0</span>; <span class="comment">//清除接收中断标志位</span></span><br><span class="line">rec_data=SBUF; <span class="comment">//存储接收到的数据</span></span><br><span class="line">SBUF=rec_data; <span class="comment">//将接收到的数据放入到发送寄存器</span></span><br><span class="line"><span class="keyword">while</span>(!TI); <span class="comment">//等待发送数据完成</span></span><br><span class="line">TI=<span class="number">0</span>; <span class="comment">//清除发送完成标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电赛准备</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex的基本语法</title>
    <url>/2022/12/20/LaTex%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>本文是B站以下两视频的学习笔记<br><a href="https://www.bilibili.com/video/BV15x411j7k6?p=1&amp;vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7">latex中文教程-15集从入门到精通包</a></p>
<p><a href="https://www.bilibili.com/video/BV1Zh411y7ps/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7">数模&amp;美赛之LaTeX攻破</a></p>
<h1 id="LaTeX-的基本框架"><a href="#LaTeX-的基本框架" class="headerlink" title="$LaTeX$的基本框架"></a>$LaTeX$的基本框架</h1><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">%导言区</span><br><span class="line">\<span class="selector-tag">documentclass</span>&#123;<span class="selector-tag">article</span>&#125; %这里有<span class="selector-tag">article</span> <span class="selector-tag">book</span> <span class="selector-tag">letter</span> <span class="selector-tag">report</span>等格式</span><br><span class="line">\<span class="selector-tag">usepackage</span>&#123;<span class="selector-tag">ctex</span>&#125; % 引入中文包,可以在正文区里输入中文</span><br><span class="line">\<span class="selector-tag">author</span>&#123;<span class="selector-tag">Carl</span>&#125;</span><br><span class="line">\<span class="selector-tag">date</span> &#123;\<span class="selector-tag">today</span>&#125;</span><br><span class="line">\<span class="selector-tag">title</span>&#123;<span class="selector-tag">My</span> <span class="selector-tag">first</span> <span class="selector-tag">document</span>&#125;</span><br><span class="line">%正文区<span class="selector-tag">-</span>一个<span class="selector-tag">LaTeX</span>文件中只有一个正文去</span><br><span class="line">\<span class="selector-tag">begin</span>&#123;<span class="selector-tag">document</span>&#125;	</span><br><span class="line">	\<span class="selector-tag">maketitle</span>	%在<span class="selector-tag">letter</span>中无法使用此命令</span><br><span class="line">	</span><br><span class="line">	<span class="selector-tag">hello</span> <span class="selector-tag">world</span></span><br><span class="line">	你好世界</span><br><span class="line">			%这里用空行可以另起一行</span><br><span class="line">	这是一个公式:$<span class="selector-tag">f</span>(x)=<span class="selector-tag">x</span>^<span class="number">2</span>+<span class="number">2</span><span class="selector-tag">x</span>+<span class="number">1</span>$ %单美元符号 接在后面输入公式</span><br><span class="line">	</span><br><span class="line">	这是另一个公式:$$<span class="selector-tag">f</span>(x)=<span class="number">3</span><span class="selector-tag">x</span>^<span class="number">2</span>+<span class="number">2</span><span class="selector-tag">x</span>+<span class="number">1</span>$$ %双美元符号 另起一行输入公式</span><br><span class="line">\<span class="selector-tag">end</span>&#123;<span class="selector-tag">document</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LaTeX-中文架构的搭建"><a href="#LaTeX-中文架构的搭建" class="headerlink" title="$LaTeX$ 中文架构的搭建"></a>$LaTeX$ 中文架构的搭建</h1><h2 id="首先设置"><a href="#首先设置" class="headerlink" title="首先设置"></a>首先设置</h2><ul>
<li>选项-构建-XeLaTeX</li>
<li>编译器-UTF-8</li>
</ul>
<h2 id="搭建中文架构"><a href="#搭建中文架构" class="headerlink" title="搭建中文架构"></a>搭建中文架构</h2><p>ctex 宏包和文档类2进一步封装了 CJK、xeCJK、luatexja 等宏包，使得用户在排版中文时 不用再考虑排版引擎等细节。</p>
<p>ctex 宏包本身用于配合各种文档类排版中文，而 ctex 文档类对 LATEX 的标准文档类进行了封装，对一些排版根据中文排版习惯做了调整，包括 ctexart / ctexrep / ctexbook。ctex 宏包和文档类能够识别操作系统和 TEX 发行版中安装的中文字体，因此基本 无需额外配置即可排版中文文档。<a href="lshort-zh-cn">^1</a></p>
<p>下面举一个使用 ctex 文档类排版中文的最简例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;ctexart&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">在\LaTeX&#123;&#125;中排版中文。</span><br><span class="line">汉字和English单词混排，通常不需要在中英文之间添加额外的空格。</span><br><span class="line">当然，为了代码的可读性，加上汉字和 English 之间的空格也无妨。</span><br><span class="line">汉字换行时不会引入多余的空格。</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LaTeX-字体字号的设置"><a href="#LaTeX-字体字号的设置" class="headerlink" title="$LaTeX$ 字体字号的设置"></a>$LaTeX$ 字体字号的设置</h1><h2 id="字体设置的两种方式"><a href="#字体设置的两种方式" class="headerlink" title="字体设置的两种方式"></a>字体设置的两种方式</h2><ul>
<li>字体声明 <code>\texterm&#123;Roman Family&#125;</code></li>
<li>字体命令<code>&#123;\texterm Roman Family&#125; %这里的大括号表示作用的范围</code></li>
</ul>
<h2 id="字体族的设置"><a href="#字体族的设置" class="headerlink" title="字体族的设置"></a>字体族的设置</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>\rmfamily</td>
<td>\textrm{…}</td>
<td>roman</td>
<td align="center">衬线字体（罗马体）</td>
</tr>
<tr>
<td>\sffamily</td>
<td>\textsf{…}</td>
<td>sans serif</td>
<td align="center">无衬线字体</td>
</tr>
<tr>
<td>\ttfamily</td>
<td>\texttt{…}</td>
<td>typewriter</td>
<td align="center">等宽字体</td>
</tr>
</tbody></table>
<h2 id="字体系列的设置-粗细"><a href="#字体系列的设置-粗细" class="headerlink" title="字体系列的设置(粗细)"></a>字体系列的设置(粗细)</h2><table>
<thead>
<tr>
<th>\mdseries</th>
<th>\textmd{…}</th>
<th>medium</th>
<th>正常粗细（中等）</th>
</tr>
</thead>
<tbody><tr>
<td>\bfseries</td>
<td>\textbf{…}</td>
<td><strong>bold face</strong></td>
<td>粗体</td>
</tr>
</tbody></table>
<h2 id="字体形状的设置"><a href="#字体形状的设置" class="headerlink" title="字体形状的设置"></a>字体形状的设置</h2><table>
<thead>
<tr>
<th>\upshape</th>
<th>\upshape</th>
<th>upright</th>
<th>直立体</th>
</tr>
</thead>
<tbody><tr>
<td>\itshape</td>
<td>\textit{…}</td>
<td>italic</td>
<td>意大利斜体</td>
</tr>
<tr>
<td>\slshape</td>
<td>\textsl{…}</td>
<td>slanted</td>
<td>倾斜体</td>
</tr>
<tr>
<td>\scshape</td>
<td>\textsc{…}</td>
<td>SMALL CAPS</td>
<td>小型大写字母</td>
</tr>
</tbody></table>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%字体字号设置</span></span><br><span class="line"><span class="keyword">\documentclass</span>[10pt]&#123;article&#125;<span class="comment">%10磅是默认正常的字体大小，即下文中的normalsize</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\myfont</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;<span class="keyword">\textsf</span>&#123;Fancy Text&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">%字体族设置(罗马字体、无衬线字体、打字机字体)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\textrm</span>&#123;Roman Family&#125; <span class="keyword">\textsf</span>&#123;Scan Serif Family&#125;<span class="keyword">\texttt</span>&#123;Typewriter Family&#125;<span class="comment">%\textrm等是字体命令，大括号里是作用到的文字</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\rmfamily</span> Roman Family&#125; &#123;<span class="keyword">\sffamily</span> Scan Serif Family&#125;&#123;<span class="keyword">\ttfamily</span> Typewriter Family&#125;<span class="comment">%\rmfamily是字体声明，后面紧跟的文字是作用到的文字</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\sffamily</span> Who are you?you find self on everyone around.take you as the same as others!&#125;</span><br><span class="line">&#123;<span class="keyword">\ttfamily</span> Are you aiser than others?&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%字体系列设置(粗细、宽度)，\textbf可以对字体加粗</span></span><br><span class="line"><span class="keyword">\textmd</span>&#123;Medium Series&#125; <span class="keyword">\textbf</span>&#123;Boldface Series&#125;<span class="comment">%\textmd等是字体命令，大括号里是作用到的文字</span></span><br><span class="line">&#123;<span class="keyword">\mdseries</span> Medium Series&#125; &#123;<span class="keyword">\bfseries</span> Boldface Series&#125;<span class="comment">%字体声明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%字体形状(直立、斜体、伪斜体、小型大写)</span></span><br><span class="line"><span class="keyword">\textup</span>&#123;Upright Shape&#125; <span class="keyword">\textit</span>&#123;Italic Shape&#125; <span class="comment">%字体命令</span></span><br><span class="line"><span class="keyword">\textsl</span>&#123;Slanted Shape&#125; <span class="keyword">\textsc</span>&#123;Small Caps Shape&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\upshape</span> Upright Shape&#125; &#123;<span class="keyword">\itshape</span> Italic Shape &#125;<span class="comment">%字体声明</span></span><br><span class="line">&#123;<span class="keyword">\slshape</span> Slanted Shape&#125;</span><br><span class="line">&#123;<span class="keyword">\scshape</span> Small Caps Shape&#125;</span><br></pre></td></tr></table></figure>



<h2 id="英文字体大小的设置"><a href="#英文字体大小的设置" class="headerlink" title="英文字体大小的设置"></a>英文字体大小的设置</h2><p>控制文档的参数:<code>\documentclass[11pt]&#123;article&#125;</code>                 </p>
<table>
<thead>
<tr>
<th>字号</th>
<th>10pt 选项（默认）</th>
<th>11pt 选项</th>
<th>12pt 选项</th>
</tr>
</thead>
<tbody><tr>
<td>\tiny</td>
<td>5pt</td>
<td>6pt</td>
<td>6pt</td>
</tr>
<tr>
<td>\scriptsize</td>
<td>7pt</td>
<td>8pt</td>
<td>8pt</td>
</tr>
<tr>
<td>\footnotesize</td>
<td>8pt</td>
<td>9pt</td>
<td>10pt</td>
</tr>
<tr>
<td>\small</td>
<td>9pt</td>
<td>10pt</td>
<td>10.95pt</td>
</tr>
<tr>
<td>\normalsize</td>
<td>10pt</td>
<td>10.95pt</td>
<td>12pt</td>
</tr>
<tr>
<td>\large</td>
<td>12pt</td>
<td>12pt</td>
<td>14.4pt</td>
</tr>
<tr>
<td>\Large</td>
<td>14.4pt</td>
<td>14.4pt</td>
<td>17.28pt</td>
</tr>
<tr>
<td>\LARGE</td>
<td>17.28pt</td>
<td>17.28pt</td>
<td>20.74pt</td>
</tr>
<tr>
<td>\huge</td>
<td>20.74pt</td>
<td>20.74pt</td>
<td>24.88pt</td>
</tr>
<tr>
<td>\Huge</td>
<td>24.88pt</td>
<td>24.88pt</td>
<td>24.88pt</td>
</tr>
</tbody></table>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%字体大小</span></span><br><span class="line">&#123;<span class="keyword">\tiny</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\scriptsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\footnotesize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\small</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\normalsize</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\Large</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\LARGE</span>  Hello &#125;<span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\huge</span>  Hello &#125;<span class="keyword">\\</span> </span><br></pre></td></tr></table></figure>



<h2 id="中文字体的设置"><a href="#中文字体的设置" class="headerlink" title="中文字体的设置"></a>中文字体的设置</h2><p>在引入了中文宏包后</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">\songti</span> 宋体&#125; <span class="keyword">\quad</span> &#123;<span class="keyword">\heiti</span> 黑体&#125; <span class="keyword">\quad</span> &#123;<span class="keyword">\fangsong</span> 仿宋&#125; <span class="keyword">\quad</span> &#123;<span class="keyword">\kaiti</span> 楷体&#125;</span><br><span class="line"><span class="comment">%中文的粗细设置</span></span><br><span class="line"><span class="keyword">\textbf</span>&#123;粗体&#125; <span class="keyword">\quad</span> <span class="keyword">\textit</span>&#123;斜体&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中文字体大小的设置"><a href="#中文字体大小的设置" class="headerlink" title="中文字体大小的设置"></a>中文字体大小的设置</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\zihao</span>&#123;5&#125; <span class="comment">%里面填字号</span></span><br></pre></td></tr></table></figure>

<h2 id="函数与字体设置分离的思想"><a href="#函数与字体设置分离的思想" class="headerlink" title="函数与字体设置分离的思想"></a>函数与字体设置分离的思想</h2><p>在导言区中设置函数<code>\newcommand&#123;\myfont&#125;&#123;\textbf&#123;\textbf&#125;&#123;\textsf&#123;Fancy Text&#125;&#125;&#125;</code></p>
<p>在正文中使用命令<code>\myfont</code></p>
<hr>
<h1 id="LaTeX-的篇章结构"><a href="#LaTeX-的篇章结构" class="headerlink" title="$LaTeX$ 的篇章结构"></a>$LaTeX$ 的篇章结构</h1><h3 id="标题的设置"><a href="#标题的设置" class="headerlink" title="标题的设置"></a>标题的设置</h3><ul>
<li><code>\section</code>为一级标题</li>
<li><code>\subsection</code>为二级标题</li>
<li><code>\subsubsection</code>为三级标题 ….</li>
</ul>
<p>在导言区可以设置标题的格式[^2]</p>
<p>[^2]:详情见ctext 第七章标题格式的设置</p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ol>
<li><strong>空一行</strong>  (推荐使用这个)</li>
<li>\ \ 两个反斜杠 注意此时首行不缩进</li>
<li><code>\par</code>使用命令</li>
</ol>
<h2 id="ctextbook"><a href="#ctextbook" class="headerlink" title="ctextbook"></a>ctextbook</h2><ul>
<li><code>\chart</code>设置章节</li>
<li><code>\tableofcontents</code>设置目录</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%文档基本结构</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\title</span>&#123;First Tex File&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;Carl&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">	<span class="keyword">\maketitle</span><span class="comment">%使得导言区的设置生效</span></span><br><span class="line">	<span class="keyword">\section</span>&#123;引言&#125;</span><br><span class="line">	中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。</span><br><span class="line">	</span><br><span class="line">	中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。<span class="keyword">\par</span></span><br><span class="line">	中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。<span class="keyword">\\</span>中国人口模式的转变发生于民国时期 关于民国的进步,我只讲两个过去人们比较忽略的问题。	一是人口模式。如前所述,传统时代人口的增减是王朝兴衰的显示器。</span><br><span class="line">	<span class="keyword">\section</span>&#123;实验方法&#125;</span><br><span class="line">	<span class="keyword">\section</span>&#123;实验结果&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>&#123;数据&#125;</span><br><span class="line">	<span class="keyword">\subsection</span>&#123;图表&#125;</span><br><span class="line">	<span class="keyword">\subsubsection</span>&#123;实验过程&#125;</span><br><span class="line">	<span class="keyword">\section</span>&#123;结论&#125;</span><br><span class="line">	<span class="keyword">\section</span>&#123;致谢&#125;	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul>
<li>在英文段落中两个单词直接空一格，注意此时不管几个空格都当作一个空格</li>
<li>中文段落中，两个中文之间加空格，视作无空格</li>
<li>在中文英文都有的段落中，中文和因为之间会存在一个空格</li>
<li>段落首行的缩进是自动产生的！不可以用空格代替!!!</li>
</ul>
<p>手动加入空格</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\quad</span> <span class="comment">%一个空格</span></span><br><span class="line"><span class="keyword">\qquad</span> <span class="comment">%两个空格</span></span><br><span class="line"><span class="comment">%... 更多可以查询手册</span></span><br></pre></td></tr></table></figure>



<h2 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\#</span> <span class="keyword">\$</span> <span class="keyword">\&#123;</span>  <span class="keyword">\&#125;</span> <span class="keyword">\~</span>&#123;&#125; <span class="keyword">\_</span>&#123;&#125; <span class="keyword">\^</span>&#123;&#125; <span class="keyword">\textbackslash</span></span><br></pre></td></tr></table></figure>

<h2 id="排版符号"><a href="#排版符号" class="headerlink" title="排版符号"></a>排版符号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\S \P \dag \ddag \copyright \pounds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="标志符号"><a href="#标志符号" class="headerlink" title="标志符号"></a>标志符号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ </span>TeX&#123;&#125; <span class="keyword">\ </span>LaTeX&#123;&#125;  <span class="keyword">\ </span>LaTeXe&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%XlLaTeX用xltxtra宏包提供</span></span><br><span class="line"><span class="keyword">\XlLaTeX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%其他标志符号见手册</span></span><br></pre></td></tr></table></figure>

<h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">` <span class="comment">%左单引号 </span></span><br><span class="line">&#x27; <span class="comment">%右单引号 </span></span><br><span class="line">`` <span class="comment">%左双引号 </span></span><br><span class="line">&#x27;&#x27; <span class="comment">%右双引号 </span></span><br></pre></td></tr></table></figure>

<h2 id="连字符"><a href="#连字符" class="headerlink" title="连字符"></a>连字符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- -- ---</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><ul>
<li><em><strong>texstudio最上方向导里有图片插入，可以不用自己写代码，不过导言区需要加个\usepackage{graphicx}命令</strong></em></li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%导言区内</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125; <span class="comment">%导入宏包</span></span><br><span class="line"><span class="keyword">\graphicspath</span>&#123;&#123;figures/&#125;,&#123;pics/&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区内</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[设置参数]&#123;图像名字&#125;</span><br><span class="line"><span class="comment">% 这里推荐用 texstudio最上方向导里的图片插入</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="表格的制作"><a href="#表格的制作" class="headerlink" title="表格的制作"></a>表格的制作</h1><ul>
<li>\\   表示换行</li>
<li>&amp;    连接不同的列</li>
<li>l      表示左对齐</li>
<li>c      表示居中对齐</li>
<li>r      表示右对齐</li>
<li>p{宽度}  控制宽度,注意单位</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 在正文区中</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l| c| c| c| p&#123;宽度&#125;|&#125;<span class="comment">%会有5列，指定每列的居中形式,|表示每列中间有竖线分开.||表示双竖线</span></span><br><span class="line">	<span class="keyword">\hline</span> <span class="comment">%每行之间由横线分开.\hline \hline 表示双横线</span></span><br><span class="line">	姓名<span class="built_in">&amp;</span>语文<span class="built_in">&amp;</span>数学<span class="built_in">&amp;</span>外语<span class="built_in">&amp;</span>政治<span class="keyword">\\</span><span class="comment">%\\表示换行</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line">	张三<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line">	张1<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line">	张2<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">	<span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="浮动体"><a href="#浮动体" class="headerlink" title="浮动体"></a>浮动体</h1><ul>
<li>灵活分页</li>
<li>给图标加标题</li>
<li>交叉引用</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%图片的浮动体</span></span><br><span class="line"><span class="keyword">\LaTeX</span>&#123;&#125;中<span class="keyword">\TeX</span> 系统的吉祥物--小狮子见图<span class="keyword">\ref</span>&#123;fig-lion&#125; <span class="comment">%交叉引用</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp] <span class="comment">%[htbp]表示浮动体的排版位置</span></span><br><span class="line">	<span class="keyword">\centering</span> <span class="comment">%使得以下内容居中的命令</span></span><br><span class="line">	<span class="keyword">\includegraphics</span>&#123;two2.jpg&#125; <span class="comment">%插入图片</span></span><br><span class="line">	<span class="comment">%\label命令为浮动体设置标签，\ref引用该标签</span></span><br><span class="line">	<span class="keyword">\caption</span>&#123;<span class="keyword">\TeX</span> 系统的吉祥物---小狮子&#125;<span class="keyword">\label</span>&#123;fig-lion&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">%表格的浮动体</span></span><br><span class="line">在<span class="keyword">\LaTeX</span>&#123;&#125;中也可以使用表<span class="keyword">\ref</span>&#123;tab-score&#125;所示的表格</span><br><span class="line">	<span class="keyword">\begin</span>&#123;table&#125;[htbp]</span><br><span class="line">		<span class="keyword">\centering</span></span><br><span class="line">		<span class="keyword">\caption</span>&#123;成绩单&#125;<span class="keyword">\label</span>&#123;tab-score&#125;</span><br><span class="line">		<span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l|c|c|c|r|&#125;</span><br><span class="line">			<span class="keyword">\hline</span><span class="comment">%每行之间由横线分开</span></span><br><span class="line">			姓名<span class="built_in">&amp;</span>语文<span class="built_in">&amp;</span>数学<span class="built_in">&amp;</span>外语<span class="built_in">&amp;</span>政治<span class="keyword">\\</span><span class="comment">%\\表示换行</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">			张三<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">			张1<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">			张2<span class="built_in">&amp;</span>87<span class="built_in">&amp;</span>120<span class="built_in">&amp;</span>25<span class="built_in">&amp;</span>36<span class="keyword">\\</span></span><br><span class="line">			<span class="keyword">\hline</span></span><br><span class="line">		<span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;table&#125;	</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>可以使用软件直接生成公式复制到$LaTeX$中</p>
<p>软件名: Mathpix</p>
<h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">1.美元符号 <span class="built_in">$</span>a+b=b+a <span class="built_in">$</span></span><br><span class="line">2.小括号 <span class="keyword">\(</span>a+b=b+a<span class="keyword">\)</span></span><br><span class="line">3.浮动体math环境</span><br><span class="line"><span class="keyword">\begin</span>&#123;math&#125;</span><br><span class="line">a+b=b+a</span><br><span class="line"><span class="keyword">\end</span>&#123;math&#125;</span><br></pre></td></tr></table></figure>

<h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><ul>
<li>使用<code>^</code> 符号</li>
</ul>
<p>比如<code>2^2</code>的效果是 $2^2$.但是后面只能跟一个字符</p>
<p>如果需要跟多个字符则需要使用^{}</p>
<p>比如2^{20}的效果是:  $2^{20}$</p>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>使用_符号</p>
<p>比如a_1,a_2,a_3. $a_1,a_2,a_3$. 但是后面也只能跟一个字符</p>
<p>如果需要跟多个字符则需要使用_{}</p>
<p>比如a_{20}的效果是:   </p>
<p>$a_{20}$</p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\beta</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\gamma</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\epsilon</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\pi</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\omega</span><span class="built_in">$</span>	</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Gamma</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Delta</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Theta</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Pi</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>得到:</p>
<p>$\alpha$<br>$\beta$<br>$\gamma$<br>$\epsilon$<br>$\pi$<br>$\omega$<br>$\Gamma$<br>$\Delta$<br>$\Theta$<br>$\Pi$<br>$\Omega$</p>
<h2 id="数学公式-1"><a href="#数学公式-1" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\log</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sin</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\cos</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\arccos</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\arcsin</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\ln</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%以及联合使用</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sin</span><span class="built_in">^</span>2x+<span class="keyword">\cos</span><span class="built_in">^</span>2x=1<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;2&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;x<span class="built_in">^</span>2+y<span class="built_in">^</span>2&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>&#123;2+<span class="keyword">\sqrt</span>&#123;2&#125;&#125;<span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>[4]&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>得到:</p>
<p>$\log$<br>$\sin$<br>$\cos$<br>$\arccos$<br>$\arcsin$<br>$\ln$</p>
<p>$\sin^2x+\cos^2x=1$<br>$\sqrt{2}$<br>$\sqrt{x^2+y^2}$<br>$\sqrt{2+\sqrt{2}}$<br>$\sqrt[4]{x}$</p>
<h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%两种写法</span></span><br><span class="line">1.大约是原体积的<span class="built_in">$</span>3/4<span class="built_in">$</span></span><br><span class="line">2.大约是原体积的<span class="built_in">$</span><span class="keyword">\frac</span>&#123;3&#125;&#123;4&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%1.</span></span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%不会自动编号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">\begin</span>&#123;displaymath&#125;</span><br><span class="line">		2x<span class="built_in">^</span>2+5x+3=6	</span><br><span class="line">	<span class="keyword">\end</span>&#123;displaymath&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%会自动编号!这个很重要</span></span><br><span class="line"></span><br><span class="line">	交换律见式<span class="keyword">\ref</span>&#123;eq:commutative&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">		a+b=b+a <span class="keyword">\label</span>&#123;eq:commutative&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%不会自动编号的equation环境</span></span><br><span class="line"><span class="comment">%注意要引用一个宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;equation*&#125;</span><br><span class="line">		a+b=b+a <span class="keyword">\label</span>&#123;eq:commutative&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;equation*&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="矩阵的生成"><a href="#矩阵的生成" class="headerlink" title="矩阵的生成"></a>矩阵的生成</h1><ul>
<li>省略号: <code>\dots(水平), \vdots(垂直), \ddots(斜的), adots(需要自己配置)</code></li>
<li><code>\adot</code>的效果.可以直接用<code>\iddots</code>生成，但要调用<code>mathdots</code>宏包</li>
</ul>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%需要导入宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br><span class="line"><span class="comment">%正文区</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;<span class="comment">%&amp;分列 \\分行</span></span><br><span class="line">  0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">  1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;<span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%括号包裹的矩阵</span></span><br><span class="line"> 0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span>	</span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;vmatrix&#125;<span class="comment">%长竖线包裹的矩阵</span></span><br><span class="line">0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;bmatrix&#125;<span class="comment">%长中括号包裹的矩阵</span></span><br><span class="line">0<span class="built_in">&amp;</span>1<span class="keyword">\\</span></span><br><span class="line">1<span class="built_in">&amp;</span>0</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%括号包裹的矩阵</span></span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125;<span class="built_in">^</span>2<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;12&#125;<span class="built_in">^</span>2<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;13&#125;<span class="built_in">^</span>2<span class="keyword">\\</span></span><br><span class="line">0<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;22&#125;<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;33&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;bmatrix&#125;<span class="comment">%长中括号包裹的矩阵</span></span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125;<span class="built_in">&amp;</span><span class="keyword">\dots</span><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;1n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span><span class="keyword">\ddots</span><span class="built_in">&amp;</span><span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;<span class="built_in">_</span>&#123;n <span class="keyword">\times</span> n&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%分块矩阵(矩阵嵌套)</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1<span class="built_in">&amp;</span>0<span class="keyword">\\</span>0<span class="built_in">&amp;</span>1</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;<span class="keyword">\Large</span> 0&#125;<span class="keyword">\\</span>  <span class="comment">%生成一个很大的0</span></span><br><span class="line"><span class="keyword">\text</span>&#123;<span class="keyword">\Large</span> 0&#125;<span class="built_in">&amp;</span><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1<span class="built_in">&amp;</span>0<span class="keyword">\\</span>0<span class="built_in">&amp;</span>1</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;<span class="comment">%括号包裹的矩阵</span></span><br><span class="line">a<span class="built_in">_</span>&#123;11&#125;<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;12&#125;<span class="built_in">&amp;</span><span class="keyword">\cdots</span><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;ln&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;22&#125;<span class="built_in">&amp;</span><span class="keyword">\cdots</span><span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;2n&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span>		<span class="built_in">&amp;</span><span class="keyword">\dots</span> <span class="built_in">&amp;</span><span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\multicolumn</span>&#123;2&#125;&#123;c&#125;&#123;<span class="keyword">\raisebox</span>&#123;1.3ex&#125;[0pt]&#123;<span class="keyword">\Huge</span> 0&#125;&#125; <span class="comment">%合并行和列;设置大小</span></span><br><span class="line"><span class="built_in">&amp;</span>		<span class="built_in">&amp;</span>a<span class="built_in">_</span>&#123;nn&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">1<span class="built_in">&amp;</span><span class="keyword">\frac</span> 12 <span class="built_in">&amp;</span><span class="keyword">\dots</span> <span class="built_in">&amp;</span><span class="keyword">\frac</span> ln <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hdotsfor</span>&#123;4&#125;<span class="keyword">\\</span>  <span class="comment">%跨列的省略号：\hdotsfor&#123;&lt;列数&gt;&#125;</span></span><br><span class="line">m<span class="built_in">&amp;</span><span class="keyword">\frac</span> m2<span class="built_in">&amp;</span> <span class="keyword">\dots</span> <span class="built_in">&amp;</span><span class="keyword">\frac</span> mn</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">%行内小矩阵(smallmatrix)环境</span></span><br><span class="line">复数<span class="built_in">$</span>z=(x,y)<span class="built_in">$</span>也可以用矩阵</span><br><span class="line"><span class="keyword">\begin</span>&#123;math&#125;</span><br><span class="line">   <span class="keyword">\left</span>(<span class="comment">%需手动加上左括号</span></span><br><span class="line">   <span class="keyword">\begin</span>&#123;smallmatrix&#125;</span><br><span class="line">  x<span class="built_in">&amp;</span> -y<span class="keyword">\\</span>y<span class="built_in">&amp;</span>x</span><br><span class="line">   <span class="keyword">\end</span>&#123;smallmatrix&#125;</span><br><span class="line">   <span class="keyword">\right</span>)<span class="comment">%需手动加上右括号</span></span><br><span class="line"><span class="keyword">\end</span>&#123;math&#125;来表示</span><br><span class="line"></span><br><span class="line"><span class="comment">%array环境(类似表格环境tabular)</span></span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;r|r&#125;</span><br><span class="line"><span class="keyword">\frac</span> 12<span class="built_in">&amp;</span>0<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">0<span class="built_in">&amp;</span> -<span class="keyword">\frac</span> abc<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="多行数学公式"><a href="#多行数学公式" class="headerlink" title="多行数学公式"></a>多行数学公式</h1><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区引入宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amssymb&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区</span></span><br><span class="line">	<span class="comment">%gather和gather*环境(可以使用\\换行)</span></span><br><span class="line">	<span class="comment">%带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">	a+b=b+a<span class="keyword">\\</span></span><br><span class="line">	ab  ba</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%不带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather*&#125;</span><br><span class="line">	3+5=5+3<span class="keyword">\\</span></span><br><span class="line">	3 <span class="keyword">\times</span> 5=5<span class="keyword">\times</span> 3</span><br><span class="line"><span class="keyword">\end</span>&#123;gather*&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%在\\前使用\notetag阻止编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">	3<span class="built_in">^</span>2+4<span class="built_in">^</span>2=5<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%align和align*环境(用&amp;对齐)</span></span><br><span class="line"><span class="comment">%带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">	x <span class="built_in">&amp;</span>=t+<span class="keyword">\cos</span> t+1<span class="keyword">\\</span></span><br><span class="line">	y <span class="built_in">&amp;</span>=2 <span class="keyword">\sin</span> t</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="comment">%不带编号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align*&#125;</span><br><span class="line">x <span class="built_in">&amp;</span>=t+<span class="keyword">\cos</span> t+1<span class="keyword">\\</span></span><br><span class="line">y <span class="built_in">&amp;</span>=2 <span class="keyword">\sin</span> t</span><br><span class="line"><span class="keyword">\end</span>&#123;align*&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">%split环境(对齐采用align环境的方式，编号在中间)</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;split&#125;</span><br><span class="line">	<span class="keyword">\cos</span> 2x <span class="built_in">&amp;</span>=<span class="keyword">\cos</span><span class="built_in">^</span>2 x- <span class="keyword">\sin</span><span class="built_in">^</span>2 x<span class="keyword">\\</span></span><br><span class="line">	<span class="built_in">&amp;</span>=2<span class="keyword">\cos</span><span class="built_in">^</span>2 x-1</span><br><span class="line"><span class="keyword">\end</span>&#123;split&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;		</span><br><span class="line">	</span><br><span class="line"><span class="comment">%case环境</span></span><br><span class="line"><span class="comment">%每行公式中使用&amp;分隔为两部分</span></span><br><span class="line"><span class="comment">%通常表示值和后面的条件</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">	D(x)=<span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">	1,<span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;如果&#125; x <span class="keyword">\in</span> <span class="keyword">\mathbb</span>&#123;Q&#125;;<span class="keyword">\\</span></span><br><span class="line">	0,<span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;如果&#125; x <span class="keyword">\in</span> <span class="keyword">\mathbb</span>&#123;R&#125;<span class="keyword">\setminus</span><span class="keyword">\mathbb</span>&#123;Q&#125;</span><br><span class="line">	<span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用zotero实现参考文献的导入"><a href="#使用zotero实现参考文献的导入" class="headerlink" title="使用zotero实现参考文献的导入"></a>使用zotero实现参考文献的导入</h1><ul>
<li>下载zotero</li>
<li>在扩展程序中下载 save to zotero</li>
<li>在文章页面中点击 save to zotero 保存到文库中</li>
<li>在文库中导出 导出格式为BiBTeX</li>
<li>用记事本打开导出文件,复制到所写的latex文件中</li>
<li>ref,改为文章的题目方便查找</li>
<li>在正文内使用命令<code>\cite</code>选择所引用的文章即可</li>
<li><strong>注意检查格式!!!</strong></li>
</ul>
<p>在参考文献位置输入命令</p>
<p><code>\bibligraphy&#123;book&#125;</code>生成参考文献</p>
<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>新起一页 <code>\newpage</code></p>
<p><code>\appendix</code> 表示是附录部分</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\section</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;lstlisting&#125;[language=matlab] <span class="comment">% 语言可以自己选择</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">%这里面粘贴代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;lstlisting&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>LaTeX</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言基础</title>
    <url>/2023/01/12/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="变量-amp-常量"><a href="#变量-amp-常量" class="headerlink" title="变量&amp;常量"></a>变量&amp;常量</h1><h2 id="变量-引用："><a href="#变量-引用：" class="headerlink" title="变量/引用："></a>变量/引用：</h2><ul>
<li><p>在程序运行过程中，值会发生变化的量（变量）</p>
</li>
<li><p>变量是一段有名字的连续存储空间。我们通过定义变量来申请并命名这样的存储空间，并通过变量的名字来使用这段存储空间。</p>
</li>
<li><p>在编程语言中，将数据放入变量的过程叫做赋值（Assignment）。Python 使用等号<code>=</code>作为赋值运算符，具体格式为：</p>
</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量名 = 任意类型的值</span><br></pre></td></tr></table></figure>

<ul>
<li>例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">100</span></span><br><span class="line">数学 = <span class="number">200</span> <span class="comment">#不推荐使用中文</span></span><br></pre></td></tr></table></figure>

<h2 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h2><ul>
<li>在程序运行过程中，值不会发生变化的量（常量）</li>
</ul>
<h2 id="具体的使用："><a href="#具体的使用：" class="headerlink" title="具体的使用："></a>具体的使用：</h2><ul>
<li><p>1.无论是变量还是常量，在创建时都会在内存中开辟一块空间，用于保存它的值</p>
</li>
<li><p>2.因此所谓的变量其实表示的就是值（加载到内存中的数据）对应的内存空间的一个引用，因此变量也叫做引用</p>
</li>
<li><p>3.Python中的变量不需要声明类型</p>
</li>
<li><p>4.用“=”号来给变量赋值</p>
<ul>
<li>这里的等号要理解并读作“赋值”，而不是“等于”，“赋值”是对变量的操作，而“等于”是对两个变量进行比较</li>
</ul>
</li>
<li><p>5.每个变量在使用前都必须赋值，变量赋值以后才会被创建</p>
</li>
<li><p>在python中变量就是引用，引用就是变量。</p>
</li>
<li><p>指向</p>
<ul>
<li>如果一个变量或者一个引用可以表示某一块具体的内存空间，则我们可以称为该变量指向该块内存。</li>
</ul>
</li>
<li><p>标识符的命名规则</p>
<ul>
<li><p>简单地理解，标识符就是一个名字，就好像我们每个人都有属于自己的名字，它的主要作用就是作为变量、函数、类、模块以及其他对象的名称。Python中标识符的命名不是随意的，而是要遵守一定的命令规则</p>
<ul>
<li>标识符是由字符（A<del>Z 和 a</del>z）、下划线和数字组成，但第一个字符不能是数字。</li>
<li>标识符不能和 Python 中的保留字相同。有关保留字，后续章节会详细介绍。</li>
<li>Python中的标识符中，不能包含空格、@、% 以及 $ 等特殊字符。</li>
<li>在 Python 中，标识符中的字母是严格区分大小写</li>
<li>Python 语言中，以下划线开头的标识符有特殊含义</li>
<li>Python 允许使用汉字作为标识符（不推荐）</li>
</ul>
</li>
<li><p>Python关键字</p>
</li>
<li><table>
<thead>
<tr>
<th>and</th>
<th>as</th>
<th>assert</th>
<th>break</th>
<th>class</th>
<th>continue</th>
</tr>
</thead>
<tbody><tr>
<td>def</td>
<td>del</td>
<td>elif</td>
<td>else</td>
<td>except</td>
<td>finally</td>
</tr>
<tr>
<td>for</td>
<td>from</td>
<td>False</td>
<td>global</td>
<td>if</td>
<td>import</td>
</tr>
<tr>
<td>in</td>
<td>is</td>
<td>lambda</td>
<td>nonlocal</td>
<td>not</td>
<td>None</td>
</tr>
<tr>
<td>or</td>
<td>pass</td>
<td>raise</td>
<td>return</td>
<td>try</td>
<td>True</td>
</tr>
<tr>
<td>while</td>
<td>with</td>
<td>yield</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>缩进</p>
<ul>
<li><p>和其它程序设计语言（如 <a href="http://c.biancheng.net/java/">Java</a>、C 语言）采用大括号“{}”分隔代码块不同，<a href="http://c.biancheng.net/python/">Python</a> 采用冒号（ : ）和代码缩进和来区分代码块之间的层次。在 Python 中，对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。</p>
<p>注意，Python 中实现对代码的缩进，可以使用空格或者 Tab 键实现。但无论是手动敲空格，还是使用 Tab 键，通常情况下都是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。</p>
</li>
</ul>
</li>
<li><p>注释：</p>
<ul>
<li><p>注释就是对代码的解释和<a href="https://baike.baidu.com/item/%E8%AF%B4%E6%98%8E/39260">说明</a>，其目的是让人们能够更加轻松地了解代码。注释是编写程序时，写程序的人给一个语句、程序段、函数等的解释或提示，能提高程序代码的可读性。一般情况下，合理的代码注释应该占源代码的 1/3 左右。</p>
<blockquote>
<p>注释只是为了提高公认阅读，不会被解释器执行。</p>
</blockquote>
<p>Python 支持两种类型的注释，分别是单行注释和多行注释。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  单行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一个多行注释</span></span><br><span class="line"><span class="string">三引号里面的任何内容不会被解释器执行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>赋值符号的运算法则</p>
<ul>
<li><p>“=”号这个赋值运算符是从右往左的计算顺序</p>
</li>
<li><p>Python允许同时为多个变量赋值</p>
</li>
<li><p>也可以同时为多个变量赋值，用逗号分隔，逐一对应</p>
</li>
<li><p>不要把赋值语句的等号等同于数学的等号</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name = &#x27;bobo&#x27;</span><br><span class="line">a = b = c = 1</span><br><span class="line">a,b,c = 1,2,3</span><br></pre></td></tr></table></figure>

<ul>
<li>把一个变量a赋值给另一个变量b，这个操作实际上是将变量b指向变量a所指向的数据，例如下面的代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &#x27;Jack&#x27;</span><br><span class="line">b = a</span><br><span class="line">a = &#x27;Tom&#x27;</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后变量b的内容到底是’Jack’还是’Tom’呢？如果从数学意义上理解，就会错误地得出b和a相同是‘Tom’，但实际上b的值还是’Jack ‘!why？如何理解呢？</p>
<ul>
<li>请牢记：Python中的一切都是对象，变量是对象的引用！所谓的对象我们在后面的面向对象环节中会详细讲解，现在我们就简单认为Python会把所有的数据都视为是不同的对象即可，数据就是对象，对象就是数据。</li>
<li>执行a = ‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象；</li>
<li>执行b = a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象；</li>
<li>执行a = ‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。</li>
<li><img src="python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/13.png" alt="13"></li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li>常量就是不变的变量，比如常用的数学常数圆周率就是一个常量。在Python中，通常用全部大写的变量名表示常量：PI = 3.14159265359</li>
<li>但事实上，从Python语法角度看，PI仍然是一个变量，因为Python根本没有任何机制保证PI不会被改变。你完全可以给PI赋值为10，不会弹出任何错误。所以，用全部大写的变量名表示常量只是一个习惯上的用法。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="运算符以及输入与输出"><a href="#运算符以及输入与输出" class="headerlink" title="运算符以及输入与输出"></a>运算符以及输入与输出</h1><ul>
<li><p>运算符：以1 + 2为例，1和2被称为操作数，“+” 称为运算符。</p>
</li>
<li><p>Python语言支持以下类型的运算符:</p>
<ul>
<li>算术运算符</li>
<li>比较（关系）运算符</li>
<li>赋值运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>成员运算符</li>
<li>身份运算符</li>
</ul>
</li>
</ul>
<h2 id="python所有的运算符"><a href="#python所有的运算符" class="headerlink" title="python所有的运算符"></a>python所有的运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code> <code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> <code>+</code> <code>-</code></td>
<td>按位取反, 正负号</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>加，减</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>右移，左移</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> `</td>
<td>`</td>
</tr>
<tr>
<td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>小于等于，小于，大于，大于等于</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>等于，不等于</td>
</tr>
<tr>
<td><code>is</code> <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>or</code> <code>and</code></td>
<td>逻辑运算符</td>
</tr>
<tr>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> `</td>
<td>=<code> </code>^=<code> </code>&gt;&gt;=<code> </code>&lt;&lt;=`</td>
</tr>
</tbody></table>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h3><ul>
<li>print用于将内容格式化显示在标准输出上，主要指的是屏幕显示器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 10</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<ul>
<li>print可以接受多个字符串，字符串类型的变量。每个字符串用逗号“,”隔开，连成一串输出。print会依次打印每个字符串，同时，每遇到一个逗号“,”就输出一个空格。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">name = <span class="string">&#x27;bobo&#x27;</span></span><br><span class="line">salary = <span class="number">1000</span></span><br><span class="line"><span class="built_in">print</span>(a,b,name,salary)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sep和end设置:</p>
<ul>
<li>sep表示分隔的符号，默认是一个空格</li>
<li>end表示打印后的结束方式，默认为换行符\n</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &#x27;bobo&#x27;</span><br><span class="line">b = 20</span><br><span class="line">c = 1.123</span><br><span class="line">print(a,b,c,sep=&#x27;+++&#x27;)</span><br></pre></td></tr></table></figure>


<ul>
<li><p>%百分号格式化输出方式（占位符）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name = &#x27;jay&#x27;</span><br><span class="line">print(&#x27;该名同学的姓名是：%s&#x27;%name)</span><br><span class="line"></span><br><span class="line">age = 20</span><br><span class="line">print(&#x27;该名同学的年龄是：%d&#x27;%age)</span><br></pre></td></tr></table></figure></li>
<li><p>格式化符号:</p>
</li>
</ul>
<p><img src="python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/22-1673530566151.png" alt="22"></p>
<h3 id="input输入"><a href="#input输入" class="headerlink" title="input输入"></a>input输入</h3><ul>
<li>input可以获取用户输入，保存成一个字符串。一定要注意，input的返回值是一个字符串类型。哪怕你输入的是个数字1，返回给你的只会是字符串“1”，而不是 整数1。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;enter your name:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;该名同学的名字：%s&#x27;</span>%name)</span><br><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;enter your age:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄：%s&#x27;</span>%age)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li>整型：Python中可以处理任意大小的整数Python 3.x中整数只有int这一种. </li>
</ul>
<p>支持二进制:0b, 八进制0o, 十六进制:0x</p>
<ul>
<li>浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如<code>&#39;hello&#39;</code>和<code>&quot;hello&quot;</code>,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</li>
<li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如<code>3 &lt; 5</code>会产生布尔值<code>True</code>，而<code>2 == 1</code>会产生布尔值<code>False</code>）。</li>
<li>复数型：形如<code>3+5j</code>，跟数学上的复数表示一样，唯一不同的是虚部的<code>i</code>换成了<code>j</code>。实际上，这个类型并不常用，大家了解一下就可以了。</li>
<li>空值: 是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</li>
</ul>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><ul>
<li>通常被称为整型，是正或负整数，不带小数点。例如：1，100，-8080，0，等等。</li>
<li>不同进制的整数<ul>
<li>表示数字的时候，有时我们还会用八进制或十六进制来表示：<ul>
<li>十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2。</li>
<li>八进制用0o前缀和0-7表示，例如0o12</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><p>浮点数也就是小数，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，一般用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p>
</li>
<li><p>```<br>salary = 1.2e5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 布尔类型</span><br><span class="line"></span><br><span class="line">- 真于假、0和1，都是传统意义上的布尔类型。</span><br><span class="line"></span><br><span class="line">- 但在Python语言中，布尔类型只有两个值，True与False。请注意，是英文单词的对与错，并且首字母要**大写**，不能其它花式变型。</span><br><span class="line"></span><br><span class="line">- 所有计算结果返回的结果是**True或者False**的过程都可以称为布尔运算，例如比较运算。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>a = 1 &lt; 2<br>print(a)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- False等同于0，True等同于1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>a = True + True + False + True<br>print(a)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 字符串类型及使用</span><br><span class="line"></span><br><span class="line">- 字符串是由零个或多个字符组成的有限序列。字符串的内容可以包含字母、标点、特殊符号、中文、日文等全世界的所有字符。</span><br><span class="line"></span><br><span class="line">- 在python中字符串是通过单引号`&#x27;&#x27;`或者双引号`&quot;&quot;`标识的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>name = “bobo”<br>addr = ‘BeiJing’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 字符串特性</span><br><span class="line"></span><br><span class="line">  - 字符串是不可变的序列数据类型，不能直接修改字符串本身，和数字类型一样！Python3全面支持Unicode编码，所有的字符串都是Unicode字符串，所以传统Python2存在的编码问题不再困扰我们，可以放心大胆的使用中文。</span><br><span class="line"></span><br><span class="line">  - 字符串属于序列类型，所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">    s = &quot;hello yuan&quot; </span><br></pre></td></tr></table></figure>

<ul>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/26.png" alt="26"></li>
</ul>
</li>
<li><p>序列类型支持的操作：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.索引取值</span></span><br><span class="line">s = <span class="string">&#x27;hello yuan&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切片取值：批量取出多个字符数据。s[start:end],只能取到start到end的前一位区间的字符数据</span></span><br><span class="line">s = <span class="string">&#x27;hello yuan&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">5</span>]) <span class="comment">#hello</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:-<span class="number">1</span>]) <span class="comment">#hello yua</span></span><br><span class="line"><span class="built_in">print</span>(s[:-<span class="number">1</span>]) <span class="comment">#hello yua</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:]) <span class="comment">#hello yuan</span></span><br><span class="line"><span class="comment">#3.in运算符检查某一个元素是否存在于一个序列</span></span><br><span class="line">s = <span class="string">&#x27;hello yuan&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;h&#x27;</span> <span class="keyword">in</span> s)</span><br><span class="line"><span class="comment">#4.支持加法运算:将两个字符串拼接到了一起</span></span><br><span class="line">s1 = <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;bobo&#x27;</span></span><br><span class="line">s3 = s1 + s2 <span class="comment">#字符串的拼接</span></span><br><span class="line"><span class="built_in">print</span>(s3)</span><br><span class="line"><span class="comment">#5.*运算:将字符串叠放多次</span></span><br><span class="line">s1 = <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">s2 = s1 * <span class="number">5</span>  <span class="comment">#字符串重叠拼接</span></span><br><span class="line"><span class="built_in">print</span>(s2)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串运算</p>
<ul>
<li>下表实例变量a值为字符串 “Hello”，b变量值为 “Python”：</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/27.png" alt="27"></li>
</ul>
</li>
<li><p>python转义字符</p>
</li>
</ul>
<p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/28.png" alt="28"></p>
<ul>
<li><p>多行字符串</p>
<ul>
<li>在字符串中，可以使用三引号（三单或三双引号都可以）编写跨行字符串，在其中可以包含换行符、制表符以及其他特殊字符。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;&#x27;&#x27;</span><br><span class="line">    djsfjds</span><br><span class="line">    fhdjskhfjkds</span><br><span class="line">    fdhjskdfh</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串内置方法</p>
<ul>
<li>内置方法有很多，但是我们主要记住如下几个即可：</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/29.png" alt="29"></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello bobo&#x27;</span></span><br><span class="line">s1 = <span class="string">&#x27;bobo123&#x27;</span></span><br><span class="line"><span class="comment">#find的返回值：</span></span><br><span class="line">    <span class="comment">#-1：子串没有存在当前字符串中</span></span><br><span class="line">    <span class="comment">#非-1值：子串存在当前字符串中</span></span><br><span class="line">result = s.find(s1)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello bobo&#x27;</span></span><br><span class="line"><span class="comment">#可以返回指定字符在当前字符串中的下标</span></span><br><span class="line">result = s.index(<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello bobo&#x27;</span></span><br><span class="line"><span class="comment">#将当前字符串中的bobo替换成jay</span></span><br><span class="line">result = s.replace(<span class="string">&#x27;bobo&#x27;</span>,<span class="string">&#x27;jay&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello bobo&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello-bobo-and-jay&#x27;</span></span><br><span class="line"><span class="comment">#split可以根据指定字符切分当前字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.split(<span class="string">&#x27;-&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;www.123@qq.com&#x27;</span></span><br><span class="line"><span class="comment">#split可以根据指定字符切分当前字符串</span></span><br><span class="line"><span class="built_in">print</span>(s.startswith(<span class="string">&#x27;www&#x27;</span>))</span><br></pre></td></tr></table></figure>


<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">321</span></span><br><span class="line">b = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(a + b)    <span class="comment"># 333</span></span><br><span class="line"><span class="built_in">print</span>(a - b)    <span class="comment"># 309</span></span><br><span class="line"><span class="built_in">print</span>(a * b)    <span class="comment"># 3852</span></span><br><span class="line"><span class="built_in">print</span>(a / b)    <span class="comment"># 26.75 除法的结果是浮点数</span></span><br></pre></td></tr></table></figure>

<p>在Python中可以使用<code>type</code>函数对变量的类型进行检查。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">12.345</span></span><br><span class="line">c = <span class="number">1</span> + <span class="number">5j</span></span><br><span class="line">d = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line">e = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))    <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))    <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))    <span class="comment"># &lt;class &#x27;complex&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d))    <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e))    <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>强制转换</p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。 注意和<code>int()</code> 的区别</li>
</ul>
<hr>
<h1 id="重要数据类型"><a href="#重要数据类型" class="headerlink" title="重要数据类型"></a>重要数据类型</h1><h2 id="列表数据类型"><a href="#列表数据类型" class="headerlink" title="列表数据类型"></a>列表数据类型</h2><ul>
<li><p>在实际开发中，经常需要将一组（不只一个）数据存储起来，以便后边的代码使用。列表就是这样的一个数据结构。且列表是Python中最基本也是最常用的数据结构之一。</p>
</li>
<li><p>什么是数据结构呢？</p>
<ul>
<li>通俗来讲，可以将数据结构当做是某种容器，该容器是用来装载或者存储数据的。不同的数据结构决定了对数据不同的组织方式。</li>
<li>那么当数据被装载或者存储到了某个数据结构中后，那么就可以基于该数据结构的特性对数据进行不同形式的处理和运算。</li>
</ul>
</li>
<li><p>列表的创建方式</p>
<ul>
<li>创建一个列表，只要把逗号分隔的不同的数据元素使用<strong>方括号</strong>括起来即可。列表内的元素，可以是其它任意类型的数据，可多层嵌套列表，元素个数无限制。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = [1,2,3,&#x27;four&#x27;,5.5,False]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>列表元素：</p>
<ul>
<li>存储在列表数据结构中的每一个数据被称为列表元素，简称元素。</li>
</ul>
</li>
<li><p>列表索引：</p>
<ul>
<li>列表中的每个元素都被分配一个数字作为索引，用来表示该元素在列表内所排在的位置。第一个元素的索引是0，第二个索引是1，依此类推。</li>
</ul>
</li>
<li><p>列表的内存结构</p>
<ul>
<li>从数据结构角度看，Python的列表是一个可变长度的顺序存储结构，每一个位置存放的都是对象的指针/引用。</li>
<li>比如，对于这个列表 alist = [1, “a”, [11,22], {“k1”:”v1”}]，其在内存内的存储方式是这样的：</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/30.png" alt="30"></li>
</ul>
</li>
<li><p>列表特性：</p>
<ul>
<li>Python的列表是一个<strong>有序可重复</strong>的元素集合，<strong>可嵌套、迭代、修改、分片、追加、删除，成员判断</strong>。</li>
</ul>
</li>
<li><ol>
<li><strong>访问列表内的元素</strong></li>
</ol>
<ul>
<li>列表从0开始为它的每一个元素顺序创建下标索引，直到总长度减一。要访问它的某个元素，以方括号加下标值的方式即可。注意要确保索引不越界，一旦访问的 索引超过范围，会抛出异常。所以，一定要记得最后一个元素的索引是len(list)-1。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3]</span><br><span class="line">print(alist[0])</span><br><span class="line">print(alist[len(alist-1)])</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li><strong>修改元素的值</strong></li>
</ol>
<ul>
<li>直接对元素进行重新赋值</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">alist[3] = &#x27;four&#x27;</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li><strong>删除元素</strong></li>
</ol>
<ul>
<li>使用del语句或者remove(),pop()方法删除指定的元素。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5]</span><br><span class="line">#方式1</span><br><span class="line">del alist[0]</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5]</span><br><span class="line">#方式2：pop(下标)可以将列表中指定元素取出</span><br><span class="line">item = alist.pop(1)</span><br><span class="line">print(&#x27;pop取出的元素为：&#x27;,item)</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5]</span><br><span class="line">#方式3：remove(删除的元素)</span><br><span class="line">alist.remove(5) #将5这个元素从alist中删除</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li><strong>添加元素</strong></li>
</ol>
<ul>
<li>使用append和insert添加元素</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5]</span><br><span class="line">alist.append(666) #可以将一个元素添加到列表的末尾</span><br><span class="line">alist.append([7,8,9])</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5]</span><br><span class="line">alist.insert(2,666) #将元素添加到列表指定的位置</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="5">
<li><strong>列表的特殊操作</strong></li>
</ol>
<ul>
<li>上述讲解的操作都是列表的常规操作，当然除了这些常规的操作列表还有很多有用的其它特殊形式的操作。</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/31.png" alt="31"></li>
</ul>
</li>
<li><ol start="6">
<li><strong>针对列表的常用函数</strong></li>
</ol>
<ul>
<li>Python有很多内置函数，可以操作列表。</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/32.png" alt="32"></li>
</ul>
</li>
<li><p>排序：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1 = [3,8,5,7,6,2,1]</span><br><span class="line">a1.sort() #可以直接基于原始列表进行排序</span><br><span class="line">print(a1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1 = [3,8,5,7,6,2,1]</span><br><span class="line">a2 = sorted(a1) #将a1排序后的结果重新返回到了一个新列表中，不会修改原始的列表</span><br><span class="line">print(a2)</span><br><span class="line">print(a1)</span><br></pre></td></tr></table></figure>

<ul>
<li>列表和字符串的相互转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#字符串转列表</span><br><span class="line">s = &#x27;hello world and dream&#x27;</span><br><span class="line">result = s.split(&#x27; &#x27;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将列表转字符串</span><br><span class="line">alist = [&#x27;hello&#x27;,&#x27;bobo&#x27;,&#x27;and&#x27;,&#x27;you&#x27;]</span><br><span class="line">result = &#x27; &#x27;.join(alist) #使用空格将列表元素拼接成一个完整的字符串</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>


<ul>
<li><p><strong>切片</strong></p>
<ul>
<li><p>切片指的是对序列进行截取，选取序列中的某一段。</p>
<ul>
<li>切片的语法是： list[start:end]</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5]</span><br><span class="line">print(alist[0:3])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>以冒号分割索引，start代表起点索引，end代表结束点索引。省略start表示以0开始，省略end表示到列表的结尾。注意，区间是左闭右开的！也就是说[1:4]会截取列表的索引为1/2/3的3个元素，不会截取索引为4的元素。分片不会修改原有的列表，可以将结果保存到新的变量，因此切片也是一种安全操作，常被用来复制一个列表，例如newlist = lis[:]。</p>
</li>
<li><p>如果提供的是负整数下标，则从列表的最后开始往头部查找。例如-1表示最后一个元素，-3表示倒数第三个元素。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5]</span><br><span class="line">print(alist[0:-1])</span><br></pre></td></tr></table></figure>

<ul>
<li>切片过程中还可以设置步长，以第二个冒号分割，例如list[3:9:2]，表示每隔多少距离取一个元素。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">print(alist[0:9:2])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>列表的内置方法</p>
<ul>
<li>上文中我们说过，数据存储到不同的数据结构中，可以基于该数据结构的特性对数据进行指定形式的操作和处理。下图中的方法是列表专有的内置方法，请熟记于心。</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/33.png" alt="33"></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;i like python and python is great&#x27;</span></span><br><span class="line">alist = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment">#统计python元素在alist列表中出现的次数</span></span><br><span class="line">result = alist.count(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a2 = [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a1.extend(a2) <span class="comment">#将a2列表中的每一个元素以此追加到a1列表的末尾</span></span><br><span class="line"><span class="built_in">print</span>(a1)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.reverse() <span class="comment">#列表元素倒置</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>深浅拷贝是python中经常涉及到一个面试，也是同学们经常出错的地方，那么什么是深浅拷贝呢？</p>
<ul>
<li><p>浅拷贝</p>
<ul>
<li>copy方法: 意思是复制一个相同的列表(赋值出的别表是一块全新的内存空间)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>,<span class="string">&#x27;小白&#x27;</span>]</span><br><span class="line"><span class="comment">#将names列表复制一份赋值给了names2</span></span><br><span class="line">names2 = names.copy()</span><br><span class="line"><span class="built_in">print</span>(names,names2)</span><br><span class="line"><span class="comment">#两个列表的内存地址不一样，names和names2不是同一个列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(names),<span class="built_in">id</span>(names2))</span><br></pre></td></tr></table></figure>

<pre><code>- 把 names 列表中的 小黄改成英文 Yellow，那么 names2 的小黄会发生变化吗？
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>,<span class="string">&#x27;小白&#x27;</span>]</span><br><span class="line"><span class="comment">#将names列表复制一份赋值给了names2</span></span><br><span class="line">names2 = names.copy()</span><br><span class="line"><span class="built_in">print</span>(names,names2)</span><br><span class="line"><span class="comment">#两个列表的内存地址不一样，names和names2不是同一个列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(names),<span class="built_in">id</span>(names2))</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(names2) <span class="comment">#names2的小红还是小红，只有names中的小红被该成了red</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<pre><code>- 其实它的原理很简单，如下图:

- ![Snip20210912_16](Python语言基础/Snip20210912_16.png)

- 首先，names 指向一个列表，然后把 names 复制了一份，赋值给 names2 ，由于 修改的是 第一个 列表的 小黄，所以第二个列表不受影响。

- 那么现在我改一下这个列表，从names列表中再添加一个列表，如下代码
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,[<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>],<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>,<span class="string">&#x27;小白&#x27;</span>]</span><br><span class="line">names2 = names.copy() <span class="comment">#将names复制一份给names2</span></span><br><span class="line">names2[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(names)</span><br><span class="line"><span class="built_in">print</span>(names2)</span><br><span class="line"><span class="comment">#注意：列表中存储的实际上是每一个列表元素的地址，而不是列表元素的值。</span></span><br></pre></td></tr></table></figure>

<pre><code>- 这段代码的运行结果是，两个列表的李四都变成了英文，来分析一下原理

- ![Snip20210912_17](Python语言基础/Snip20210912_17.png)

- 其实这个图也挺简单的，就是中间那个列表是单独分配了一块空间，然后从第一层列表中去引用地址，复制的names2 也是引用的地址，所以真实的值一变，两个列表的内部列表的值也就变了。

- 也就是说 list.copy() 方法只能 copy 一层，这就是所谓的浅复制。
</code></pre>
<ul>
<li>深拷贝</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy <span class="comment">#将copy这个工具箱搬过来</span></span><br><span class="line">names = [<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;小红&#x27;</span>,[<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;王五&#x27;</span>],<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;小黄&#x27;</span>,<span class="string">&#x27;小白&#x27;</span>]</span><br><span class="line">names2 = copy.deepcopy(names) <span class="comment">#将names复制一份给names2</span></span><br><span class="line">names2[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></table></figure>

<ul>
<li>列表的维度：浅拷贝只可以完全拷贝一维列表，如果是多维列表务必使用深拷贝！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">#一维列表</span></span><br><span class="line">a2 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]] <span class="comment">#二维列表</span></span><br><span class="line">a3 = [[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],[[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]] <span class="comment">#三维列表</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="元组数据类型"><a href="#元组数据类型" class="headerlink" title="元组数据类型"></a>元组数据类型</h2><ul>
<li>用方括号括起来的是列表，那么用<strong>圆括号</strong>括起来的就是元组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">t1 = (<span class="number">1</span>,) <span class="comment">#只有一个元素的元组</span></span><br><span class="line">t2 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,(<span class="number">4</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>元组也是序列结构，但是是一种不可变序列，你可以简单的理解为内容不可变的列表<strong>。除了在内部元素不可修改的区别外，元组和列表的用法差不多</strong>。</p>
</li>
<li><p>元组与列表相同的操作：</p>
<ul>
<li><p>使用方括号加下标访问元素</p>
</li>
<li><p>切片（形成新元组对象）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">n_t = t[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(n_t)</span><br></pre></td></tr></table></figure>

<ul>
<li>count()/index()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(t.count(<span class="number">3</span>)) <span class="comment">#返回指定元素的个数</span></span><br><span class="line"><span class="built_in">print</span>(t.index(<span class="number">5</span>)) <span class="comment">#返回指定元素的下标</span></span><br></pre></td></tr></table></figure>

<ul>
<li>len()/max()/min()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">max</span> = t.<span class="built_in">max</span>()</span><br><span class="line"><span class="built_in">min</span> = t.<span class="built_in">min</span>()</span><br><span class="line"><span class="built_in">len</span> = <span class="built_in">len</span>(t)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>元组中不允许的操作，确切的说是元组没有的功能：</p>
<ul>
<li>修改、新增元素</li>
<li>删除某个元素（但可以删除整个元组）</li>
<li>所有会对元组内部元素发生修改动作的方法。例如，元组没有remove，append，pop等方法。</li>
</ul>
</li>
<li><p>元组与列表类似的特殊操作：</p>
</li>
<li><p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/34.png" alt="34"></p>
</li>
<li><p>提问：</p>
<ul>
<li><p>在学完列表后，在使用元素我们会发现元组由于是一个不可变序列，则很多操作会受到限制，这不能，那不能，要你何用，我直接用列表不行吗？</p>
</li>
<li><p>还是有用的，有些数据一旦创建之后就不允许修改了，这些数据就适合用元组来创建，比如主机地址和端口（ip，port），（”192.168.1.1”， 80），两者捆绑在一起，不允许修改。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ip_port = (<span class="string">&quot;192.168.1.1&quot;</span>, <span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>元组看来是很安全的。但真的吗？</p>
<ul>
<li><p>实则不然，注意：元组只保证它的一级子元素不可变，对于嵌套的元素内部，不保证不可变！</p>
<ul>
<li>所以，在使用元组的时候，请尽量使用数字、字符串和元组这种不可变的数据类型作为元组的元素，这样就能确保元组不发生变化。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>)</span><br><span class="line">t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;four&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(t) <span class="comment">#可变</span></span><br><span class="line"></span><br><span class="line">t1 = (<span class="number">1</span>,<span class="number">2</span>,(<span class="number">4</span>,<span class="number">5</span>),<span class="number">5</span>)</span><br><span class="line">t1[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;five&#x27;</span> <span class="comment">#不可行</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="字典数据类型"><a href="#字典数据类型" class="headerlink" title="字典数据类型"></a>字典数据类型</h2><ul>
<li><p>字典的实现机制：</p>
</li>
<li><p>Python的字典数据类型是基于hash散列算法实现的，采用键值对(key:value)的形式，根据key的值计算value的地址，具有非常快的查取和插入速度。</p>
</li>
<li><p>字典特性：</p>
<ul>
<li>字典包含的元素个数不限，值的类型可以是任何数据类型！但是字典的key必须是不可变的对象，例如整数、字符串、bytes和元组，最常见的还是将字符串作为key。列表、字典、集合等就不可以作为key。同时，同一个字典内的key必须是唯一的，但值则不必。</li>
<li>注意：从Python3.6开始，字典是有序的！它将保持元素插入时的先后顺序！请务必清楚！</li>
</ul>
</li>
<li><p>创建字典</p>
<ul>
<li><p>字典的每个键值对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ，例如：</p>
<ul>
<li>d = {key1 : value1, key2 : value2 }</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    &#x27;name&#x27;:&#x27;bobo&#x27;,</span><br><span class="line">    &#x27;age&#x27;:20,</span><br><span class="line">    &#x27;score&#x27;:[99.88]</span><br><span class="line">&#125;</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>访问字典</p>
<ul>
<li>虽然现在的字典在访问时有序了，但字典依然是集合类型，不是序列类型，因此没有索引下标的概念，更没有切片的说法。但与list类似的地方是，字典采用把相应的键放入方括号内获取对应值的方式取值。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:[<span class="number">100</span>,<span class="number">99</span>,<span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:&#123;<span class="string">&#x27;zhangsan&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(dic[<span class="string">&#x27;address&#x27;</span>]) <span class="comment">#通过中括号的机制取value值</span></span><br><span class="line"><span class="built_in">print</span>(dic.get(<span class="string">&#x27;age&#x27;</span>)) <span class="comment">#通过调用get取value值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过中括号访问value值和通过get访问value值得区别是什么？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:[<span class="number">100</span>,<span class="number">99</span>,<span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:&#123;<span class="string">&#x27;zhangsan&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># print(dic[&#x27;hobby&#x27;]) #使用了不存在的key程序会报错</span></span><br><span class="line"><span class="built_in">print</span>(dic.get(<span class="string">&#x27;hobby&#x27;</span>)) <span class="comment">#使用get访问了不存在的key只会返回一个None，不会报错</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加和修改</p>
<ul>
<li>增加就是往字典插入新的键值对，修改就是给原有的键赋予新的值。由于一个key只能对应一个值，所以，多次对一个key赋值，后面的值会把前面的值冲掉。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:[<span class="number">100</span>,<span class="number">99</span>,<span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:&#123;<span class="string">&#x27;zhangsan&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">dic[<span class="string">&#x27;salary&#x27;</span>] = <span class="number">10000</span> <span class="comment">#直接给一个不存在的key赋值，就表示向字典中增加了一个键值对</span></span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:[<span class="number">100</span>,<span class="number">99</span>,<span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:&#123;<span class="string">&#x27;zhangsan&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">dic[<span class="string">&#x27;age&#x27;</span>] = <span class="number">100</span> <span class="comment">#直接给一个存在的key赋值，就表示修改了字典中的一个键值对</span></span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除字典元素、清空字典和删除字典</p>
</li>
<li><p>使用del关键字删除字典元素或者字典本身，使用字典的clear()方法清空字典。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:[<span class="number">100</span>,<span class="number">99</span>,<span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:&#123;<span class="string">&#x27;zhangsan&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">del</span> dic[<span class="string">&#x27;age&#x27;</span>] <span class="comment">#删除了age表示的键值对</span></span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:[<span class="number">100</span>,<span class="number">99</span>,<span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:&#123;<span class="string">&#x27;zhangsan&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">dic.clear() <span class="comment">#清空字典中所有的键值对</span></span><br><span class="line"><span class="built_in">print</span>(dic) </span><br></pre></td></tr></table></figure>

<ul>
<li>字典的重要方法<ul>
<li>下表中列出了字典的重要内置方法。其中的get、items、keys和values是核心中的核心，必须熟练掌握！</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/35.png" alt="35"></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;score&#x27;</span>:[<span class="number">100</span>,<span class="number">99</span>,<span class="number">80</span>],</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:&#123;<span class="string">&#x27;zhangsan&#x27;</span>:<span class="string">&#x27;beijing&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>:<span class="string">&#x27;shanghai&#x27;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(dic.items()) <span class="comment">#返回字典中所有的元素</span></span><br><span class="line"><span class="built_in">print</span>(dic.keys()) <span class="comment">#返回字典中所有的key</span></span><br><span class="line"><span class="built_in">print</span>(dic.values())<span class="comment">#返回字典中所有的value值</span></span><br><span class="line">result = dic.pop(<span class="string">&#x27;age&#x27;</span>) <span class="comment">#可以将字典中指定的键值对取出且返回</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">dic1 = &#123;</span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>:<span class="string">&#x27;三年六班&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;teacher&#x27;</span>:<span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">dic.update(dic1)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>遍历字典</p>
<ul>
<li>从Python3.6开始遍历字典获得的键值对是有序的！以下的遍历方法必须全部熟练掌握</li>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/36.png" alt="36"></li>
</ul>
</li>
</ul>
<h2 id="bytes字节类型-二进制类型"><a href="#bytes字节类型-二进制类型" class="headerlink" title="bytes字节类型/二进制类型"></a>bytes字节类型/二进制类型</h2><ul>
<li>在Python3以后，字符串和bytes类型彻底分开了。字符串是以字符为单位进行处理的，bytes类型是以字节为单位处理的。</li>
<li>bytes数据类型在所有的操作和使用甚至内置方法上和字符串数据类型基本一样，也是不可变的序列对象。</li>
<li>作用<ul>
<li>bytes对象只负责以二进制字节序列的形式记录所需记录的对象。Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等</li>
</ul>
</li>
<li>创建方式<ul>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/37.png" alt="37"></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bs = <span class="string">b&#x27;hello world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(bs))</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串和bytes类型的数据相互转换</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bs = <span class="string">b&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">#将bytes类型的数据转换成字符串类型的数据</span></span><br><span class="line">ss = bs.decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ss))</span><br><span class="line"><span class="comment">#将字符串类型的数据转换成bytes类型</span></span><br><span class="line">bss = ss.encode()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(bss))</span><br></pre></td></tr></table></figure>

<h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><ul>
<li><p>特性</p>
<ul>
<li>set集合是一个==无序不重复==元素的容器，集合数据类型的核心在于自动去重。</li>
</ul>
</li>
<li><p>创建方式</p>
<ul>
<li>集合使用大括号{}框定元素，并以逗号进行分隔。但是注意：如果要创建一个空集合，必须用 set() 而不是 {} ，因为后者创建的是一个空字典。集合除了在形式上最外层用的也是花括号外，其它的和字典没有一毛钱关系。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s ad &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>]) <span class="comment">#会报错，因为set集合没有下标的机制</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>应用</p>
<ul>
<li>对于字符串，集合会把它一个一个拆开，然后去重</li>
<li>通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果</li>
<li>可以通过update()方法，将另一个对象更新到已有的集合中，这一过程同样会进行去重。</li>
<li>通过remove(key)方法删除指定元素，或者使用pop()方法。注意，集合的pop方法无法设置参数，删除指定的元素</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">s = &#123;<span class="number">9</span>,<span class="number">0</span>&#125;</span><br><span class="line">s.update(alist)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">s2=&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">#集合关系的运算</span></span><br><span class="line"><span class="comment">#求交集 </span></span><br><span class="line"><span class="built_in">print</span>(s1.intersection(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 &amp; s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#求并集</span></span><br><span class="line"><span class="built_in">print</span>(s1.union(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 | s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#求差集</span></span><br><span class="line"><span class="built_in">print</span>(s1.differet(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 - s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#差并补</span></span><br><span class="line"><span class="built_in">print</span>(s1.symmetric_differet(s2))</span><br><span class="line"><span class="built_in">print</span>(s1 ^ S2)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意：</p>
<ul>
<li>集合既不支持下标索引也不支持字典那样的通过键获取值。</li>
</ul>
</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>可变类型：列表，字典，set集合</li>
<li>不可变类型：数字类型，布尔类型，字符串，元组，bytes类型</li>
</ul>
<hr>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul>
<li><p>流程控制指的是代码运行逻辑、<strong>分支走向、循环控制</strong>，是真正体现程序执行顺序的操作。</p>
</li>
<li><p>流程控制的组成</p>
<ul>
<li>流程控制一般分为顺序执行、条件判断和循环控制。</li>
</ul>
</li>
<li><p>伪代码</p>
<ul>
<li>伪代码(Pseudocode)是一种算法描述语言。使用伪代码的目的是使被描述的算法可以容易地以任何一种编程语言实现。因此，伪代码必须结构清晰、代码简单、可读性好，并且类似自然语言。 通俗简单地讲，就是用中文把你的程序先写出来，在检查过伪代码没有问题后，再用Python等语言将其真正实现。</li>
</ul>
<p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/38.png" alt="38"></p>
</li>
</ul>
<p>上图中就是一组典型的流程控制操作，很明确的阐述了编程中的因果关系，同一个输入不管执行多少次必然会得到同样的输出结果。</p>
<h2 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h2><ul>
<li>顾名思义，就是根据编写程序的上下顺序依次执行或者说是自上而下逐行顺序执行。</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul>
<li><p>顺序结构的程序虽然能解决计算、输出等问题，但不能做判断再选择。对于要先做判断再选择的问题就要使用分支结构。</p>
</li>
<li><p>单分支语句</p>
<ul>
<li>语法：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 表达式:</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>说明：</p>
<p>1、“表达式”可以是一个单一的值或者复杂语句，形式不限，但解释器最后会通过<code>bool</code>获取一个<code>true</code>或者<code>false</code>的布尔值</p>
<p>2、“代码块”由：与具由相同缩进标识的若干条语句组成（一般是四个缩进）。</p>
</blockquote>
<p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/39.png" alt="39"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;enter your age:&#x27;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age) <span class="comment">#将字符串形式的age转换成了数字类型</span></span><br><span class="line"><span class="keyword">if</span> age &gt; <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;成年&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;over!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>双分支语句</p>
<ul>
<li>双分支语句顾名思义，二条分支二选一执行！语法格式：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 表达式：</span><br><span class="line">    代码块 1</span><br><span class="line">else：</span><br><span class="line">    代码块 2</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/40.png" alt="40"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;enter a age:&#x27;</span>)<span class="comment">#age是一个字符串类型</span></span><br><span class="line"><span class="comment">#将字符串类型的age转换成整形</span></span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>: <span class="comment">#if后面的表达式返回True说明该条件成立，否则说明该条件不成立</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;成年&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;未成年&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>多分支语句</p>
<ul>
<li>多分支即从比双分支更多的分支选择一支执行。语法格式：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 表达式 1：</span><br><span class="line">    代码块 1</span><br><span class="line">elif 表达式 2：</span><br><span class="line">    代码块 2</span><br><span class="line">elif 表达式 3：</span><br><span class="line">    代码块 3</span><br><span class="line">...# 其它elif语句</span><br><span class="line">else：</span><br><span class="line">    代码块 n</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/41.png" alt="41"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&#x27;enter a age:&#x27;</span>)<span class="comment">#age是一个字符串类型</span></span><br><span class="line"><span class="comment">#将字符串类型的age转换成整形</span></span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>: <span class="comment">#if后面的表达式返回True说明该条件成立，否则说明该条件不成立</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;成年&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">12</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;未成年&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">8</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;儿童&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;婴儿&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>案例:猜数字游戏</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种写法</span></span><br><span class="line">true_num = <span class="number">9</span> <span class="comment">#标准答案</span></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&#x27;please guess a num:&#x27;</span>)</span><br><span class="line">num = <span class="built_in">int</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户猜数字只有三种可能：猜对了，猜小了和猜大了</span></span><br><span class="line"><span class="keyword">if</span> num == true_num:<span class="comment">#猜对了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;恭喜您，猜对了！&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:<span class="comment">#包含了用户猜大了和猜小了两种可能</span></span><br><span class="line">    <span class="comment"># print(&#x27;猜错了&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; true_num:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:<span class="comment">#只剩下一种可能：猜大了</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;一轮游戏结束！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第二种写法：</span></span><br><span class="line">true_num = <span class="number">9</span> <span class="comment">#标准答案</span></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&#x27;please guess a num:&#x27;</span>)</span><br><span class="line">num = <span class="built_in">int</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户猜数字只有三种可能：猜对了，猜小了和猜大了</span></span><br><span class="line"><span class="keyword">if</span> num == true_num:<span class="comment">#猜对了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;恭喜您，猜对了！&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num &lt; true_num:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;一轮游戏结束！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。</p>
<p>Python语言中的循环语句支持 while循环（条件循环）和for循环（遍历循环）。</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 表达式:</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/42.png" alt="42"></p>
</li>
<li><p>案例：循环打印十遍”hello world”</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world!&#x27;</span>)</span><br><span class="line">    <span class="comment">#步进语句</span></span><br><span class="line">    i += <span class="number">1</span>  <span class="comment">#i = i + 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>让猜数字游戏多次执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">true_num = <span class="number">9</span> <span class="comment">#标准答案</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    num = <span class="built_in">input</span>(<span class="string">&#x27;please guess a num:&#x27;</span>)</span><br><span class="line">    num = <span class="built_in">int</span>(num)</span><br><span class="line">    <span class="comment">#用户猜数字只有三种可能：猜对了，猜小了和猜大了</span></span><br><span class="line">    <span class="keyword">if</span> num == true_num:<span class="comment">#猜对了</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;恭喜您，猜对了！&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> num &lt; true_num:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line">    i += <span class="number">1</span> <span class="comment">#步进语句</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;一轮游戏结束！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>案例：求解1-3累加和</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#案例：求解1-3累加和</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span> <span class="comment">#保存累加后的结果</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次循环结束：sum = 1  i = 2</span></span><br><span class="line"><span class="comment">#第二次循环结束：sum = 3  i = 3</span></span><br><span class="line"><span class="comment">#第三次循环结束：sum = 6  i = 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>想要计算n！(5! = 5 * 4 * 3 * 2 * 1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="number">1</span> <span class="comment">#前n个数的积</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">5</span>:</span><br><span class="line">    s = s * i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">input</span>(<span class="string">&#x27;您想要计算几的阶乘呢，请录入：&#x27;</span>)</span><br><span class="line">x = <span class="built_in">int</span>(x)</span><br><span class="line"></span><br><span class="line">s = <span class="number">1</span> <span class="comment">#前n个数的积</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= x:</span><br><span class="line">    s = s * i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>

<ul>
<li>找出1-100之间所有的偶数,将其存储到一个列表中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找出1-100之间所有的偶数,将其存储到一个列表中</span></span><br><span class="line">alist = [] <span class="comment">#存放所有符合条件的偶数</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="comment">#判断偶数</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:<span class="comment">#i可以被2整除</span></span><br><span class="line">        alist.append(i) <span class="comment">#将偶数添加到指定的列表中</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul>
<li>语法格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 迭代变量 in 字符串|列表|元组|字典|集合：</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure>

<ul>
<li>格式中，迭代变量用于存放从序列类型变量中读取出来的元素，所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">#item变量不需要提前声明/定义</span></span><br><span class="line"><span class="comment">#循环次数取决于in后面那个数据结构中元素的个数</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> alist: <span class="comment">#遍历列表元素</span></span><br><span class="line">    <span class="built_in">print</span>(item) <span class="comment">#循环体</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">#item变量不需要提前声明/定义</span></span><br><span class="line"><span class="comment">#循环次数取决于in后面那个数据结构中元素的个数</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> alist: <span class="comment">#遍历列表元素</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">#循环体</span></span><br></pre></td></tr></table></figure>

<ul>
<li>计算1-5之和</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> alist:</span><br><span class="line">    <span class="built_in">sum</span> += item</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;bobo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;address&#x27;</span>:<span class="string">&#x27;Bj&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#keys返回的是一个列表，列表中存储的是字典中所有的key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic.keys():</span><br><span class="line">    <span class="built_in">print</span>(dic[key])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic.items():</span><br><span class="line">    <span class="built_in">print</span>(key,value)</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;hello bobo&#x27;</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>如果遍历一个数据结构，则最好使用for循环</li>
<li>如果一个需求循环次数不确定最好使用while</li>
<li>如果一个需求循环次数确定最好使用for</li>
</ul>
</li>
</ul>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><ul>
<li><p>永远都不会结束的循环。</p>
</li>
<li><p>但有我们是会需要无限循环。例如Web服务器响应客户端的实时请求。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="keyword">pass</span> <span class="comment">#循环体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">pass</span> <span class="comment">#循环体</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h4><ul>
<li>if判断可以嵌套，while和for当然也可以嵌套。但是建议大家不要嵌套3层以上，那样的效率会很低。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看下述的print会被循环执行多少次</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello world!&#x27;</span>) <span class="comment">#会被打印6次</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> alist:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">#重复执行25次</span></span><br></pre></td></tr></table></figure>

<h4 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h4><p>如果想提前结束循环（在不满足结束条件的情况下结束循环），可以使用break或continue关键字。</p>
<ul>
<li><p>break</p>
<ul>
<li>通常情况下的循环要么执行出错，要么死循环，要么就只能老老实实等它把所有的元素循环一遍才能退出。如果想在循环过程中退出循环，怎么办？用break语句！</li>
<li>break只能用于循环体内。其效果是直接结束并退出当前循环，剩下的未循环的工作全部被忽略和取消。注意当前两个字，Python的break只能退出一层循环，对于多层嵌套循环，不能全部退出。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">#终止整个循环</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>continue</p>
<ul>
<li>与break不同，continue语句用于跳过当前循环的剩余部分代码，直接开始下一轮循环。它不会退出和终止循环，只是提前结束当前轮次的循环。同样的，continue语句只能用在循环内。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment">#结束当次循环，开始下一次新的循环</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：break和continue只可以作用在离其最近的那一层循环中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> alist:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="else从句"><a href="#else从句" class="headerlink" title="else从句"></a>else从句</h4><ul>
<li><p>while的else从句</p>
<ul>
<li>while循环还可以增加一个else从句。当while循环正常执行完毕，会执行else语句。但如果是被break等机制强制提前终止的循环，不会执行else语句。注意else与while平级的缩进方式！</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment">#只有当循环被正常结束，才会执行else从句</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;while循环正常结束！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>for的else从句</p>
<ul>
<li>与while一样，for循环也可以有else子句。同样是正常结束循环时，else子句执行。被中途break时，则不执行。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;for循环正常结束！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>1.实现完整的猜数字游戏：</p>
<p>规则如下：</p>
<p>​    可以不间断的进行猜数字游戏环节，找到猜对了，结束程序，猜不对，可以不断的进行游戏，并且需要提示用户猜大了还是猜小了。</p>
<p>拓展功能实现：</p>
<p>​    1.最后需要统计出，用户猜了多少次才猜对。</p>
<p>​    2.每一个用户的初始分数为100，每猜错一次扣5分，最后程序结束，统计用户的得分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">score = <span class="number">100</span> <span class="comment">#初始分值</span></span><br><span class="line">count = <span class="number">0</span> <span class="comment">#用来统计循环了多少次</span></span><br><span class="line"><span class="comment">#随机产生一个1-100之间的数字</span></span><br><span class="line">num = <span class="built_in">int</span>(random.random() * <span class="number">100</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    guessNum = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;enter a num:&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> guessNum == num:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜对了&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> guessNum &lt; num:</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="number">0</span>:</span><br><span class="line">            score -= <span class="number">5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜小了&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="number">0</span>:</span><br><span class="line">            score -= <span class="number">5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;猜大了&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;一共猜了%d次,总得分为：%d&#x27;</span>%(count,score))</span><br></pre></td></tr></table></figure>



<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul>
<li><p>冒泡排序</p>
<ul>
<li>1.将序列中的元素两两比较，然后实现将序列中的最大值逐一偏移到序列的末尾位置。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">        <span class="comment">#将两个元素交换位置</span></span><br><span class="line">        alist[i],alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>],alist[i]</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li>2.将上述步骤1的核心操作重复执行n次就可以实现有序效果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)-<span class="number">1</span>-j):</span><br><span class="line">        <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="comment">#将两个元素交换位置</span></span><br><span class="line">            alist[i],alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>],alist[i]</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>选择排序</p>
<ul>
<li>1.将序列中的元素两两比较，找出最大值，将最大值和序列中最后一个元素交换位置。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [3,8,5,7,6]</span><br><span class="line">#一开始假设最大值的小标为0</span><br><span class="line">max_index = 0 #保存最大元素的小标</span><br><span class="line">for i in range(len(alist)-1):#i的取值为0，1，2，3</span><br><span class="line">    if alist[max_index] &lt; alist[i+1]:</span><br><span class="line">        max_index = i+1</span><br><span class="line"></span><br><span class="line">alist[max_index],alist[len(alist)-1] =  alist[len(alist)-1],alist[max_index]</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li>将上述步骤1的核心操作重复执行n次就可以实现有序效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [3,8,5,7,6]</span><br><span class="line">for j in range(len(alist)-1):</span><br><span class="line">    #一开始假设最大值的小标为0</span><br><span class="line">    max_index = 0 #保存最大元素的小标</span><br><span class="line">    for i in range(len(alist)-1-j):#i的取值为0，1，2，3</span><br><span class="line">        if alist[max_index] &lt; alist[i+1]:</span><br><span class="line">            max_index = i+1</span><br><span class="line">    alist[max_index],alist[len(alist)-1-j] =  alist[len(alist)-1-j],alist[max_index]</span><br><span class="line"></span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>插入排序</p>
<ul>
<li>假设将列表分为两部分：<ul>
<li>有序部分：默认情况下，列表的第一个元素为有序部分</li>
<li>无序部分：默认情况下，列表的非第一个元素为无序部分</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3,   8,5,7,6] #初始列表</span><br><span class="line">[3,8,   5,7,6] #第一次插入</span><br><span class="line">[3,5,8,   7,6] #第二次插入</span><br><span class="line">[3,5,7,8,   6] #第三次插入</span><br><span class="line">[3,5,6,7,8   ] #第四次插入</span><br></pre></td></tr></table></figure>

<pre><code>- 定义一个变量i，i的初始值为1.变量i表示的是有序部分的元素个数。

- i = 1的情况：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i = 1</span><br><span class="line">alist = [3,8,5,7,6]</span><br><span class="line">#alist[i]无序部分的第一个元素</span><br><span class="line">#alist[i-1]有序部分最后一个元素</span><br><span class="line">if alist[i] &lt; alist[i-1]:</span><br><span class="line">    alist[i],alist[i-1] = alist[i-1],alist[i]</span><br></pre></td></tr></table></figure>

<pre><code>- i = 2 或者说i&gt;1的情况
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#alist[i]无序部分的第一个元素</span><br><span class="line">#alist[i-1]有序部分最后一个元素</span><br><span class="line">while i &gt; 0:</span><br><span class="line">    if alist[i] &lt; alist[i-1]:</span><br><span class="line">        alist[i],alist[i-1] = alist[i-1],alist[i]</span><br><span class="line">        i -= 1</span><br><span class="line">    else:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<pre><code>- 完整代码：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alist = [3,8,5,7,6,2,1,0]</span><br><span class="line">for i in range(1,len(alist)):</span><br><span class="line">    while i &gt; 0:</span><br><span class="line">        if alist[i] &lt; alist[i-1]:</span><br><span class="line">            alist[i],alist[i-1] = alist[i-1],alist[i]</span><br><span class="line">            i -= 1</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">print(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二分查找</p>
<ul>
<li>只可以作用在有序序列中</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isFind = False</span><br><span class="line">#假设现在查找2是否存在于当前列表中</span><br><span class="line">toFind = input(&#x27;enter a num of you want to find:&#x27;)</span><br><span class="line">toFind = int(toFind)</span><br><span class="line">alist = [1,2,3,4,5,6]</span><br><span class="line">low = 0 #第一个元素下标</span><br><span class="line">high = len(alist)-1 #最后一个元素下标</span><br><span class="line">while low &lt;= high:</span><br><span class="line">    #mid保存中间元素下标</span><br><span class="line">    mid = (low + high) // 2</span><br><span class="line">    #如果条件成立，则可以去中间元素右侧查找</span><br><span class="line">    if toFind &gt; alist[mid]:</span><br><span class="line">        low = mid + 1</span><br><span class="line">    elif toFind &lt; alist[mid]:#查找的元素可能存在中间元素左侧</span><br><span class="line">        high = mid - 1</span><br><span class="line">    else: #中间元素等于查找的元素</span><br><span class="line">        isFind = True</span><br><span class="line">        break</span><br><span class="line">        </span><br><span class="line">print(isFind)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    </p>
<ul>
<li><p>衡量算法性能好坏优劣的指标：</p>
<ul>
<li><p>时间复杂度</p>
<ul>
<li>量化算法执行步骤的数量。</li>
</ul>
</li>
<li><p>例子：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 5  #1</span><br><span class="line">while n &gt; 0: #2n</span><br><span class="line">	print(&#x27;haha&#x27;)</span><br><span class="line">	a -= 1</span><br><span class="line">print(&#x27;over!&#x27;)#1</span><br><span class="line"></span><br><span class="line">#上述算法量化出执行步骤的数量：2+2n</span><br></pre></td></tr></table></figure>

<pre><code>- 时间复杂度最终是通过大O记法来表示：

  - 将量化出的表达式取出最有意义的一项，放入在大O后面的括号中即可。
  - 2+2*n：最优意义的一项是n，该算法就可以表示为：O(n)
</code></pre>
<hr>
<h1 id="函数操作"><a href="#函数操作" class="headerlink" title="函数操作"></a>函数操作</h1><ul>
<li><p>什么是函数？</p>
<ul>
<li>前面在讲解Python数据类型的时候，我们已经接触过函数了。我们说，所谓的函数其实就是Python语言中的一种工具，基于该工具可以完成不同的具体操作。函数可以分为两种，一种是内置函数，另一种是自定义函数，我们可以这么理解：</li>
<li>内置函数：<ul>
<li>内置函数其实就是Python语言的开发者已经给我们设计好的工具，我们可以直接使用这些已经被设计好的工具或者函数完成相关的操作</li>
</ul>
</li>
<li>自定义函数：<ul>
<li>当然，Python语言的开发者们也无法将我们在不同需求中要使用的操作都设计成不同的函数或者工具，那么我们也可以向开发者那样自行设计定制我们专属功能的工具函数。</li>
</ul>
</li>
</ul>
</li>
<li><p>那么，为什么要使用函数呢？</p>
<ul>
<li>第一：<ul>
<li>函数的使用可以重用代码，省去重复性代码的编写，提高代码的重复利用率。如果程序中需要多次使用某种特定的功能，那么只需要编写一个合适的函数就可以了。程序可以在任何需要的地方调用该函数，并且同一个函数可以在不同的程序中调用，就像我们经常使用的print()和input()函数一样。</li>
</ul>
</li>
<li>第二：<ul>
<li>函数能封装内部实现，保护内部数据。很多时候，我们把函数看做“黑盒子”，即对应一定的输入会产生特定的结果或返回某个对象。往往函数的使用者并不是函数的编写者，函数的使用者对黑盒子的内部行为并不需要考虑，可以把精力投入到自身业务逻辑的设计而不是函数的实现细节。只有函数的设计者或者说编写者，才需要考虑函数内部实现的细节，如何暴露对外的接口，返回什么样的数据，也就是API的设计。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><ul>
<li><p>自定义函数的使用要经过两个过程</p>
<ul>
<li>函数的定义（制定）</li>
<li>函数的调用（使用）</li>
</ul>
</li>
<li><p>函数定义语法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def 函数名(参数)：</span><br><span class="line">	#内部代码</span><br><span class="line">	return 表达式</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myFunc</span>(): <span class="comment">#函数定义</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a和b的计算结果为:&#x27;</span>,c)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数调用语法</p>
<ul>
<li><p>函数编写出来就是给人调用的。</p>
</li>
<li><p>要调用一个函数，必须使用函数名后跟圆括号的方式才能调用函数。</p>
</li>
<li><p>调用的同时要根据函数的定义体，提供相应个数和类型的参数，每个参数之间用逗号分隔，否则就会报错。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myFunc() <span class="comment">#函数调用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数定义规范使用</li>
</ul>
<p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/43.png" alt="43"></p>
<ul>
<li>在定义函数的过程中，需要注意以下几点：<ul>
<li>函数代码块以def关键词开头，一个空格之后接函数标识符名称和圆括号()，再接个冒号。</li>
<li>任何传入的参数必须放在圆括号中间。</li>
<li>函数的第一行语句后可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li>使用return结束函数。默认返回None。</li>
<li>return语句依然在函数体内部，不能回退缩进。直到函数的所有代码写完，才回退缩进，表示函数体结束。</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>return语句<ul>
<li>当一个函数被调用结束后，该函数势必已经将一组操作执行结束了，如果在操作执行结束后，想要将一个结果返回给调用者，则就可以使用return语句实现。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#返回一个表达式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myAdd</span>():</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&#x27;enter a num1:&#x27;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&#x27;enter a num 2:&#x27;</span>)</span><br><span class="line">    num1 = <span class="built_in">int</span>(num1)</span><br><span class="line">    num2 = <span class="built_in">int</span>(num2)</span><br><span class="line">    <span class="comment">#return就会将后面的内容返回给函数的调用</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">result = myAdd()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#不写return默认返回None</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myAdd</span>():</span><br><span class="line">    num1 = <span class="built_in">input</span>(<span class="string">&#x27;enter a num1:&#x27;</span>)</span><br><span class="line">    num2 = <span class="built_in">input</span>(<span class="string">&#x27;enter a num 2:&#x27;</span>)</span><br><span class="line">    num1 = <span class="built_in">int</span>(num1)</span><br><span class="line">    num2 = <span class="built_in">int</span>(num2)</span><br><span class="line">    <span class="comment">#注意：如果函数定义中没有写return语句，则该函数默认会返回一个None</span></span><br><span class="line">    <span class="comment">#解释器会自动给函数定义的末尾加上一句代码：return None</span></span><br><span class="line">result = myAdd()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#返回多个结果</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = [<span class="string">&#x27;bobo&#x27;</span>,<span class="string">&#x27;100&#x27;</span>]</span><br><span class="line">    c = <span class="string">&#x27;jay&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a,b,c</span><br><span class="line"><span class="comment">#python的函数可以返回多个结果</span></span><br><span class="line">r1,r2,r3 = func()</span><br><span class="line"><span class="built_in">print</span>(r1,r2,r3)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#return后面的代码无意义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数开始执行&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数正在执行&#x27;</span>)</span><br><span class="line">    <span class="comment">#当一个函数执行到return语句的时候，说明函数调用结束了（return语句后面的代码不会被执行）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;over&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数执行结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line">result = func()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#内部函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在执行outer函数&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():<span class="comment">#内部函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在执行inner函数&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer函数执行结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line"><span class="comment">#执行结果：发现inner函数内部的语句没有被执行</span></span><br><span class="line">	<span class="comment">#正在执行outer函数</span></span><br><span class="line">	<span class="comment">#outer函数执行结束</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如何调用inner这个内部函数呢？</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在执行outer函数&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在执行inner函数&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer函数执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner <span class="comment">#outer将内部函数inner的函数名给返回了</span></span><br><span class="line"><span class="comment">#result == inner</span></span><br><span class="line">result = outer() <span class="comment">#result就是inner（内部函数的函数名），至此result也成为了内部函数的函数名</span></span><br><span class="line">result() <span class="comment">#调用了内部函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#返回函数调用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在执行outer函数&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在执行inner函数&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;outer函数执行结束&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner() <span class="comment">#inner() == 123</span></span><br><span class="line">    <span class="comment">#return 123</span></span><br><span class="line"></span><br><span class="line">result = outer() <span class="comment">#outer() == 123</span></span><br><span class="line"><span class="comment">#result = 123</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<ul>
<li>return可以返回什么<ul>
<li>什么都不返回，仅仅return</li>
<li>数字/字符串/任意数据类型： return ‘hello’</li>
<li>一个表达式：return 1+2</li>
<li>一个判断语句：return 100 &gt; 99</li>
<li>一个变量：return a</li>
<li>一个函数调用：return func()</li>
<li>多个返回值，以逗号分隔：return a, 1+2, “hello”</li>
<li>简而言之，函数可以return几乎任意Python对象。</li>
</ul>
</li>
<li>注意：<ul>
<li>一旦函数执行过程遇到return语句，那么之后函数体内的所有代码都会被忽略，直接跳出函数体。那怕你现在正在一个循环内。</li>
</ul>
</li>
</ul>
<h3 id="基本参数传递"><a href="#基本参数传递" class="headerlink" title="基本参数传递"></a>基本参数传递</h3><ul>
<li><p>参数传递</p>
<ul>
<li><p>函数通常都有参数，用于将外部的实际数据传入函数内部进行处理。但是，在处理不同数据类型的参数时，会有不同的情况发生。这一切都是因为以下两点。</p>
<ul>
<li>Python的函数参数传递的是实际数据的内存地址。</li>
<li>Python的数据类型分可变数据类型和不可变数据类型。</li>
</ul>
</li>
<li><p>例子1：不可变类型参数</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">#a表示的是1这个数据对应内存空间的地址，a是不可变类型数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">b</span>):<span class="comment">#形参，实参给形参的传值(地址)：b = a</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在函数内部修改之前，形参b的内存地址为:%s&#x27;</span>%<span class="built_in">id</span>(b))</span><br><span class="line">    b = <span class="number">2</span> <span class="comment">#将形参b的指向发生了改变</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在函数内部修改之后，形参b的内存地址为:%s&#x27;</span>%<span class="built_in">id</span>(b))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数内部的b为：%s&#x27;</span>%b)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用函数之前，变量a的内存地址为：&#x27;</span>,<span class="built_in">id</span>(a))</span><br><span class="line">func(a) <span class="comment">#a作为实参</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数调动后，函数外部的变量a为:&#x27;</span>,a)</span><br></pre></td></tr></table></figure>

<ul>
<li>例子2：上面例子说的是不可变类型参数，如果是可变类型的，比如列表呢？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">#可变类型的数据结构</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">b</span>): <span class="comment">#形参：b = a</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在函数内部修改之前，变量b的内存地址为:&#x27;</span>,<span class="built_in">id</span>(b))</span><br><span class="line">    b.append(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;在函数内部修改之后，变量b的内存地址为：&#x27;</span>,<span class="built_in">id</span>(b))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数内部的b为：&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;调用函数之前，变量a的内存地址为：&#x27;</span>,<span class="built_in">id</span>(a))</span><br><span class="line">func(a) <span class="comment">#实参</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数外部的变量a为：&#x27;</span>,a)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用函数时将列表对象a的地址传递给了函数内部的变量b。b.append(4)的时候，根据传进来的内存地址，找到[1,2,3]这个列表对象，在它的后面添加了4。</p>
</li>
<li><p>可以看出，此时的a和b实际指向了同一个对象。为什么会这样？因为最关键的b.append(4)这句代码，它不同于“=”赋值语句，不会创建新的变量，而列表作为可变类型，具有append方法，这个方法只是对列表的一种调用而已。因此，a和b实际还是同一个对象。</p>
</li>
</ul>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><ul>
<li><p>绝大多数函数在定义的时候需要接收一定数量的参数，然后根据实际调用时提供的参数的不同，输出不同的结果。注意将函数内部的参数名字，定义得和外部变量的名字一样是一种不好的习惯，它容易混淆思维，甚至发生错误。</p>
</li>
<li><p>参数的两种称谓</p>
<ul>
<li>形参<ul>
<li>函数定义时，制定的参数叫做形参</li>
</ul>
</li>
<li>实参<ul>
<li>函数调用时，传递的参数叫做实参</li>
</ul>
</li>
<li>而我们通常讨论的参数，指的都是形参</li>
</ul>
</li>
<li><p>参数的不同种类</p>
<ul>
<li>定义函数时，参数的名字和位置确定下来，函数的接口就固定了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。Python函数的参数定义灵活度非常大。除了正常定义的位置参数外，还可以使用：<ul>
<li>位置参数</li>
<li>默认参数</li>
<li>动态参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><ul>
<li>也叫必传参数或者顺序参数，是最重要的、也是必须在调用函数时明确提供的参数！位置参数必须按先后顺序，一一对应，个数不多不少的传递！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line"></span><br><span class="line">x = y = <span class="number">5</span></span><br><span class="line">r1 = add(x,y,x)</span><br><span class="line">r2 = add(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(r1,r2)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面例子中的a，b，c就是位置参数，我们在使用add(4, 5, 6)调用时，就是将4的地址传给a，5的传给b，6的传给c的一一对应传递。</p>
<ul>
<li>类似add(4, 5, 6, 7)、add(4)这种“画蛇添足”、“缺胳膊少腿”和“嫁错郎”类型的调用都是错误的。</li>
</ul>
</li>
<li><p>注意: Python在做函数参数传递的时候不会对数据类型进行检查，理论上你传什么类型都可以！</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;haha&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>但是，上面的add函数，如果你传递了一个字符串和两个数字，结果是弹出异常，因为字符串无法和数字相加。</p>
<ul>
<li>这就是Python的弱数据类型和动态语言的特点。在简单、方便的时候，需要你自己去实现数据类型检查。</li>
</ul>
</li>
</ul>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><ul>
<li>在函数定义时，如果给某个参数提供一个默认值，这个参数就变成了默认参数，不再是位置参数了。在调用函数的时候，我们可以给默认参数传递一个自定义的值，也可以使用默认值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x,n=<span class="number">2</span></span>): <span class="comment">#x是位置参数，n是默认参数</span></span><br><span class="line">    <span class="keyword">return</span> x * n</span><br><span class="line"></span><br><span class="line">power(<span class="number">10</span>)</span><br><span class="line">power(<span class="number">10</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面例子中的n就是个默认参数。默认参数可以简化函数的调用，在为最常用的情况提供简便调用的同时，还可以在特殊情况时传递新的值。</p>
</li>
<li><p>默认参数的注意事项：</p>
<ul>
<li>默认参数必须在位置参数后面！</li>
<li>使用参数名传递参数</li>
<li>使用不可变的数据类型作为默认值！</li>
</ul>
</li>
<li><p><strong>默认参数必须在位置参数后面</strong></p>
<ul>
<li>如果你违反了这点，在语法层面直接是通不过的。</li>
<li>当有多个默认参数的时候，通常将更常用的放在前面，变化较少的放后面。</li>
<li>在调用函数的时候，尽量给实际参数提供默认参数名。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student</span>(<span class="params">name,sex,age,classroom=<span class="string">&#x27;101&#x27;</span>,tel=<span class="string">&#x27;1323333333&#x27;</span>,address=<span class="string">&#x27;...&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">student(<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">17</span>) <span class="comment">#可以</span></span><br><span class="line">student(<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;male&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;102&#x27;</span>,<span class="string">&#x27;666&#x27;</span>,<span class="string">&#x27;Beijing&#x27;</span>) <span class="comment">#可以</span></span><br><span class="line">student(<span class="string">&#x27;marry&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;102&#x27;</span>,address=<span class="string">&#x27;SH&#x27;</span>) <span class="comment">#可以</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student(<span class="string">&#x27;mary&#x27;</span>,<span class="string">&#x27;female&#x27;</span>,address=<span class="string">&#x27;Bj&#x27;</span>,<span class="number">18</span>)   <span class="comment">#  这是错误的参数传递方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用参数名传递参数</p>
<ul>
<li>通常我们在调用函数时，位置参数都是按顺序先后传入,而且必须在默认参数前面。但如果在位置参数传递时，给实参指定位置参数的参数名，那么位置参数也可以不按顺序调用</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student(name=<span class="string">&#x27;mary&#x27;</span>,sex=<span class="string">&#x27;female&#x27;</span>,address=<span class="string">&#x27;Bj&#x27;</span>,age=<span class="number">18</span>)   <span class="comment">#  这是错误的参数传递方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>默认参数尽量指向不变的对象</p>
<ul>
<li>首先先来看一道面试真题：输出程序运行后的结果</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a=[]</span>): <span class="comment">#将可变类型数据作为了默认参数的默认值</span></span><br><span class="line">    a.append(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func()) </span><br><span class="line"><span class="built_in">print</span>(func()) </span><br><span class="line"><span class="built_in">print</span>(func()) </span><br></pre></td></tr></table></figure>

<ul>
<li><p>解释：</p>
<ul>
<li>因为Python函数体在被读入内存的时候，默认参数a指向的空列表对象就会被创建，并放在内存里了。因为默认参数a本身也是一个变量，保存了指向对象[]的地址。每次调用该函数，往a指向的列表里添加一个A。a没有变，始终保存的是指向列表的地址，变的是列表内的数据！</li>
</ul>
</li>
</ul>
<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><ul>
<li><p>顾名思义，动态参数就是传入的参数的个数是动态的，可以是1个、2个到任意个，还可以是0个。在不需要的时候，你完全可以忽略动态函数，不用给它传递任何值。</p>
</li>
<li><p>Python的动态参数有两种，分别是：</p>
<ul>
<li>*args</li>
<li>**kwargs</li>
<li>这里面的关键是一个和两个星号的区别，而不是args和kwargs在名字上的区别</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>动态参数，必须放在所有的位置参数和默认参数后面！</li>
</ul>
</li>
<li><p>*args</p>
</li>
<li><p>一个星号表示接收任意个参数。调用时，会将实际参数打包成一个元组传入形式参数。如果参数是个列表，会将整个列表当做一个参数传入。例如：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args</span>):<span class="comment">#动态参数</span></span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(param) <span class="comment">#param就是接收到的每一个参数</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题：</p>
<ul>
<li>通过循环args，我们可以获得传递的每个参数。但是li这个列表，我们本意是让它内部的1,2,3分别当做参数传递进去，但实际情况是列表本身被当做一个整体给传递进去了。怎么办呢？</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(param)</span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">func(li)</span><br></pre></td></tr></table></figure>

<pre><code>  - 解决：

    - **使用一个星号！调用函数，传递实参时，在列表前面添加一个星号就可以达到目的了。**实际情况是，不光列表，任何序列类型数据对象，比如字符串、元组都可以通过这种方式将内部元素逐一作为参数，传递给函数。而字典，则会将所有的key逐一传递进去。
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(param)</span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">func(*li)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>**kwargs</p>
<ul>
<li>两个星表示接受键值对的动态参数，数量任意。调用的时候会将实际参数打包成字典。例如：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">func(k1=<span class="number">1</span>,age=<span class="number">2</span>,k3=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题：</p>
<ul>
<li>而如果我们这样传递一个字典dic呢？我们希望字典内的键值对能够像上面一样被逐一传入。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;k3&#x27;</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">func(d = dic)</span><br></pre></td></tr></table></figure>

<pre><code>- 上述程序实际结果却是弹出错误，为什么？

- 解释：

  - 因为这时候，我们其实是把dic当做一个位置参数传递给了func函数。而func函数并不接收任何位置函数。那怎么办呢？使用两个星号！
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="string">&#x27;k3&#x27;</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">func(**dic)</span><br></pre></td></tr></table></figure>

<pre><code>- 有了前面一个星号的基础，这里我们应该很好理解了。两个星号能将字典内部的键值对逐一传入**kwargs。
</code></pre>
<ul>
<li><p>万能参数</p>
<ul>
<li>当<em>args和**kwargs组合起来使用，理论上能接受任何形式和任意数量的参数，在很多代码中我们都能见到这种定义方式。需要注意的是，</em>args必须出现在**kwargs之前。</li>
</ul>
</li>
</ul>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ul>
<li><p>讲到了函数就必须介绍变量的作用域相关。</p>
<ul>
<li>作用域指的是变量的有效范围。变量并不是在哪个位置都可以访问的，访问权限取决于这个变量是在哪里赋值的，也就是在哪个作用域内赋的值。变量在哪个作用域内赋值，则表示该变量的作用域就是该区域，变量只可以在其作用域指定区域被访问。</li>
</ul>
</li>
<li><p>通常而言，在编程语言中，变量的作用域从代码结构形式来看，有块级、函数、类、模块、包等由小到大的级别。但是在Python中，没有块级作用域，也就是类似if语句块、for语句块、while语句块，with上下文管理器等等是不存在作用域概念的，他们等同于普通的语句。</p>
</li>
</ul>
<p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/44.png" alt="44"></p>
<ul>
<li><p>核心：</p>
<ul>
<li>通常，函数内部的变量无法被函数外部访问，但内部可以访问；类内部的变量无法被外部访问，但类的内部可以。通俗来讲，就是内部代码可以访问外部变量，而外部代码通常无法访问内部变量。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    name = <span class="string">&#x27;bobo&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(age,name)<span class="comment">#函数内部可以访问外部变量</span></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(name) <span class="comment">#在函数外部是无法访问函数内部变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;i am inner&#x27;</span>)</span><br><span class="line">    inner() <span class="comment">#在函数内部可以调用inner</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">inner() <span class="comment">#在函数外部不可以调用inner，因为超出了inner的作用域</span></span><br></pre></td></tr></table></figure>

<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><ul>
<li><p>局部变量</p>
<ul>
<li>定义在函数内部的变量拥有一个局部作用域，被叫做局部变量</li>
</ul>
</li>
<li><p>全局变量</p>
<ul>
<li>定义在函数外的拥有全局作用域的变量，被称为全局变量。（类、模块等同理）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">123</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    email = <span class="string">&#x27;www.123.com&#x27;</span> <span class="comment">#局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(email,num)</span><br><span class="line">func()</span><br><span class="line"><span class="comment">#全局变量在全局区域都可以被访问</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li>所谓的局部变量是相对的。局部变量也有可能是更小范围内的变量的外部变量。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    b = <span class="number">2</span> <span class="comment">#局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(a) <span class="comment">#全局变量可以在全局区域被访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        c = <span class="number">3</span> <span class="comment">#更局部的变量</span></span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">        <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">result = func()</span><br><span class="line">result()</span><br></pre></td></tr></table></figure>

<h4 id="global关键字"><a href="#global关键字" class="headerlink" title="global关键字"></a>global关键字</h4><ul>
<li>先来看一个例子</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = <span class="number">0</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">arg1,arg2</span>):</span><br><span class="line">    total = arg1 + arg2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数内的局部变量total=&#x27;</span>,total)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数内的total的地址是：&#x27;</span>,<span class="built_in">id</span>(total))</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">plus(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数外部全局变量total=&#x27;</span>,total)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数外部变量total的地址：&#x27;</span>,<span class="built_in">id</span>(total))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>很明显，函数plus内部通过total = arg1 + arg2语句，新建了一个局部变量total，它和外面的全局变量total是两码事。而如果我们，想要在函数内部修改外面的全局变量total呢？使用global关键字！</p>
</li>
<li><p>global：</p>
<ul>
<li>指定当前变量使用外部的全局变量</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = <span class="number">0</span> <span class="comment">#全局变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">arg1,arg2</span>):</span><br><span class="line">    <span class="keyword">global</span> total <span class="comment">#在函数内部引用了外部的全局变量total</span></span><br><span class="line">    total = arg1 + arg2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数内的局部变量total=&#x27;</span>,total)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;函数内的total的地址是：&#x27;</span>,<span class="built_in">id</span>(total))</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">plus(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数外部全局变量total=&#x27;</span>,total)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数外部变量total的地址：&#x27;</span>,<span class="built_in">id</span>(total))</span><br></pre></td></tr></table></figure>

<h3 id="函数其他"><a href="#函数其他" class="headerlink" title="函数其他"></a>函数其他</h3><p>我们将函数涉及到的其他几点进行讲解</p>
<ul>
<li>range()函数</li>
<li>递归函数</li>
<li>匿名函数</li>
</ul>
<h4 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h4><ul>
<li><p>range函数是内置函数，无须特别导入，在任何地方都可以直接使用它，下面看一下具体用法：</p>
</li>
<li><p>1.提供一个数字参数，直接遍历数字：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>只给一个数字类型参数，range会遍历从0到参数减1的数字。要特别注意，range默认从0开始，到参数减1，也就是左闭右开的规则，这也是Python很多地方的规则，比如切片。</p>
</li>
<li><p>2.也可以指定遍历的区间：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<ul>
<li>3.还可以指定步长，就像切片一样</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<ul>
<li>4.但更多的时候是结合range和len函数，遍历一个序列的索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alist)):</span><br><span class="line">    <span class="built_in">print</span>(alist[i])</span><br></pre></td></tr></table></figure>

<ul>
<li>5.指定步长为-1可以倒序遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>,<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4><ul>
<li>如果一个函数在内部调用了自身，这个函数就被称为递归函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在调用func函数&#x27;</span>)</span><br><span class="line">    func()</span><br><span class="line">    </span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<ul>
<li>What？函数可以自己调用自己？会不会进入死循环，永远退出不了？我们先看一个例子，典型的高斯求和问题，1+2+3+4+…+99+100,不使用递归的话，我们可以用循环，这么做：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_number</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">result = sum_number(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<ul>
<li>但如果使用递归函数来写，是这样的：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_number</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n + sum_number(n-<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(sum_number(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析一下代码，当n小于等于0的时候，直接给出和值为0，这句不能省。当n大于0时，结果是n加上sum_number(n-1)。这里的sum_number(n-1)又是一次sum_number函数的调用，不过参数的值变成了n-1，要得sum_number(n)到的值就必须等待sum_number(n-1)的值被计算出来，同样要得到sum_number(n-1)的值必须等待sum_number(n-2)的值，如此一路推算下去，直到sum_number(0)，因为if语句的存在，它不需要等待sum_number(-1)的计算了，而是直接给出结果0。然后程序一路返回，直到回到最初的sum_number(n)，并给出最终结果。</p>
</li>
<li><p>递归最核心的思想是：</p>
<ul>
<li>每一次递归，整体问题都要比原来减小，并且递归到一定层次时，要能直接给出结果！</li>
</ul>
</li>
<li><p>递归的优点</p>
<ul>
<li>递归函数的优点是定义简单，代码量少，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>使用递归函数需要注意防止递归深度溢出，在Python中，通常情况下，这个深度是1000层，超过将抛出异常。在计算机中，函数递归调用是通过栈（stack）这种数据结构实现的，每当进入一个递归时，栈就会加一层，每当函数返回一次，栈就会减一层。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_number</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n + sum_number(n-<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(sum_number(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">递归调用的执行过程：</span></span><br><span class="line"><span class="string">	sum_number(5)：5 + sum_number(4)</span></span><br><span class="line"><span class="string">	sum_number(4)：4 + sum_number(3)</span></span><br><span class="line"><span class="string">	sum_number(3)：3 + sum_number(2)</span></span><br><span class="line"><span class="string">	sum_number(2)：2 + sum_number(1)</span></span><br><span class="line"><span class="string">	sum_number(1)：1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><ul>
<li><p>提问：</p>
<ul>
<li>刚开始编程的同学可能会遇到一个头疼的问题，就是变量或者函数命名的问题，虽然命名规范很简单，但是如果涉及到的操作过多给每一个操作的函数都起一个高可读性的名称，必然会挖空你的英语词汇量。</li>
</ul>
</li>
<li><p>当我们在创建函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。这省去了我们挖空心思为函数命名的麻烦，也能少写不少代码，很多编程语言都提供这一特性。匿名函数用好了，会有画龙点睛的效果，没用好，就容易“画虎不成反类犬”，需要我们在平时的代码过程中，多学、多看、多琢磨。</p>
</li>
<li><p>匿名函数的使用</p>
<ul>
<li>Python语言使用lambda关键字来创建匿名函数。</li>
<li>所谓匿名，即不再使用def语句这样标准的形式定义一个函数。<ul>
<li>lambda只是一个表达式,而不是一个代码块，函数体比def简单很多。</li>
<li>仅仅能在lambda表达式中封装有限的逻辑。</li>
</ul>
</li>
<li>定义语法：<ul>
<li>其形式通常是这样的：lambda 参数: 表达式</li>
</ul>
</li>
</ul>
</li>
<li><p>例子：它相当于下面的函数：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#该匿名函数就等同于上面的有名函数</span></span><br><span class="line">result = <span class="keyword">lambda</span> x:<span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment">#x就是匿名函数的参数，0和1就是返回值</span></span><br><span class="line"><span class="built_in">print</span>(result(<span class="number">1</span>)) <span class="comment">#调用匿名函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>匿名函数只能有一个表达式，不用也不能写return语句，表达式的结果就是其返回值。</li>
</ul>
<hr>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul>
<li>到目前为止，我们做的一切操作，都是在内存里进行的，这样会有什么问题吗？如果一旦断电或发生意外关机了，那么你辛勤的工作成果将瞬间消失。是不是感觉事还挺大的呢？现在你是否感觉你的编程技巧还缺了点什么呢？是的，我们还缺少将数据在本地文件系统进行持久化的能力，白话讲就是文件的读写能力。</li>
</ul>
<h2 id="文件打开"><a href="#文件打开" class="headerlink" title="文件打开"></a>文件打开</h2><ul>
<li><p>Python内置了一个open()方法，用于对文件进行读写操作。使用open()方法操作文件就像把大象塞进冰箱一样，可以分三步走，一是打开文件，二是操作文件，三是关闭文件。</p>
</li>
<li><p>文件句柄/文件描述符</p>
<ul>
<li>open()方法的返回值是一个file对象，可以将它赋值给一个变量，这个变量就是所谓的文件句柄。</li>
<li>file对象：<ul>
<li>可以调用read()和write()方法，对打开的文件进行读写操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>open方法的语法</p>
<ul>
<li>f = open(filename, mode)<ul>
<li>filename：<ul>
<li>一个包含了你要访问的文件名称的字符串值，通常是一个文件路径。</li>
</ul>
</li>
<li>mode：<ul>
<li>打开文件的模式，有很多种，默认是只读方式r。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>文件打开的模式：</p>
</li>
<li><p><img src="Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/45.png" alt="45"></p>
</li>
<li><p>常规文件打开模式操作演示</p>
<ul>
<li>b模式：<ul>
<li>二进制模式，通常用来读取图片、视频等二进制文件。注意，它在读写的时候是以bytes类型读写的，因此获得的是一个bytes对象而不是字符串。在这个读写过程中，需要自己指定编码格式。在使用带b的模式时一定要注意传入的数据类型，确保为bytes类型。</li>
</ul>
</li>
<li>+模式：<ul>
<li>对于w+模式，在读写之前都会清空文件的内容，建议不要使用！</li>
<li>对于a+模式，永远只能在文件的末尾写入，有局限性！</li>
<li>对于r+模式，也就是读写模式，配合seek()和tell()方法，可以实现更多操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>编码问题</p>
<ul>
<li>要读取非UTF-8编码的文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件</li>
<li>遇到有些编码不规范的文件，可能会抛出UnicodeDecodeError异常，这表示在文件中可能夹杂了一些非法编码的字符。遇到这种情况，可以提供errors=’ignore‘参数，表示如果遇到编码错误后如何处理。</li>
</ul>
</li>
</ul>
<h2 id="文件对象操作"><a href="#文件对象操作" class="headerlink" title="文件对象操作"></a>文件对象操作</h2><ul>
<li><p>每当我们用open方法打开一个文件时，将返回一个文件对象。这个对象内置了很多操作方法。</p>
</li>
<li><p>f.read(size) #size读取数据的个数</p>
<ul>
<li>读取一定大小的数据, 然后作为字符串或字节对象返回。size是一个可选的数字类型的参数，用于指定读取的数据量。当size被忽略了或者为负值，那么该文件的所有内容都将被读取并且返回。</li>
<li>注意：<ul>
<li>如果文件体积较大，请不要使用read()方法一次性读入内存，而是read(512)这种一点一点的读。</li>
</ul>
</li>
</ul>
</li>
<li><p>f.readline()</p>
<ul>
<li>从文件中读取一行n内容。换行符为’\n’。如果返回一个空字符串，说明已经已经读取到最后一行。这种方法，通常是读一行，处理一行，并且不能回头，只能前进，读过的行不能再读了。</li>
</ul>
</li>
<li><p>f.readlines()</p>
<ul>
<li>将文件中所有的行，一行一行全部读入一个列表内，按顺序一个一个作为列表的元素，并返回这个列表。readlines方法会一次性将文件全部读入内存，所以也存在一定的风险。但是它有个好处，每行都保存在列表里，可以随意存取。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#需求：读取文件中的数据</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;./test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">text = fp.read(<span class="number">10</span>) <span class="comment">#读取指定字节的数据</span></span><br><span class="line">text_line = fp.readline() <span class="comment">#一次读取一行数据</span></span><br><span class="line">text_lines = fp.readlines() <span class="comment">#读取多行数据，返回一个列表</span></span><br><span class="line"><span class="built_in">print</span>(text_lines)</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>总结：</p>
<ul>
<li>几种不同的读取和遍历文件的方法比较：如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便。普通情况，使用for循环更好，速度更快。</li>
</ul>
</li>
<li><p>f.write()</p>
<ul>
<li>将字符串或bytes类型的数据写入文件内。write()动作可以多次重复进行，其实都是在内存中的操作，并不会立刻写回硬盘，直到执行close()方法后，才会将所有的写入操作反映到硬盘上。在这过程中，如果想将内存中的修改，立刻保存到硬盘上，可以使用f.flush()方法。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;./test123.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">fp.write(<span class="string">&#x27;hello bobo&#x27;</span>)</span><br><span class="line">fp.close() <span class="comment">#将文件内容清空，在写入新数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>```python<br>fp = open(‘./test123.txt’,’a’)<br>fp.write(‘hello bobo’)<br>fp.close() #在文件数据末尾追加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">- f.tell()</span><br><span class="line"></span><br><span class="line">  - 返回文件读写指针当前所处的位置,它是从文件开头开始算起的字节数。一定要注意了，是字节数，不是字符数。</span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line">    fp = open(&#x27;./test123.txt&#x27;,&#x27;w&#x27;)</span><br><span class="line">    # fp.write(&#x27;hello bobo&#x27;)</span><br><span class="line">    print(fp.tell())</span><br><span class="line">    fp.close()</span><br></pre></td></tr></table></figure></li>
<li><p>f.seek()</p>
<ul>
<li><p>如果要改变文件指针的位置, 可以使用f.seek(offset, from_what)方法。seek()经常和tell()方法配合使用。</p>
</li>
<li><p>from_what</p>
<ul>
<li>如果是0表示从文件开头计算</li>
<li>如果是1表示从文件读写指针的当前位置开始计算</li>
<li>2表示从文件的结尾开始计算，默认为0</li>
</ul>
</li>
<li><p>offset：表示偏移量</p>
<ul>
<li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字节</li>
<li>seek(x,1) ： 表示从当前位置往后移动x个字节</li>
<li>seek(-x,2)：表示从文件的结尾往前移动x个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;./test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">fp.seek(<span class="number">9</span>,<span class="number">0</span>)</span><br><span class="line">text = fp.read(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>

<p>​    </p>
<ul>
<li><p>f.close()</p>
<ul>
<li>关闭文件对象。当处理完一个文件后，调用f.close()来关闭文件并释放系统的资源。文件关闭后，如果尝试再次调用该文件对象，则会抛出异常。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了，或者更糟糕的结果。也就是说大象塞进冰箱后，一定不要忘记关上冰箱的门。</li>
</ul>
</li>
</ul>
<h2 id="with关键字"><a href="#with关键字" class="headerlink" title="with关键字"></a>with关键字</h2><p>with关键字用于Python的上下文管理器机制。为了防止诸如open这一类文件打开方法在操作过程出现异常或错误，或者最后忘了执行close方法，文件非正常关闭等可能导致文件泄露、破坏的问题。Python提供了with这个上下文管理器机制，保证文件会被正常关闭。在它的管理下，不需要再写close语句。注意缩进。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./test123.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp: <span class="comment">#fp = open()</span></span><br><span class="line">    text = fp.read(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line"><span class="comment">#上下两组代码功效一样</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;./test123.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">text = fp.read(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(text)</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>

<h2 id="简易图书管理系统"><a href="#简易图书管理系统" class="headerlink" title="简易图书管理系统"></a>简易图书管理系统</h2><ul>
<li>注册功能</li>
<li>登录功能</li>
<li>图书的录入</li>
<li>图书的删除</li>
<li>图书的修改操作</li>
<li>图书的查询操作</li>
</ul>
<h4 id="注册实现"><a href="#注册实现" class="headerlink" title="注册实现"></a>注册实现</h4><ul>
<li>1.判定两次密码一致，则注册成功</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">regist</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到注册页面&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;enter username:&#x27;</span>)</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;enter password:&#x27;</span>)</span><br><span class="line">    repeatpwd = <span class="built_in">input</span>(<span class="string">&#x27;repeat enter password:&#x27;</span>)</span><br><span class="line">    email = <span class="built_in">input</span>(<span class="string">&#x27;enter email:&#x27;</span>)</span><br><span class="line">    <span class="comment">#判定用户的注册状态</span></span><br><span class="line">    <span class="keyword">if</span> password == repeatpwd:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./userData.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="comment">#bobo-123-123@qq.com</span></span><br><span class="line">            <span class="comment">#jay-456-456@qq.com</span></span><br><span class="line">            fp.write(username+<span class="string">&#x27;-&#x27;</span>+password+<span class="string">&#x27;-&#x27;</span>+email+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;注册成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;两次密码不一致，注册失败！&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_view</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到xxx管理系统&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1.登录\n2.注册\n3.退出&#x27;</span>)</span><br><span class="line">    choose = <span class="built_in">input</span>(<span class="string">&#x27;请选择功能:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> choose == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        login()</span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        regist()</span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        exit() <span class="comment">#退出整个程序</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入有误，程序退出！&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">main_view()</span><br></pre></td></tr></table></figure>

<ul>
<li>在两次密码一致的情况下，在验证用户名是否重复</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">regist</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到注册页面&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;enter username:&#x27;</span>)</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;enter password:&#x27;</span>)</span><br><span class="line">    repeatpwd = <span class="built_in">input</span>(<span class="string">&#x27;repeat enter password:&#x27;</span>)</span><br><span class="line">    email = <span class="built_in">input</span>(<span class="string">&#x27;enter email:&#x27;</span>)</span><br><span class="line">    <span class="comment">#判定用户的注册状态</span></span><br><span class="line">    <span class="keyword">if</span> password == repeatpwd:</span><br><span class="line">        isHave = <span class="literal">False</span><span class="comment">#用户名是否重复的状态显示，isHave==True表示用户名重复</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./userData.txt&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="comment">#bobo-123-123@qq.com</span></span><br><span class="line">            <span class="comment">#jay-456-456@qq.com</span></span><br><span class="line">            <span class="comment">#读取文件中所有注册用户的用户名</span></span><br><span class="line">            user_data_list = fp.readlines()</span><br><span class="line">            <span class="keyword">for</span> user_data <span class="keyword">in</span> user_data_list:</span><br><span class="line">                userName = user_data.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> username == userName:<span class="comment">#用户名重复</span></span><br><span class="line">                    isHave = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> isHave == <span class="literal">False</span>:  </span><br><span class="line">                fp.write(username+<span class="string">&#x27;-&#x27;</span>+password+<span class="string">&#x27;-&#x27;</span>+email+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;注册成功！&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;注册失败，%s用户名已被占用！&#x27;</span>%username)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;两次密码不一致，注册失败！&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_view</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到xxx管理系统&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1.登录\n2.注册\n3.退出&#x27;</span>)</span><br><span class="line">    choose = <span class="built_in">input</span>(<span class="string">&#x27;请选择功能:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> choose == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        login()</span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        regist()</span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        exit() <span class="comment">#退出整个程序</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入有误，程序退出！&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">main_view()</span><br></pre></td></tr></table></figure>

<h4 id="登录功能实现"><a href="#登录功能实现" class="headerlink" title="登录功能实现"></a>登录功能实现</h4>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">regist</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n\n欢迎来到注册页面&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;enter username:&#x27;</span>)</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;enter password:&#x27;</span>)</span><br><span class="line">    repeatpwd = <span class="built_in">input</span>(<span class="string">&#x27;repeat enter password:&#x27;</span>)</span><br><span class="line">    email = <span class="built_in">input</span>(<span class="string">&#x27;enter email:&#x27;</span>)</span><br><span class="line">    <span class="comment">#判定用户的注册状态</span></span><br><span class="line">    <span class="keyword">if</span> password == repeatpwd:</span><br><span class="line">        isHave = <span class="literal">False</span><span class="comment">#用户名是否重复的状态显示，isHave==True表示用户名重复</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./userData.txt&#x27;</span>,<span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            <span class="comment">#bobo-123-123@qq.com</span></span><br><span class="line">            <span class="comment">#jay-456-456@qq.com</span></span><br><span class="line">            <span class="comment">#读取文件中所有注册用户的用户名</span></span><br><span class="line">            user_data_list = fp.readlines()</span><br><span class="line">            <span class="keyword">for</span> user_data <span class="keyword">in</span> user_data_list:</span><br><span class="line">                userName = user_data.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> username == userName:<span class="comment">#用户名重复</span></span><br><span class="line">                    isHave = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> isHave == <span class="literal">False</span>:  </span><br><span class="line">                fp.write(username+<span class="string">&#x27;-&#x27;</span>+password+<span class="string">&#x27;-&#x27;</span>+email+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;注册成功,三秒后自动跳转到登录页面......&#x27;</span>)</span><br><span class="line">                time.sleep(<span class="number">3</span>) <span class="comment">#暂停三秒</span></span><br><span class="line">                login()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;注册失败，%s用户名已被占用！&#x27;</span>%username)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;是否重新注册？y/n&#x27;</span>)</span><br><span class="line">                c = <span class="built_in">input</span>(<span class="string">&#x27;enter your choose:&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;y&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">                      regist()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                     exit() </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;两次密码不一致，注册失败！&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n\n欢迎来到登录页面&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;enter username:&#x27;</span>)</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;enter password:&#x27;</span>)</span><br><span class="line">    <span class="comment">#判定登录状态</span></span><br><span class="line">    login_state = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./userData.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        user_data_list = fp.readlines()</span><br><span class="line">        <span class="keyword">for</span> user_data <span class="keyword">in</span> user_data_list:</span><br><span class="line">            un = user_data.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            pw = user_data.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> username == un <span class="keyword">and</span> password == pw:</span><br><span class="line">                login_state = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> login_state == <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;登录失败,是否返回主页面？y/n&#x27;</span>)</span><br><span class="line">            c = <span class="built_in">input</span>(<span class="string">&#x27;enter your choose:&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;y&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">                main_view()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                exit()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">findPwd</span>():</span><br><span class="line">    un = <span class="built_in">input</span>(<span class="string">&#x27;enter your username:&#x27;</span>)</span><br><span class="line">    em = <span class="built_in">input</span>(<span class="string">&#x27;enter your email&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./userData.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        isFind = <span class="literal">False</span></span><br><span class="line">        user_data_list = fp.readlines()</span><br><span class="line">        <span class="keyword">for</span> user_data <span class="keyword">in</span> user_data_list:</span><br><span class="line">            username = user_data.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            email = user_data.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">2</span>]</span><br><span class="line">            <span class="comment">#将email中的回车去掉</span></span><br><span class="line">            email = email.strip()</span><br><span class="line">            <span class="keyword">if</span> username == un <span class="keyword">and</span> email == em:</span><br><span class="line">                password = user_data.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;找回的密码为：&#x27;</span>,password)</span><br><span class="line">                isFind = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> isFind == <span class="literal">False</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;密码找回失败，用户名和邮箱不匹配！&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_view</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到xxx管理系统&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1.登录\n2.注册\n3.找回密码\n4.退出&#x27;</span>)</span><br><span class="line">    choose = <span class="built_in">input</span>(<span class="string">&#x27;请选择功能:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> choose == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        login()</span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        regist()</span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        findPwd() </span><br><span class="line">    <span class="keyword">elif</span> choose == <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">#退出整个程序</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入有误，程序退出！&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">main_view()</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。而这样的一个<code>py</code>文件在Python中称为模块（Module）。</p>
<p>模块是组织代码的更高级形式，大大提高了代码的阅读性和可维护性。</p>
<p>模块一共四种：</p>
<ul>
<li>解释器内建模块</li>
<li>python标准库</li>
<li>第三方模块</li>
<li>应用程序自定义模块</li>
</ul>
<p>另外，使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
<h3 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 方式1：导入一个模块</span></span><br><span class="line"><span class="string">import 模块名</span></span><br><span class="line"><span class="string">import 模块名 as 别名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 方式2：导入多个模块</span></span><br><span class="line"><span class="string">import (</span></span><br><span class="line"><span class="string">   模块1</span></span><br><span class="line"><span class="string">   模块2 </span></span><br><span class="line"><span class="string">   )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import 模块1,模块2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 方式3：导入成员变量</span></span><br><span class="line"><span class="string">from 模块名 import 成员变量</span></span><br><span class="line"><span class="string">from 模块名 import *</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>导入模块时会执行模块，多次导入只执行一次。</p>
</blockquote>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cal.py</span><br><span class="line">logger.py</span><br><span class="line">main.py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cal.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这是cal模块文件&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#logger.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_logger</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;打印日志！&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这是logger模块文件&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#main.py</span></span><br><span class="line"><span class="keyword">import</span> cal <span class="comment">#导入了cal模块</span></span><br><span class="line"><span class="keyword">import</span> logger <span class="comment">#导入和logger模块</span></span><br><span class="line"><span class="comment">#注意：import导入模块，就好比是将模块中的代码执行了</span></span><br><span class="line"><span class="keyword">from</span> cal <span class="keyword">import</span> mul <span class="comment">#将cal模块中的mul成员进行导入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用用了cal模块中的add函数</span></span><br><span class="line">result = cal.add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">c = mul(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用了logger模块中的get_logger函数</span></span><br><span class="line">logger.get_logger()</span><br></pre></td></tr></table></figure>

<h4 id="name"><a href="#name" class="headerlink" title="__name__ "></a><code>__name__ </code></h4><p><code>__name__</code>是python内置变量，存储的是当前模块名称。</p>
<p>对于很多编程语言来说，程序都必须要有一个入口。像C，C++都有一个main函数作为程序的入口，而Python作为解释性脚本语言，没有一个统一的入口，因为Python程序运行时是从模块顶行开始，逐行进行翻译执行，所以，最顶层（没有被缩进）的代码都会被执行，所以Python中并不需要一个统一的main()作为程序的入口。</p>
<p>在刚才的案例中三个模块都打印一次<code>__name__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cal.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这是cal模块文件,__name__内置变量的值为：&#x27;</span>,__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#logger.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_logger</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;打印日志！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;这是logger模块文件,__name__内置变量的值为：&#x27;</span>,__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#main.py：作为执行文件</span></span><br><span class="line"><span class="keyword">import</span> cal <span class="comment">#导入了cal模块</span></span><br><span class="line"><span class="keyword">import</span> logger <span class="comment">#导入和logger模块</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main文件的__name__这个内置变量为：&#x27;</span>,__name__)</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是cal模块文件,__name__内置变量的值为： cal</span><br><span class="line">这是logger模块文件,__name__内置变量的值为： logger</span><br><span class="line">main文件的__name__这个内置变量为： __main__</span><br></pre></td></tr></table></figure>

<p>通过结果发现<code>__name__</code>只有在执行模块中打印<code>__main__</code>,在其他导入模块中打印各自模块的名称。</p>
<p>所以，<code>__name__</code>可以有以下作用：</p>
<ul>
<li>利用<code>__name__==&quot;__main__&quot;</code>声明程序入口。</li>
<li>可以对导入的模块进行功能测试</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="什么是包"><a href="#什么是包" class="headerlink" title="什么是包"></a>什么是包</h3><p>当一个项目中模块越来越多，维护和开发不是那么高效的时候，我们可以引入一种比模块更高级语法：包。</p>
<p>包是对相关功能的模块<code>py</code>文件的组织方式。</p>
<p>包可以理解为文件夹，更确切的说，是一个包含<code>__init__</code>文件的文件夹。</p>
<h3 id="导入包的语法"><a href="#导入包的语法" class="headerlink" title="导入包的语法"></a>导入包的语法</h3><ol>
<li><code>import 包名[.模块名 [as 别名]]</code></li>
<li><code>from 包名 import 模块名 [as 别名]</code></li>
<li><code>from 包名.模块名 import 成员名 [as 别名]</code></li>
</ol>
<p>案例：将上面案例中的<code>cal .py</code>文件放到<code>utils</code>包中管理，<code>logger.py</code>放到<code>logger</code>包中管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- demo</span><br><span class="line">   main.py  #执行文件</span><br><span class="line">   -- m_log #包</span><br><span class="line">   		__init__.py</span><br><span class="line">      logger.py #存储在logger包中的一个模块</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> m_log <span class="keyword">import</span> logger</span><br><span class="line">logger.get_logger() <span class="comment">#调用了logger模块中的get_logger函数</span></span><br></pre></td></tr></table></figure>

<h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h3><h4 id="三种时间形式"><a href="#三种时间形式" class="headerlink" title="三种时间形式"></a>三种时间形式</h4><p>在Python中，通常有这三种方式来表示时间：时间戳、元组(struct_time)、格式化的时间字符串：</p>
<blockquote>
<p>(1) 时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</p>
<p>(2) 格式化的时间字符串(Format String)： ‘1988-03-16’</p>
<p>(3) 元组(struct_time) ：struct_time元组共有9个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等）</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;1&gt; 时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.time()     </span><br><span class="line"><span class="number">1493136727.099066</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;2&gt; 时间字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>) <span class="comment">#%Y:年 %m：月 %d：天 %X:时分秒</span></span><br><span class="line"><span class="string">&#x27;2017-04-26 00:32:18&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&lt;3&gt; 程序暂定固定的时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在下载数据......&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>) <span class="comment">#程序暂定n秒</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;下载成功！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>小结：时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#计算一组程序执行的耗时</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"><span class="comment">##############################</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;总耗时：&#x27;</span>,time.time()-start)</span><br></pre></td></tr></table></figure>



<h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()      <span class="comment"># 大于0且小于1之间的小数</span></span><br><span class="line"><span class="number">0.7664338663654585</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">5</span>)  <span class="comment"># 大于等于1且小于等于5之间的整数</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">1</span>,<span class="number">3</span>) <span class="comment"># 大于等于1且小于3之间的整数</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice([<span class="number">1</span>,<span class="string">&#x27;23&#x27;</span>,[<span class="number">4</span>,<span class="number">5</span>]])  <span class="comment"># 返回列表中的随机一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample([<span class="number">1</span>,<span class="string">&#x27;23&#x27;</span>,[<span class="number">4</span>,<span class="number">5</span>]],<span class="number">2</span>) <span class="comment"># 列表元素任意2个随机组合</span></span><br><span class="line">[[<span class="number">4</span>, <span class="number">5</span>], <span class="string">&#x27;23&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.uniform(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">#大于1小于3的小数</span></span><br><span class="line"><span class="number">1.6270147180533838</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(item) <span class="comment"># 直接将原来的列表元素打乱次序，不会返回一个新列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item</span><br><span class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>随机验证码案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">v_code</span>():</span><br><span class="line">    code = <span class="string">&#x27;&#x27;</span> <span class="comment">#存储验证码数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        num = random.randint(<span class="number">0</span>,<span class="number">9</span>) <span class="comment">#产生了一个随机的个位数</span></span><br><span class="line">        alf = <span class="built_in">chr</span>(random.randint(<span class="number">65</span>,<span class="number">90</span>)) <span class="comment">#随机产生了一个字母</span></span><br><span class="line">        add = random.choice([num,alf]) <span class="comment">#随机从列表中选择一个元素</span></span><br><span class="line">        code = <span class="string">&#x27;&#x27;</span>.join([code,<span class="built_in">str</span>(add)])</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line">code_text = v_code()</span><br><span class="line"><span class="built_in">print</span>(code_text)</span><br></pre></td></tr></table></figure>

<h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><p>os模块是与操作系统交互的一个接口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.getcwd() <span class="comment"># 获取当前工作目录，即当前python脚本工作的目录路径</span></span><br><span class="line">os.chdir(<span class="string">&quot;dirname&quot;</span>)  <span class="comment"># 改变当前脚本工作目录；相当于shell下cd</span></span><br><span class="line">os.curdir   <span class="comment"># 返回当前目录: (&#x27;.&#x27;)</span></span><br><span class="line">os.pardir  <span class="comment"># 获取当前目录的父目录字符串名：(&#x27;..&#x27;)</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;dirname1/dirname2&#x27;</span>)   <span class="comment"># ***可生成多层递归目录</span></span><br><span class="line">os.removedirs(<span class="string">&#x27;dirname1&#x27;</span>)    <span class="comment"># ***若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;dirname&#x27;</span>)    <span class="comment">#*** 生成单级目录；相当于shell中mkdir dirname</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;dirname&#x27;</span>)    <span class="comment"># *** 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span></span><br><span class="line">os.listdir(<span class="string">&#x27;dirname&#x27;</span>)    <span class="comment"># ***列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span></span><br><span class="line">os.remove()  <span class="comment">#*** 删除一个文件</span></span><br><span class="line">os.rename(<span class="string">&quot;oldname&quot;</span>,<span class="string">&quot;newname&quot;</span>)  <span class="comment">#*** 重命名文件/目录</span></span><br><span class="line">os.stat(<span class="string">&#x27;path/filename&#x27;</span>) <span class="comment">#  获取文件/目录信息</span></span><br><span class="line">os.sep    <span class="comment"># 输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span></span><br><span class="line">os.linesep    <span class="comment"># 输出当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;</span></span><br><span class="line">os.pathsep    <span class="comment"># 输出用于分割文件路径的字符串 win下为;,Linux下为:</span></span><br><span class="line">os.name    <span class="comment"># 输出字符串指示当前使用平台。win-&gt;&#x27;nt&#x27;; Linux-&gt;&#x27;posix&#x27;</span></span><br><span class="line">os.system(<span class="string">&quot;bash command&quot;</span>)  <span class="comment"># 运行shell命令，直接显示</span></span><br><span class="line">os.environ  <span class="comment"># 获取系统环境变量</span></span><br><span class="line">os.path.abspath(path)  <span class="comment"># ***返回path规范化的绝对路径</span></span><br><span class="line">os.path.split(path)  <span class="comment"># 将path分割成目录和文件名二元组返回</span></span><br><span class="line">os.path.dirname(path)  <span class="comment"># 返回path的目录。其实就是os.path.split(path)的第一个元素</span></span><br><span class="line">os.path.basename(path) <span class="comment">#  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span></span><br><span class="line">os.path.exists(path) <span class="comment">#  ***如果path存在，返回True；如果path不存在，返回False</span></span><br><span class="line">os.path.isabs(path)  <span class="comment"># 如果path是绝对路径，返回True</span></span><br><span class="line">os.path.isfile(path)  <span class="comment"># ***如果path是一个存在的文件，返回True。否则返回False</span></span><br><span class="line">os.path.isdir(path)  <span class="comment"># ***如果path是一个存在的目录，则返回True。否则返回False</span></span><br><span class="line">os.path.join(path1[, path2[, ...]])  <span class="comment"># 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span></span><br><span class="line">os.path.getatime(path)  <span class="comment"># 返回path所指向的文件或者目录的最后访问时间</span></span><br><span class="line">os.path.getmtime(path)  <span class="comment"># 返回path所指向的文件或者目录的最后修改时间</span></span><br><span class="line">os.path.getsize(path) <span class="comment"># ***返回path的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="序列化模块：json"><a href="#序列化模块：json" class="headerlink" title="序列化模块：json"></a>序列化模块：json</h3><blockquote>
<p>序列化： 将python中的字典，列表对象转换成指定形式字符串</p>
<p>反序列化：将指定格式的字符串转换成字典，列表对象</p>
</blockquote>
<ul>
<li><p>基本使用</p>
</li>
<li><p>```python<br>import json<br>dic = {</p>
<pre><code>&#39;hobby&#39;:[&#39;football&#39;,&#39;pingpang&#39;,&#39;smoke&#39;],
&#39;age&#39;:20,
&#39;score&#39;:97.6,
&#39;name&#39;:&#39;zhangsan&#39;
</code></pre>
<p>}<br>#序列化：将字典对象转换成了json格式的字符串<br>r = json.dumps(dic)<br>print(r)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">str = &#x27;&#123;&quot;hobby&quot;: [&quot;football&quot;, &quot;pingpang&quot;, &quot;smoke&quot;], &quot;age&quot;: 20, &quot;score&quot;: 97.6, &quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27;</span><br><span class="line">#反序列化：将字符串转换成了字典对象</span><br><span class="line">dic = json.loads(str)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#持久化存储字典</span><br><span class="line">import json</span><br><span class="line">dic = &#123;</span><br><span class="line">    &#x27;hobby&#x27;:[&#x27;football&#x27;,&#x27;pingpang&#x27;,&#x27;smoke&#x27;],</span><br><span class="line">    &#x27;age&#x27;:20,</span><br><span class="line">    &#x27;score&#x27;:97.6,</span><br><span class="line">    &#x27;name&#x27;:&#x27;zhangsan&#x27;</span><br><span class="line">&#125;</span><br><span class="line">fp = open(&#x27;./dic.json&#x27;,&#x27;a&#x27;)</span><br><span class="line">#dump首先将dic字典进行序列化，然后将序列化后的结果写入到了fp表示的文件中</span><br><span class="line">json.dump(dic,fp)</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">fp = open(&#x27;./dic.json&#x27;,&#x27;r&#x27;)</span><br><span class="line">#load将文件中的字符串数据进行读取，且将其转换成字典类型</span><br><span class="line">dic = json.load(fp)</span><br><span class="line">print(dic)</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="正则模块"><a href="#正则模块" class="headerlink" title="正则模块"></a>正则模块</h3><ul>
<li><p>什么是正则表达式？</p>
<ul>
<li>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（例如，*，+，？等）。</li>
<li>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</li>
</ul>
</li>
<li><p>常用的正则标识</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单字符：</span><br><span class="line">    . : 除换行以外所有字符</span><br><span class="line">    [] ：[aoe] [a-w] 匹配集合中任意一个字符</span><br><span class="line">    \d ：数字  [0-9]</span><br><span class="line">   </span><br><span class="line">数量修饰：</span><br><span class="line">    * : 任意多次  &gt;=0</span><br><span class="line">    + : 至少1次   &gt;=1</span><br><span class="line">    ? : 可有可无  0次或者1次</span><br><span class="line">    &#123;m&#125; ：固定m次 hello&#123;3,&#125;</span><br><span class="line">    &#123;m,&#125; ：至少m次</span><br><span class="line">    &#123;m,n&#125; ：m-n次</span><br><span class="line">边界：</span><br><span class="line">    $ : 以某某结尾 </span><br><span class="line">    ^ : 以某某开头</span><br><span class="line">分组：</span><br><span class="line">		(ab)  </span><br><span class="line">贪婪模式： .*</span><br><span class="line">非贪婪（惰性）模式： .*?</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>正则在python中的使用</p>
<ul>
<li><p>基于re模块进行正则匹配操作</p>
</li>
<li><p>主要使用re模块中的findall进行指定规则的匹配</p>
<ul>
<li>findall(str,rule)<ul>
<li>str表示即将进行匹配的原始字符串数据</li>
<li>rule表示指定规则的正则表达式</li>
<li>findall返回的是列表，列表中存储匹配到的指定内容</li>
</ul>
</li>
</ul>
</li>
<li><p>练习</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取170</span></span><br><span class="line">string = <span class="string">&#x27;我喜欢身高为170的女孩&#x27;</span></span><br><span class="line">ex = <span class="string">&#x27;\d+&#x27;</span></span><br><span class="line">result = re.findall(ex,string)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="comment">#提取出http://和https://</span></span><br><span class="line">key=<span class="string">&#x27;http://www.baidu.com and https://boob.com&#x27;</span></span><br><span class="line">ex = <span class="string">&#x27;https?://&#x27;</span></span><br><span class="line">result = re.findall(ex,key)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#提取出hello</span></span><br><span class="line">key=<span class="string">&#x27;lalala&lt;hTml&gt;hello&lt;/HtMl&gt;hahah&#x27;</span> <span class="comment">#输出&lt;hTml&gt;hello&lt;/HtMl&gt;</span></span><br><span class="line">ex = <span class="string">&#x27;&lt;hTml&gt;.*&lt;/HtMl&gt;&#x27;</span></span><br><span class="line">result = re.findall(ex,key)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="comment">#提取出hit.</span></span><br><span class="line">key=<span class="string">&#x27;bobo@hit.edu.com&#x27;</span><span class="comment">#想要匹配到hit.</span></span><br><span class="line"><span class="comment"># ex = &#x27;h.*\.&#x27; #贪婪模式</span></span><br><span class="line">ex = <span class="string">&#x27;h.*?\.&#x27;</span> <span class="comment">#？将正则的贪婪模式调整为非贪婪模式。默认下为贪婪模式</span></span><br><span class="line">result = re.findall(ex,key)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="comment">#匹配sas和saas</span></span><br><span class="line">key=<span class="string">&#x27;saas and sas and saaas&#x27;</span></span><br><span class="line">ex = <span class="string">&#x27;sa&#123;1,2&#125;s&#x27;</span></span><br><span class="line">result = re.findall(ex,key)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line">key = <span class="string">&#x27;你好我的手机号是13222222222你记住了吗&#x27;</span></span><br><span class="line">ex = <span class="string">&#x27;1[3,5,7,8,9]\d&#123;9&#125;&#x27;</span></span><br><span class="line">result = re.findall(ex,key)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><strong>重难点!!! 平时翻笔记看得最勤就是这里了</strong></p>
<h2 id="面向过程VS面向对象"><a href="#面向过程VS面向对象" class="headerlink" title="面向过程VS面向对象"></a>面向过程VS面向对象</h2><ul>
<li><p>面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的思想就好比是精心设计好一条流水线，考虑周全什么时候处理什么东西。</p>
</li>
<li><p><strong>优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。</strong></p>
</li>
<li><p><strong>缺点是：一套流水线就是用来解决一个问题，代码牵一发而动全身。</strong></p>
</li>
<li><p>应用场景：</p>
<ul>
<li>一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。</li>
</ul>
</li>
<li><p>面向对象OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，并且一个对象包含数据和操作数据的方法。</p>
</li>
<li><p>面向对象的程序设计的核心是对象，要理解对象为何物，必须把自己当成上帝（上帝式思维）。上帝眼里世间存在的万物皆为对象。</p>
</li>
<li><p>形象化场景设计：</p>
<ul>
<li>面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，”如来”想了想解决这个问题需要四个人（对象）：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法）。然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。“如来”根本不会管师徒四人按照什么流程去取，只关心最后结果是否可以实现。</li>
<li>因此面向对象的核心思想就是使用一个有一个的对象来完成某件具体是事件，且不用关心完成的具体过程！</li>
</ul>
</li>
<li><p><strong>面向对象的优点：面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使他人更加容易理解你的代码逻辑，从而使团队开发变得更从容。</strong></p>
</li>
<li><p><strong>应用场景：需求经常变化的软件，如互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。</strong></p>
</li>
</ul>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p><strong>类</strong>，英文名字Class，有“类别”，“分类”，“聚类”的意思。</p>
<p>必须牢记类是抽象的模板，用来描述具有相同属性和方法的对象的集合，比如Animal类。</p>
<p>而<strong>实例</strong>是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>
<ul>
<li>Python使用class关键字来定义类，其基本结构如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(): <span class="comment">#一般类名首字母是大写</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>下面是一个学生类：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">  	<span class="comment">#数据</span></span><br><span class="line">    classroom = <span class="string">&#x27;101&#x27;</span></span><br><span class="line">    address = <span class="string">&#x27;beijing&#x27;</span> </span><br><span class="line">		<span class="comment">#构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">		<span class="comment">#操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.age))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象的创建</p>
<ul>
<li><p>可以通过调用类的实例化方法（有的语言中也叫初始化方法或构造函数）来创建一个类的实例（对象）。</p>
</li>
<li><p>Python提供了一个<code>def __init__(self):</code>的实例化机制。任何一个类中，名字为<code>__init__</code>的方法就是类的实例化方法，具有<code>__init__</code>方法的类在实例化的时候，会自动调用该方法，并传递对应的参数。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">zhangsan = Student(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">lisi = Student(<span class="string">&#x27;lisi&#x27;</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="实例变量和类变量"><a href="#实例变量和类变量" class="headerlink" title="实例变量和类变量"></a>实例变量和类变量</h2><ul>
<li><p>实例变量</p>
<ul>
<li><p>实例变量指的是实例（对象）本身拥有的变量。Student类中<code>__init__</code>方法里的name和age就是两个实例变量。</p>
</li>
<li><p>通过实例名加圆点的方式调用实例变量（可以通过对象名打点的方式去调用/访问属于对象的成员）。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="comment">#init称为构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,i_name,i_age</span>):</span><br><span class="line">        <span class="comment">#只要定义在init方法内部的变量就是【实例/对象变量】</span></span><br><span class="line">        self.name = i_name <span class="comment">#self.name就是定义的实例变量，name是init方法的参数值</span></span><br><span class="line">        self.age = i_age <span class="comment">#self.age就是定义的实例变量，age就是init方法的参数值</span></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">20</span>) <span class="comment">#调用Student类中的init这个构造方法</span></span><br><span class="line">s2 = Student(<span class="string">&#x27;lisi&#x27;</span>,<span class="number">25</span>)</span><br><span class="line"><span class="comment">#根据对象的引用访问对象的实例变量</span></span><br><span class="line"><span class="built_in">print</span>(s1.name,s1.age) <span class="comment">#访问s1对象的name和age这两个实例变量</span></span><br><span class="line"><span class="built_in">print</span>(s2.name,s2.age) <span class="comment">#访问s2对象的name和age这两个实例变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>类变量</p>
<ul>
<li><p>定义在类中，方法之外的变量，称作类变量。类变量是所有实例公有的变量，每一个实例都可以访问类变量。</p>
</li>
<li><p>在Student类中，classroom和address两个变量就是类变量。可以通过类名或者实例名加圆点的方式访问类变量，比如：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="comment">#定义在方法外部的变量：类变量</span></span><br><span class="line">    address = <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">    classroom = <span class="number">167</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#init称为构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,i_name,i_age</span>):</span><br><span class="line">        <span class="comment">#只要定义在init方法内部的变量就是【实例/对象变量】</span></span><br><span class="line">        self.name = i_name <span class="comment">#self.name就是定义的实例变量，name是init方法的参数值</span></span><br><span class="line">        self.age = i_age <span class="comment">#self.age就是定义的实例变量，age就是init方法的参数值</span></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">20</span>) <span class="comment">#调用Student类中的init这个构造方法</span></span><br><span class="line">s2 = Student(<span class="string">&#x27;lisi&#x27;</span>,<span class="number">25</span>)</span><br><span class="line"><span class="comment">#根据对象的引用访问对象的实例变量</span></span><br><span class="line"><span class="built_in">print</span>(s1.name,s1.age) <span class="comment">#访问s1对象的name和age这两个实例变量</span></span><br><span class="line"><span class="built_in">print</span>(s2.name,s2.age) <span class="comment">#访问s2对象的name和age这两个实例变量</span></span><br></pre></td></tr></table></figure>

<pre><code>- 类变量的特性：

  - 所有的类变量是可以通过类名或者对象名打点的方式访问/调用的。
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(s1.address,s1.classroom) <span class="comment">#通过对象名可以访问类变量（不推荐）</span></span><br><span class="line"><span class="comment">#通过类名可以访问类变量（推荐）</span></span><br><span class="line"><span class="built_in">print</span>(Student.address,Student.classroom)</span><br></pre></td></tr></table></figure>

<pre><code>  - 类变量是可以被所有的对象公用的
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(s1.address,s1.classroom) <span class="comment">#通过s1对象访问类变量</span></span><br><span class="line"><span class="built_in">print</span>(s2.address,s2.classroom) <span class="comment">#通过s2对象访问类变量</span></span><br></pre></td></tr></table></figure>




<ul>
<li><p>思考：如何修改类变量中存储的数据？</p>
<ul>
<li>通过对象名访问类变量对其进行内容的修改？</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="comment">#定义在方法外部的变量：类变量</span></span><br><span class="line">    address = <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">    classroom = <span class="number">167</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#init称为构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,i_name,i_age</span>):</span><br><span class="line">        <span class="comment">#只要定义在init方法内部的变量就是【实例/对象变量】</span></span><br><span class="line">        self.name = i_name <span class="comment">#self.name就是定义的实例变量，name是init方法的参数值</span></span><br><span class="line">        self.age = i_age <span class="comment">#self.age就是定义的实例变量，age就是init方法的参数值</span></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">20</span>) <span class="comment">#调用Student类中的init这个构造方法</span></span><br><span class="line">s2 = Student(<span class="string">&#x27;lisi&#x27;</span>,<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#想要通过s1对象访问address类变量，且给其修改内容</span></span><br><span class="line">s1.address = <span class="string">&#x27;SH&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s2.address)</span><br><span class="line"><span class="comment">#思考：类变量是被所有的对象共享，因此通过s1对象修改了类变量，s2再次访问类变量，情况如何？</span></span><br><span class="line"><span class="comment">#s2访问的类变量address依然是beijing不是s1修改后的上海，Why？</span></span><br><span class="line"><span class="comment">#这种情况是说明类变量不是被所有对象共享的吗？一定不是这样！</span></span><br></pre></td></tr></table></figure>

<pre><code>  - 特别注意：建议大家使用类名访问类变量。如果通过对象名直接访问类变量是没有问题的。但是通过对象名访问类变量后给其进行赋值操作意图修改类变量实则发生的是通过对象打点的方式给对象动态的新增了一个实例变量，并不是在修改类变量。
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1.address = <span class="string">&#x27;SH&#x27;</span> <span class="comment">#动态的给s1这个变量新增了一个实例变量，这个实例变量叫做address。该操作执行完毕后，则s1这个对象内部多了一个实例变量叫做s1，且s1对象对应的类中也有一个address表示的类变量。</span></span><br><span class="line"><span class="built_in">print</span>(Student.address)<span class="comment">#在访问类变量address，这个类变量依然还是Beijing。</span></span><br></pre></td></tr></table></figure>

<pre><code>- 通过实例名修改？
</code></pre>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在访问类变量</span></span><br><span class="line"><span class="built_in">print</span>(s1.address,s2.address)</span><br><span class="line"><span class="comment">#通过类名访问类变量且对其进行修改</span></span><br><span class="line">Student.address = <span class="string">&#x27;SH&#x27;</span></span><br><span class="line"><span class="comment">#查看修改后的结果</span></span><br><span class="line"><span class="built_in">print</span>(s1.address,s2.address) <span class="comment">#SH SH</span></span><br></pre></td></tr></table></figure>

<p>  注意：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对象创建好了之后，是可以通过对象名动态的给对象添加新的实例变量。对象添加了实例变量后，只会影响该对象本身，不会对类和其他对象造成影响。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#给s1对象动态添加了一个实例变量book</span></span><br><span class="line">s1.book = <span class="string">&#x27;sanguo&#x27;</span></span><br><span class="line"><span class="comment">#下述语句报错，因为s1动态增加的实例变量，只会影响它自己，不会影响到其他</span></span><br><span class="line"><span class="built_in">print</span>(s2.book,Student.book)</span><br></pre></td></tr></table></figure>


<ul>
<li>测试：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    address = <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">    <span class="comment">#构造方法：用来实例变量初始化赋值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,addr</span>):</span><br><span class="line">        <span class="comment">#构造方法中也可以写入其他操作，但是一般情况下，只需要在构造方法中写给实例变量初始化赋值的操作。</span></span><br><span class="line">        self.address = addr</span><br><span class="line">        <span class="comment">#实例变量名和类变量名一致</span></span><br><span class="line">        </span><br><span class="line">s = Student(<span class="string">&#x27;SH&#x27;</span>) <span class="comment">#创建对象其实就是在调用类中的init方法</span></span><br><span class="line"><span class="comment">#如果实例变量和类变量同名，通过对象名访问，优先方位对象的实例变量</span></span><br><span class="line"><span class="built_in">print</span>(s.address) <span class="comment">#输出：SH</span></span><br><span class="line"><span class="built_in">print</span>(Student.address)<span class="comment">#输出：Beijing</span></span><br></pre></td></tr></table></figure>

<h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><p>Python的类中包含<strong>实例方法、静态方法和类方法</strong>三种方法。区别在于传入的参数和调用方式不同。</p>
<p>在类的内部，使用<code>def</code>关键字来定义一个方法。</p>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><p>类的实例方法由实例调用，至少包含一个self参数，且为第一个参数。执行实例方法时，会自动将调用该方法的实例赋值给self。</p>
<ul>
<li><p><code>self</code>代表的是类的实例，而非类本身。<code>self</code>不是关键字，而是Python约定成俗的命名，你完全可以取别的名字，但不建议这么做。</p>
</li>
<li><p>例如，我们前面Student类中的print_age()就是实例方法：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    classroot = <span class="number">167</span> <span class="comment">#类变量</span></span><br><span class="line">    <span class="comment">#构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="comment">#实例变量</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment">#实例方法:self不是python的关键字，实例方法的第一个参数也可以叫其他的名字，但是约定俗成叫做self。</span></span><br><span class="line">    <span class="comment">#注意：实例方法只可以通过对象调用。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self,book</span>):<span class="comment">#self是不需要手动给其传值</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在学习的书籍是：&#x27;</span>,book)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">20</span>) <span class="comment">#调用构造方法</span></span><br><span class="line"><span class="comment">#只给除了self其他的参数传值</span></span><br><span class="line">s.study(<span class="string">&#x27;高等数学&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>实例方法中的第一个参数self到底是什么鬼？</p>
<ul>
<li>想要在一个实例方法内部调用另一个实例方法？<ul>
<li>核心：实例方法只可以被对象调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    classroot = <span class="number">167</span> <span class="comment">#类变量</span></span><br><span class="line">    <span class="comment">#构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        <span class="comment">#实例变量</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment">#实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self,book</span>): <span class="comment">#self就是study方法的调用者（对象）</span></span><br><span class="line">        <span class="comment">#注意：在study方法内部调用play方法，如何实现？</span></span><br><span class="line">        self.play(<span class="string">&#x27;足球&#x27;</span>) <span class="comment">#实例方法必须使用对象调用</span></span><br><span class="line">        <span class="comment">#self表示的就是调用该方法的对象的引用</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在学习的书籍是：&#x27;</span>,book)</span><br><span class="line">    <span class="comment">#实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self,b</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在玩的项目是:&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">20</span>) <span class="comment">#调用构造方法</span></span><br><span class="line">s.study(<span class="string">&#x27;高等数学&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- self就是study方法的调用者（对象），self表示的就是调用该方法的对象的引用
</code></pre>
<p><strong>对象之间的交互</strong>：设计人狗大战游戏，让他们真正的打一架。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.blood = <span class="number">100</span> <span class="comment">#人的初始血量</span></span><br><span class="line">        self.gjl = <span class="number">10</span> <span class="comment">#人的攻击力</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hitDog</span>(<span class="params">self,dog</span>): <span class="comment">#dog参数表示的是狗对象</span></span><br><span class="line">        <span class="comment">#人打狗后，需要让狗的血量减去人的攻击力</span></span><br><span class="line">        dog.blood -= self.gjl</span><br><span class="line">    <span class="comment">#展示剩余血量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">showBlood</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s，剩下的血量为：%d&#x27;</span>%(self.name,self.blood))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.blood = <span class="number">50</span> <span class="comment">#狗的初始血量</span></span><br><span class="line">        self.gjl = <span class="number">5</span> <span class="comment">#狗的攻击力</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hitPerson</span>(<span class="params">self,p</span>): <span class="comment">#参数p就是狗攻击的人那个对象</span></span><br><span class="line">        p.blood -= self.gjl</span><br><span class="line">    <span class="comment">#展示剩余血量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">showBlood</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s，剩下的血量为：%d&#x27;</span>%(self.name,self.blood))</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">p2 = Person(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d1 = Dog(<span class="string">&#x27;doudou&#x27;</span>)</span><br><span class="line">d2 = Dog(<span class="string">&#x27;huanghuang&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p2.hitDog(d1) <span class="comment">#lisi去攻击doudou这条狗</span></span><br><span class="line">d1.showBlood() <span class="comment">#查看被攻击后的狗还剩下多少血量</span></span><br><span class="line"></span><br><span class="line">d2.hitPerson(p1) <span class="comment">#huanghuang去攻击zhangsan</span></span><br><span class="line">p1.showBlood() <span class="comment">#查看被攻击后的人还剩下多少血量</span></span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li><p>静态方法由类调用，无默认参数。将实例方法参数中的self去掉，然后在方法定义上方加上@staticmethod，就成为静态方法。</p>
</li>
<li><p>静态方法属于类，和实例无关。建议只使用类名.静态方法的调用方式。（虽然也可以使用实例名.静态方法的方式调用）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">#定义一个静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">staticFunc</span>(<span class="params">name</span>):<span class="comment">#静态方法不需要有任何的必要参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是静态方法！，我有一个普通参数：&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line">Obj.staticFunc(<span class="string">&#x27;bobo&#x27;</span>) <span class="comment">#通过类名调用（推荐）</span></span><br><span class="line">o = Obj()</span><br><span class="line">o.staticFunc(<span class="string">&#x27;bobo&#x27;</span>) <span class="comment">#通过对象名调用（不推荐）</span></span><br><span class="line"><span class="comment">#静态方法既不属于类也不属于对象，仅仅是写在类内部的一个普通函数而已</span></span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul>
<li><p>类方法由类调用，采用@classmethod装饰，至少传入一个cls（代指类本身，类似self）参数。</p>
</li>
<li><p>执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span>():</span><br><span class="line">    f = <span class="string">&#x27;classVar&#x27;</span> <span class="comment">#类变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">classFunc</span>(<span class="params">cls</span>): <span class="comment">#类方法必须要有一个cls的参数，且作为第一个参数</span></span><br><span class="line">        <span class="comment">#cls也不是python的关键字，cls也可以写作其他的形式，比如：name，self</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是类方法！必要参数cls的值为：&#x27;</span>,cls)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类变量的值为:&#x27;</span>,cls.f) <span class="comment">#类名访问类变量</span></span><br><span class="line">        <span class="comment">#cls表示的是当前类</span></span><br><span class="line"></span><br><span class="line">o = Obj()</span><br><span class="line">o.classFunc() <span class="comment">#通过对象名访问（不推荐）</span></span><br><span class="line"></span><br><span class="line">Obj.classFunc() <span class="comment">#通过类名访问（推荐）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>测试题：</p>
<ul>
<li>在类方法中是否可以调用实例方法和实例变量？<ul>
<li>不能，因为实例变量和实例方法只可以通过对象名访问，但是在类方法内部不存在对象名。</li>
</ul>
</li>
<li>在实例方法中是否可以调用类方法和类变量？<ul>
<li>可以，但是不建议这么做！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象的组合用法"><a href="#面向对象的组合用法" class="headerlink" title="面向对象的组合用法"></a>面向对象的组合用法</h2><ul>
<li><p><strong>组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合</strong></p>
</li>
<li><p>思路设计：一个学生会有一步手机，学生使用手机看电影。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#将创建好的手机对象赋值给了phone这个实例变量</span></span><br><span class="line">        self.phone = Phone(<span class="string">&#x27;霸王别姬&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,movie_name</span>):</span><br><span class="line">        self.movie_name = movie_name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">playMovie</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;手机正在播放的电影是：&#x27;</span>,self.movie_name)</span><br><span class="line"></span><br><span class="line">s1 = Student()</span><br><span class="line">s1.phone.playMovie()</span><br></pre></td></tr></table></figure>



<h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>面向对象有三大特性：封装、继承和多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li><p>封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现且不能通过任何形式修改对象内部实现，正是由于封装机制。</p>
</li>
<li><p>作用：</p>
<ul>
<li>程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    classroom = <span class="string">&#x27;101&#x27;</span></span><br><span class="line">    address = <span class="string">&#x27;beijing&#x27;</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是错误的用法</span></span><br><span class="line"><span class="comment"># 类将它内部的变量和方法封装起来，阻止外部的直接访问</span></span><br><span class="line"><span class="built_in">print</span>(classroom)</span><br><span class="line"><span class="built_in">print</span>(adress)</span><br><span class="line">print_age()</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>继承来源于现实世界：</p>
<ul>
<li>一个最简单的例子就是孩子会具有父母的一些特征，即每个孩子都会继承父亲或者母亲的某些特征，当然这只是最基本的继承关系，现实世界中还存在着更复杂的继承。</li>
</ul>
</li>
<li><p>在OOP程序设计中，当我们定义一个新类的时候，新的类称为子类（Subclass），而被继承的类称为基类、父类或超类（Base class、Super class）。</p>
<ul>
<li>继承最大的好处是子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展。其语法结构如下：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(superA, superB,superC....):</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Python支持多父类的继承机制。</li>
</ul>
<p>继承示例代码：子类可以继承到父类中所有的成员</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    address = <span class="string">&#x27;Beijing&#x27;</span> <span class="comment">#类变量</span></span><br><span class="line">    <span class="comment">#构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,fistName,hobby</span>):</span><br><span class="line">        <span class="comment">#两个实例变量</span></span><br><span class="line">        self.firstName = fistName</span><br><span class="line">        self.hobby = hobby</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_xxx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father的实例方法&#x27;</span>)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">classFunc</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father类的类方法&#x27;</span>)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">staticFunc</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father类的静态方法&#x27;</span>)</span><br><span class="line"><span class="comment">#Son继承了Father这个类</span></span><br><span class="line"><span class="comment">#Son子类，Father父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.子类可以继承到父类的构造方法</span></span><br><span class="line">s = Son(<span class="string">&#x27;zhang&#x27;</span>,<span class="string">&#x27;smoke&#x27;</span>) <span class="comment">#调用子类的构造方法，子类是可以继承到父类的构造方法</span></span><br><span class="line"><span class="comment">#2.子类可以继承到父类的类变量</span></span><br><span class="line"><span class="built_in">print</span>(Son.address)</span><br><span class="line"><span class="comment">#3.子类可以继承到父类的实例变量</span></span><br><span class="line"><span class="built_in">print</span>(s.firstName,s.hobby)</span><br><span class="line"><span class="comment">#4.子类可以继承到父类的实例方法</span></span><br><span class="line">s.get_xxx()</span><br><span class="line"><span class="comment">#5.子类可以继承到父类的类方法</span></span><br><span class="line">Son.classFunc()</span><br><span class="line"><span class="comment">#6.子类可以继承到父类的静态方法</span></span><br><span class="line">Son.staticFunc()</span><br></pre></td></tr></table></figure>

<h3 id="派生"><a href="#派生" class="headerlink" title="派生"></a>派生</h3><ul>
<li>子类添加自己独有的方法和或属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    address = <span class="string">&#x27;Beijing&#x27;</span> <span class="comment">#类变量</span></span><br><span class="line">    <span class="comment">#构造方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,fistName,hobby</span>):</span><br><span class="line">        <span class="comment">#两个实例变量</span></span><br><span class="line">        self.firstName = fistName</span><br><span class="line">        self.hobby = hobby</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_xxx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father的实例方法&#x27;</span>)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">classFunc</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father类的类方法&#x27;</span>)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">staticFunc</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father类的静态方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="comment">#子类自己派生出来的独有的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;子类的实例方法sing&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Son(<span class="string">&#x27;zhang&#x27;</span>,<span class="string">&#x27;smoke&#x27;</span>)</span><br><span class="line">s.sing()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法的重写</p>
<ul>
<li><p>重写:子类继承到父类的方法，如果满足不了子类的需求，则子类可以重写从父类中继承到的方法。重写父类方法有两种方式：1完全重写，2部分重写</p>
<ul>
<li>1.完全重写：完全重新将父类的方法进行的全新的定义/实现（毫无保留父类方法原始的功能）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,firstName</span>):</span><br><span class="line">        self.firstName = firstName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我喜欢读书，运动和跳舞！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="comment">#完全重写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我喜欢吃鸡，王者！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Son(<span class="string">&#x27;zhang&#x27;</span>)</span><br><span class="line">s.hobby()</span><br></pre></td></tr></table></figure>

<ul>
<li>2.部分重写：在父类方法功能实现的基础上新增了其他操作/功能</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,firstName</span>):</span><br><span class="line">        self.firstName = firstName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我喜欢读书，运动和跳舞！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father1</span>):</span><br><span class="line">    <span class="comment">#部分重写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#调用一下父类的hobby方法</span></span><br><span class="line">        <span class="built_in">super</span>().hobby() <span class="comment">#调用父类的方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我喜欢吃鸡，王者！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Son(<span class="string">&#x27;zhang&#x27;</span>)</span><br><span class="line">s.hobby()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>super()只可以作用在类的内部，然后表示的是父类对象的引用。</p>
</li>
<li><p>super函数</p>
<ul>
<li><p>如果你想强制调用父类的成员该如何实现呢？使用super()函数！这是一个非常重要的函数，最常见的就是通过super调用父类的实例化方法<code>__init__</code>！</p>
<ul>
<li>语法：<code>super(子类名, self).方法名()</code>，需要传入的是子类名和self，调用的是父类里的方法，按父类的方法需要传入参数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,firstName</span>):</span><br><span class="line">        self.firstName = firstName</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我喜欢读书，运动和跳舞！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="comment">#子类需要有属于自己的实例变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,firstName,classroom,score</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(firstName)</span><br><span class="line">        <span class="comment">#子类自己派生出的独有的实例变量</span></span><br><span class="line">        self.classroom = classroom</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="comment">#部分重写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#调用一下父类的hobby方法</span></span><br><span class="line">        <span class="built_in">super</span>().hobby() <span class="comment">#调用父类的方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我喜欢吃鸡，王者！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Son(<span class="string">&#x27;zhang&#x27;</span>,<span class="number">102</span>,<span class="number">100</span>)</span><br><span class="line">s.hobby()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>继承的作用：</p>
<ul>
<li>实现了程序的高复用，大大缩短程序的开发周期！</li>
</ul>
</li>
<li><p>在多继承中，继承关系的优先级</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father1，我喜欢唱歌！&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father2</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Father2，我喜欢跳舞！&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#注意：越靠前的父类越优先被继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(Father1,Father2):</span><br><span class="line">    <span class="comment">#方法的重写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hobby</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#思考：现在Son有两个父类，super()表示的是哪一个父类对象？</span></span><br><span class="line">        <span class="comment">#输出结果显示super表示的是Father1对象</span></span><br><span class="line">        <span class="built_in">super</span>().hobby()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是Son，我喜欢吃鸡！&#x27;</span>)</span><br><span class="line">s = Son()</span><br><span class="line">s.hobby()</span><br></pre></td></tr></table></figure>

<p><strong>type和isinstance</strong></p>
<ul>
<li><p>isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</p>
</li>
<li><p>isinstance() 方法的语法:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isinstance(object, classinfo)</span><br><span class="line">参数：</span><br><span class="line">    object -- 实例对象。</span><br><span class="line">    classinfo -- 可以是类名、基本类型或者有它们组成的元组。</span><br><span class="line">返回值：</span><br><span class="line">		如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">s = Son() <span class="comment">#子类对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(s,Son)) <span class="comment">#True</span></span><br><span class="line"><span class="comment">#s这个对象是属于Son这个数据类型的。</span></span><br><span class="line"><span class="comment">#python的数据类型：内置类型（8中），自定义类型（类）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">s = Son() <span class="comment">#子类对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(s,Father)) <span class="comment">#True</span></span><br><span class="line"><span class="comment">#注意：子类对象可以被视为是一种父类类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">s = Son() <span class="comment">#子类对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s)) <span class="comment">#&lt;class &#x27;__main__.Son&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>type：返回对象的类型</p>
</li>
<li><p>isinstance() 与 type() 区别：</p>
<ul>
<li><p>type() 不会认为子类是一种父类类型，不考虑继承关系。</p>
</li>
<li><p>isinstance() 会认为子类是一种父类类型，考虑继承关系。</p>
</li>
</ul>
</li>
</ul>
<h3 id="继承注意事项"><a href="#继承注意事项" class="headerlink" title="继承注意事项"></a>继承注意事项</h3><ul>
<li>实例方法中的self参数是一个相对的值？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_xxx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">f = Father()</span><br><span class="line">f.get_xxx()</span><br><span class="line"><span class="comment">#输出：&lt;__main__.Father object at 0x103536580&gt;</span></span><br><span class="line"><span class="comment">#说明self表示的是父类类型的对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_xxx</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">s = Son()</span><br><span class="line"><span class="comment">#是子类对象从父类中继承过来，self原本是写在父类的实例方法中的</span></span><br><span class="line">s.get_xxx() </span><br><span class="line"><span class="comment">#输出结果：&lt;__main__.Son object at 0x100e2a880&gt;</span></span><br></pre></td></tr></table></figure>

<pre><code>- self所处的位置不同，表示的对象类型也是不同的！
</code></pre>
<ul>
<li>类方法中的cls参数是一个相对的值？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="comment">#类变量</span></span><br><span class="line">    class_var = <span class="string">&#x27;father var&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getVar</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(Father.class_var)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="comment">#类变量：和父类的类变量同名，子类同名的类变量就会覆盖从父类中继承过来的类变量</span></span><br><span class="line">    class_var = <span class="string">&#x27;son var&#x27;</span></span><br><span class="line">    </span><br><span class="line">Son.getVar() <span class="comment">#输出：father var</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>():</span><br><span class="line">    <span class="comment">#类变量</span></span><br><span class="line">    class_var = <span class="string">&#x27;father var&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getVar</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls.class_var)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">    <span class="comment">#类变量：和父类的类变量同名，子类同名的类变量就会覆盖从父类中继承过来的类变量</span></span><br><span class="line">    class_var = <span class="string">&#x27;son var&#x27;</span></span><br><span class="line">    </span><br><span class="line">Son.getVar() <span class="comment">#输出：son var</span></span><br></pre></td></tr></table></figure>

<pre><code>- 注意：cls存在哪个类中，就表示的是当前的类。
</code></pre>
<h3 id="类方法的作用"><a href="#类方法的作用" class="headerlink" title="类方法的作用"></a>类方法的作用</h3><p>思考：实例方法中的self参数的值是从哪来的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 中的__new__和__init__的区别:</span><br><span class="line">【同】</span><br><span class="line">　　二者均是Python面向对象语言中的函数，__new__比较少用，__init__则用的比较多。</span><br><span class="line"></span><br><span class="line">【异】</span><br><span class="line">		__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象。</span><br><span class="line">		__init__是在对象创建好之后被调用的，init给对象的实例变量赋值，说明得事先存在实例变量，实例变量属于对象，实例变量存在则对象肯定也已经存在了。所以说对象存在了，则实例变量存在，实例变量存在则才可使用/调用init给实例变量赋值。</span><br><span class="line">	</span><br><span class="line">也就是： __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。</span><br></pre></td></tr></table></figure>



<h4 id="类方法-1"><a href="#类方法-1" class="headerlink" title="类方法"></a>类方法</h4><ul>
<li><p>如下场景：</p>
<p>假设我有一个学生类和一个班级类，想要实现的功能为：</p>
<pre><code>学生类继承自班级类，每实例化一个学生对象，班级人数都能增加；
最后，我想定义一些学生，获得班级中的总人数。
</code></pre>
<ul>
<li>要求：<ul>
<li>必须通过班级类获取所有的学生对象的个数</li>
<li>不能创建班级对象，只能创建学生对象</li>
</ul>
</li>
<li>思路：<ul>
<li>需要在班级类中定义一个变量，让该变量记录学生的人数（每创建好一个学生对象则让班级类中的该变量进行加1操作），那么该变量如何创建（类变量or实例变量）？<ul>
<li>应该创建类变量：上述要求明确指明了，不可以创建班级对象，因此无法访问实例变量，所以应该创建一个类变量。</li>
</ul>
</li>
<li>如果班级类中有一个类变量，该类变量记录学生的个数，需要给该类变量提供一个访问的接口，该接口应该使用类方法getNum来实现。类方法可以直接被班级类名访问。</li>
<li>当每创建好一个学生对象，如何同步使得班级类中的类变量num进行加一操作呢？<ul>
<li>在班级类中提供一个类方法addNum，该类方法可以给num类变量进行加一操作。该方法必须保证，当创建好一个学生对象的时候被调用一次。</li>
<li>如何保证每创建好一个学生对象让addNum这个类方法调用一次呢？<ul>
<li>需要在班级类中重写new方法（该new方法是可以继承给学生这个子类）,该new方法可以继承给Student子类，因此每创建一个子类对象，就会调用一次new方法，则在new方法中就可以执行给num类变量进行加一操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassRoom</span>():</span><br><span class="line">    num = <span class="number">0</span> <span class="comment">#记录学生对象的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#类方法是用来显示计数器num的数值</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNum</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls.num)</span><br><span class="line">    <span class="comment">#是用来给num进行加一操作，该方法必须保证，当创建好一个学生对象的时候被调用一次</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">cls</span>):</span><br><span class="line">        cls.num += <span class="number">1</span></span><br><span class="line">    <span class="comment">#new最终是可以被继承给Student这个子类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        ClassRoom.addNum()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">ClassRoom</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;zhangsan&#x27;</span>)</span><br><span class="line">s2 = Student(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line">s3 = Student(<span class="string">&#x27;wangwu&#x27;</span>)</span><br><span class="line">s4 = Student(<span class="string">&#x27;bobo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ClassRoom.getNum()</span><br></pre></td></tr></table></figure>

<h4 id="成员保护和访问限制"><a href="#成员保护和访问限制" class="headerlink" title="成员保护和访问限制"></a>成员保护和访问限制</h4><p>在类的内部，有各种变量和方法。这些数据成员，可以在类的外部通过实例或者类名进行调用，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在学习！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line">s.study()</span><br></pre></td></tr></table></figure>

<p>上面的调用方式是我们大多数情况下都需要的，但是往往我们也不希望所有的变量和方法能被外部访问，需要针对性地保护某些成员，限制对这些成员的访问。这样的程序才是健壮、可靠的，也符合业务的逻辑。</p>
<p>在Python中，如果要让内部成员不被外部访问，可以<strong>在成员的名字前加上两个下划线__，这个成员就变成了一个私有成员（private）</strong>。私有成员只能在类的内部访问，外部无法访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="comment">#name属性就变成了私有属性</span></span><br><span class="line">        self.__name = name</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#可以访问私有成员属性</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在学习！学习的人员是:&#x27;</span>,self.__name)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line">s.study()</span><br><span class="line"><span class="built_in">print</span>(s.__name) <span class="comment">#无法访问私有成员</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>思考：私有成员是否可以被子类继承？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,p</span>):</span><br><span class="line">        <span class="comment">#私有成员</span></span><br><span class="line">        self.__p = p</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__p)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s.get_p()) <span class="comment">#无法访问私有成员</span></span><br><span class="line"><span class="comment">#程序执行会报错！</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：私有成员是无法被继承的。</li>
</ul>
<p>那么，以双下划线开头的数据成员是不是一定就无法从外部访问呢？其实也不是！本质上，从内部机制原理讲，外部不能直接访问<code>__age</code>是因为Python解释器对外把<code>__age</code>变量改成了<code>_People__age</code>，也就是<code>_类名__age</code>（类名前是一个下划线）。因此，投机取巧的话，你可以通过<code>_ People__age</code>在类的外部访问<code>__age</code>变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,p</span>):</span><br><span class="line">        <span class="comment">#私有成员</span></span><br><span class="line">        self.__p = p</span><br><span class="line"></span><br><span class="line">p = Person(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(p._Person__p) <span class="comment">#无法访问私有成员</span></span><br></pre></td></tr></table></figure>

<p>也就是说：Python的私有成员和访问限制机制是“假”的，没有从语法层面彻底限制对私有成员的访问。这一点和常量的尴尬地位很相似。</p>
<h4 id="reflect反射"><a href="#reflect反射" class="headerlink" title="reflect反射"></a>reflect反射</h4><p>首先，我们要区分两个概念——“标识名”和“字符串”。两者字面上看起来一样，却是两种东西，比如下面的func函数和字符串“func”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">s = <span class="string">&quot;func()&quot;</span> <span class="comment">#字符串，不是函数调用</span></span><br></pre></td></tr></table></figure>

<p>前者是函数func的函数名，后者只是一个叫“func”的字符串，两者是不同的事物。我们可以用func()的方式调用函数func，但我们不能用”func”()的方式调用函数。说白了就是，不能通过字符串来调用名字看起来相同的函数！</p>
<p><strong>实例分析</strong></p>
<p>考虑有这么一个场景：需要根据用户输入url的不同，调用不同的函数，实现不同的操作，也就是一个WEB框架的url路由功能。</p>
<p>首先，有一个commons.py文件，它里面有几个函数，分别用于展示不同的页面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># commons.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是登录页面！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是退出页面&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是主页面&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其次，有一个visit.py文件，作为程序入口，接收用户输入，并根据输入展示相应的页面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># visit.py</span></span><br><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    inp = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要访问的网址:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">&#x27;login&#x27;</span>:</span><br><span class="line">        commons.login()</span><br><span class="line">    <span class="keyword">elif</span> inp == <span class="string">&#x27;logout&#x27;</span>:</span><br><span class="line">        commons.logout()</span><br><span class="line">    <span class="keyword">elif</span> inp == <span class="string">&#x27;home&#x27;</span>:</span><br><span class="line">        commons.home()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;404&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>运行visit.py，输入home，页面结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入您想访问页面的url：  home</span><br><span class="line">这是网站主页面！</span><br></pre></td></tr></table></figure>

<p>这就实现了一个简单的url路由功能，根据不同的url，执行不同的函数，获得不同的页面。</p>
<p>然而，让我们思考一个问题，如果commons文件里有成百上千个函数呢(这很常见)？难道在visit模块里写上成百上千个elif？显然这是不可能的！那么怎么办？</p>
<p>仔细观察visit.py中的代码，会发现用户输入的url字符串和相应调用的函数名好像！</p>
<p>如果能用这个字符串直接调用函数就好了！但是，前面已经说了字符串是不能用来调用函数的。为了解决这个问题，Python提供了反射机制，帮助我们实现这一想法!</p>
<p>现在将前面的visit.py修改一下，代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># visit.py</span></span><br><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    inp = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要访问的网址:&#x27;</span>)</span><br><span class="line">    <span class="comment">#inp == &quot;login&quot;</span></span><br><span class="line">    func = <span class="built_in">getattr</span>(commons,inp) <span class="comment">#func == login</span></span><br><span class="line">    func() <span class="comment">#login()</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p><code>func = getattr(commons,inp)</code>语句是关键，通过getattr()函数，从commons模块里，查找到和inp字符串“外形”相同的函数名，并将其返回，然后赋值给func变量。变量func此时就指向那个函数，func()就可以调用该函数。</p>
<p><strong>getattr()函数的使用方法：接收2个参数，前面的是一个类或者模块，后面的是一个字符串，注意了！是个字符串！</strong></p>
<p>这个过程就相当于把一个字符串变成一个函数名的过程。这是一个动态访问的过程，一切都不写死，全部根据用户输入来变化。</p>
<p><strong>瑕疵</strong>：前面的代码还有个小瑕疵，那就是如果用户输入一个非法的url，比如jpg，由于在commons里没有同名的函数，肯定会产生运行错误</p>
<p>那怎么办呢？python提供了一个hasattr()的内置函数，用法和getattr()基本类似，它可以判断commons中是否具有某个成员，返回True或False。现在将代码修改一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># visit.py</span></span><br><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    inp = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要访问的网址:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(commons,inp):</span><br><span class="line">        func = <span class="built_in">getattr</span>(commons,inp) </span><br><span class="line">        func() </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;404&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<p>这下就没有问题了！通过hasattr()的判断，可以防止非法输入导致的错误，并将其统一定位到错误页面。</p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li><p>单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于被外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
</li>
<li><p>单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<p>比如,某个服务器的配置信息存在在一个文件中,客户端通过AppConfig类来读取配置文件的信息.如果程序的运行的过程中,很多地方都会用到配置文件信息,则就需要创建很多的AppConfig实例,这样就导致内存中有很多AppConfig对象的实例,造成资源的浪费.其实这个时候AppConfig我们希望它只有一份,就可以使用单例模式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls,<span class="string">&#x27;instance&#x27;</span>):</span><br><span class="line">            Singleton.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> Singleton.instance</span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(s1),<span class="built_in">id</span>(s2))</span><br></pre></td></tr></table></figure>



<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li><p>链表就是用来修正/优化列表存在的某一个弊端的。</p>
</li>
<li><p>列表存在的弊端：</p>
<ul>
<li>列表开启的内存空间是连续的,导致如果向列表中增加或者删除元素，需要将增加或者删除元素后面的所有元素批量移动，该行为会严重影响列表元素添加或者删除的性能。</li>
<li>列表是不适合进行<strong>高频的元素添加和删除操</strong>作的。ddd</li>
</ul>
</li>
<li><p>分析：</p>
<ul>
<li>链表如何进行列表弊端的优化？<ul>
<li>优化核心在于，元素的内存空间不可以连续开辟，因此链表的内存空间不是连续开辟，则意味着链表就丧失了索引的机制。</li>
</ul>
</li>
<li>链表的作用：<ul>
<li>如果需求需要进行高频的元素增加和删除，则使用链表最合适。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,item</span>):</span><br><span class="line">        self.item = item</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#head指向第一个节点</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addHead</span>(<span class="params">self,item</span>): <span class="comment">#向链表头部插入新的节点</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.<span class="built_in">next</span> = self.head</span><br><span class="line">        self.head = node</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">travel</span>(<span class="params">self</span>): <span class="comment">#遍历链表中节点的item</span></span><br><span class="line"><span class="comment">#         print(self.head.item)</span></span><br><span class="line"><span class="comment">#         print(self.head.next.item)</span></span><br><span class="line"><span class="comment">#         print(self.head.next.next.item)</span></span><br><span class="line"><span class="comment">#         print(self.head.next.next.next.item)</span></span><br><span class="line"><span class="comment">#         print(self.head.next.next.next.next.item)</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(cur.item)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isEmpty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#判定链表是否为空，空返回True，否则返回False</span></span><br><span class="line">        <span class="keyword">return</span> self.head == <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">length</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#返回链表中节点的个数</span></span><br><span class="line">        count = <span class="number">0</span> <span class="comment">#记录节点的个数</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="comment">#向链表尾部添加新的节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self,item</span>):</span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():<span class="comment">#如果链表为空</span></span><br><span class="line">            self.head = node</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#链表为非空的情况</span></span><br><span class="line">            pre = <span class="literal">None</span> <span class="comment">#pre要指向cur前面的一个节点</span></span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment">#循环结束后cur指向了None而pre指向了最后一个节点</span></span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#将新的节点插入到pos表示的位置中</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertNode</span>(<span class="params">self,item,pos</span>):</span><br><span class="line">        node = Node(item)</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="number">0</span>:</span><br><span class="line">            self.addHead(item)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos):</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = node</span><br><span class="line">        node.<span class="built_in">next</span> = cur</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#从链表中删除item表示的节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNode</span>(<span class="params">self,item</span>):</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">if</span> self.head.item == item:<span class="comment">#删除的是第一个节点</span></span><br><span class="line">            self.head = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.item == item:</span><br><span class="line">                <span class="comment">#条件成立则cur就是我们要删除的节点</span></span><br><span class="line">                pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">link = Link()</span><br><span class="line">link.addHead(<span class="number">1</span>)</span><br><span class="line">link.addHead(<span class="number">2</span>)</span><br><span class="line">link.addHead(<span class="number">3</span>)</span><br><span class="line">link.addHead(<span class="number">4</span>)</span><br><span class="line">link.addHead(<span class="number">5</span>)</span><br><span class="line">link.append(<span class="number">6</span>)</span><br><span class="line">link.removeNode(<span class="number">5</span>)</span><br><span class="line">link.travel()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我的练习:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5 4 ?  3 2 1</span></span><br><span class="line"><span class="comment"># 0 1 2 3 4</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(): <span class="comment">#创建一个节点类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,item</span>):</span><br><span class="line">        self.item = item  <span class="comment">#存放节点的值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment">#存放节点下一个的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span>(<span class="title class_ inherited__">Node</span>): <span class="comment">#继承节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  <span class="comment">#初始化一个第一个节点的的位置</span></span><br><span class="line">        self.hand = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addhand</span>(<span class="params">self, item</span>): <span class="comment">#在第一个位置加入一个节点</span></span><br><span class="line">        node = Node(item) <span class="comment">#创建一个节点</span></span><br><span class="line">        node.<span class="built_in">next</span> = self.hand <span class="comment">#创建的新节点 指向上一个节点</span></span><br><span class="line">        self.hand = node      <span class="comment">#头节点 指向第一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traval</span>(<span class="params">self</span>):  <span class="comment">#遍历链表</span></span><br><span class="line">        s = self.hand  <span class="comment">#首先指向第一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> s != <span class="literal">None</span>: <span class="comment">#当这个节点不是空，打印这个节点</span></span><br><span class="line">            <span class="built_in">print</span>(s.item) <span class="comment">#打印这个节点的内容</span></span><br><span class="line">            s = s.<span class="built_in">next</span>    <span class="comment">#指向下一个节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IsEmpty</span>(<span class="params">self</span>): <span class="comment">#判断是否为空链表</span></span><br><span class="line">            <span class="keyword">return</span> (self.hand ==  <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lenth</span>(<span class="params">self</span>):</span><br><span class="line">        s = self.hand  <span class="comment">#首先指向第一个节点</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s != <span class="literal">None</span>: <span class="comment">#当这个节点不是空，节点数加一</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            s = s.<span class="built_in">next</span>    <span class="comment">#指向下一个节点</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">additem</span>(<span class="params">self,item,Pos</span>):</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        s = self.hand</span><br><span class="line">        <span class="keyword">if</span> Pos &lt; self.lenth():</span><br><span class="line">            <span class="keyword">while</span> p != (Pos-<span class="number">1</span>):</span><br><span class="line">                s = s.<span class="built_in">next</span> <span class="comment">#指向下一个节点</span></span><br><span class="line">                p += <span class="number">1</span>     <span class="comment">#计数</span></span><br><span class="line"></span><br><span class="line">            node = Node(item)  <span class="comment"># 创建一个新的节点</span></span><br><span class="line">            node.<span class="built_in">next</span> = s.<span class="built_in">next</span></span><br><span class="line">            s.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;超出链表的范围,无法插入<span class="subst">&#123;item&#125;</span> 到位置<span class="subst">&#123;Pos&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeitem</span>(<span class="params">self,Pos</span>):</span><br><span class="line">        s = self.hand</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p != (Pos-<span class="number">1</span>):</span><br><span class="line">            s = s.<span class="built_in">next</span></span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">        s.<span class="built_in">next</span> = s.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Link()    <span class="comment">#创建一个链表</span></span><br><span class="line">s1.addhand(<span class="number">1</span>)</span><br><span class="line">s1.addhand(<span class="number">2</span>)</span><br><span class="line">s1.addhand(<span class="number">3</span>)</span><br><span class="line">s1.addhand(<span class="number">4</span>)</span><br><span class="line">s1.addhand(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">s1.traval()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;这个字符串的节点数是：<span class="subst">&#123;s1.lenth()&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">s1.additem(<span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s1.traval()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">s1.removeitem(<span class="number">3</span>)</span><br><span class="line">s1.traval()</span><br><span class="line"><span class="built_in">print</span>(s1.IsEmpty())</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数模准备</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习（中级篇）</title>
    <url>/2023/01/08/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h1 id="RCC的使用"><a href="#RCC的使用" class="headerlink" title="RCC的使用"></a>RCC的使用</h1><p>使用HSE、HSI来配置系统时钟</p>
<h2 id="RCC的功能框图"><a href="#RCC的功能框图" class="headerlink" title="RCC的功能框图"></a>RCC的功能框图</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/RCC002.png" alt="STM32时钟树"></p>
<h2 id="HSI-HSE-来配置系统时钟"><a href="#HSI-HSE-来配置系统时钟" class="headerlink" title="HSI/HSE 来配置系统时钟"></a>HSI/HSE 来配置系统时钟</h2><p>这块地方主要要求看懂代码，学会代码的移植即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码对照功能框图和系统文件来看</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HSI_SetSysClock</span><span class="params">(<span class="type">uint32_t</span> pllmul)</span></span><br><span class="line">&#123;</span><br><span class="line">    __IO <span class="type">uint32_t</span> HSIStartUpStatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把RCC外设初始化成复位状态</span></span><br><span class="line">    RCC_DeInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能HSI</span></span><br><span class="line">    RCC_HSICmd(ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 HSI 就绪</span></span><br><span class="line">    HSIStartUpStatus = RCC-&gt;CR &amp; RCC_CR_HSIRDY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 HSI就绪之后则继续往下执行</span></span><br><span class="line">    <span class="keyword">if</span> (HSIStartUpStatus == RCC_CR_HSIRDY) &#123;</span><br><span class="line">    <span class="comment">//-------------------------------------------------------------//</span></span><br><span class="line">        <span class="comment">// 这两句是操作FLASH闪存用到的，如果不操作FLASH，这两个注释掉也没影响</span></span><br><span class="line">        <span class="comment">// 使能FLASH 预存取缓冲区</span></span><br><span class="line">        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SYSCLK周期与闪存访问时间的比例设置，这里统一设置成2</span></span><br><span class="line">        <span class="comment">// 设置成2的时候，SYSCLK低于48M也可以工作，如果设置成0或者1的时候，</span></span><br><span class="line">        <span class="comment">// 如果配置的SYSCLK超出了范围的话，则会进入硬件错误，程序就死了</span></span><br><span class="line">        <span class="comment">// 0：0 &lt; SYSCLK &lt;= 24M</span></span><br><span class="line">        <span class="comment">// 1：24&lt; SYSCLK &lt;= 48M</span></span><br><span class="line">        <span class="comment">// 2：48&lt; SYSCLK &lt;= 72M</span></span><br><span class="line">        FLASH_SetLatency(FLASH_Latency_2);</span><br><span class="line">    <span class="comment">//------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AHB预分频因子设置为1分频，HCLK = SYSCLK</span></span><br><span class="line">        RCC_HCLKConfig(RCC_SYSCLK_Div1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// APB2预分频因子设置为1分频，PCLK2 = HCLK</span></span><br><span class="line">        RCC_PCLK2Config(RCC_HCLK_Div1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// APB1预分频因子设置为1分频，PCLK1 = HCLK/2</span></span><br><span class="line">        RCC_PCLK1Config(RCC_HCLK_Div2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-----------设置各种频率主要就是在这里设置-------------------//</span></span><br><span class="line">        <span class="comment">// 设置PLL时钟来源为HSE，设置PLL倍频因子</span></span><br><span class="line">        <span class="comment">// PLLCLK = 4MHz * pllmul</span></span><br><span class="line">        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, pllmul);</span><br><span class="line">    <span class="comment">//-- -----------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启PLL</span></span><br><span class="line">        RCC_PLLCmd(ENABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待 PLL稳定</span></span><br><span class="line">        <span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当PLL稳定之后，把PLL时钟切换为系统时钟SYSCLK</span></span><br><span class="line">        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取时钟切换状态位，确保PLLCLK被选为系统时钟</span></span><br><span class="line">        <span class="keyword">while</span> (RCC_GetSYSCLKSource() != <span class="number">0x08</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果HSI开启失败，那么程序就会来到这里，用户可在这里添加出错的代码处理</span></span><br><span class="line">        <span class="comment">// 当HSE开启失败或者故障的时候，单片机会自动把HSI设置为系统时钟，</span></span><br><span class="line">        <span class="comment">// HSI是内部的高速时钟，8MHZ</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用HSE功能类似这里不多赘述.</p>
<hr>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断其实就是异常</p>
<p>系统出现异常时停止执行主程序 去执行中断服务程序,执行完中断服务程序之后再接着执行主程序的内容</p>
<p>这里中断可以嵌套,至于先执行哪一个中断,看中断优先级.</p>
<h2 id="中断的类型"><a href="#中断的类型" class="headerlink" title="中断的类型"></a>中断的类型</h2><ol>
<li>系统的异常,体现再内核</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr01.png" alt="F103系统异常清单"></p>
<ol start="2">
<li>外部中断,体现到外设中</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr02.png" alt="F103外部中断清单"></p>
<h2 id="中断的管理-NVIC"><a href="#中断的管理-NVIC" class="headerlink" title="中断的管理-NVIC"></a>中断的管理-NVIC</h2><p>NVIC(嵌套向量中断控制器):管理芯片中所有中断的部分 </p>
<p>中断服务固件库在 CMSIS文件夹中的 core_cm3.c 文件中和 misc.c中</p>
<h3 id="NVIC寄存器"><a href="#NVIC寄存器" class="headerlink" title="NVIC寄存器"></a>NVIC寄存器</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置中断的时候我们一般只用ISER、ICER和IP这三个寄存器，ISER用来使能中断，ICER用来失能中断，IP用来设置中断优先级。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __IO <span class="type">uint32_t</span> ISER[<span class="number">8</span>];       <span class="comment">// 中断使能寄存器,相当于总开关</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED0[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ICER[<span class="number">8</span>];       <span class="comment">// 中断清除寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RSERVED1[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ISPR[<span class="number">8</span>];       <span class="comment">// 中断使能悬起寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED2[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> ICPR[<span class="number">8</span>];       <span class="comment">// 中断清除悬起寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED3[<span class="number">24</span>];</span><br><span class="line">    __IO <span class="type">uint32_t</span> IABR[<span class="number">8</span>];       <span class="comment">// 中断有效位寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED4[<span class="number">56</span>];</span><br><span class="line">    __IO <span class="type">uint8_t</span>  IP[<span class="number">240</span>];       <span class="comment">// 中断优先级寄存器(8Bit wide)</span></span><br><span class="line">    <span class="type">uint32_t</span> RESERVED5[<span class="number">644</span>];</span><br><span class="line">    __O  <span class="type">uint32_t</span> STIR;          <span class="comment">// 软件触发中断寄存器</span></span><br><span class="line">&#125;  NVIC_Type;</span><br></pre></td></tr></table></figure>

<h2 id="中断优先级的定义"><a href="#中断优先级的定义" class="headerlink" title="中断优先级的定义"></a>中断优先级的定义</h2><p>在NVIC 有一个专门的寄存器：中断优先级寄存器NVIC_IPRx.<strong>在F103中,只有高四位有效.</strong></p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr04.png" alt="使用4bit表达优先级"></p>
<p>用于表达优先级的这4bit，又被分组成抢占优先级和子优先级。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行， 如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p>
<h3 id="优先级的分组"><a href="#优先级的分组" class="headerlink" title="优先级的分组"></a>优先级的分组</h3><p>优先级的分组由内核外设SCB的应用程序中断及复位控制寄存器AIRCR的PRIGROUP[10:8]位决定，F103分为了5组，具体如下：主优先级=抢占优先级</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr045.png" alt="img"></p>
<p>设置优先级分组可调用库函数NVIC_PriorityGroupConfig()实现，有关NVIC中断相关的库函数都在库文件misc.c和misc.h中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 配置中断优先级分组：抢占优先级和子优先级</span></span><br><span class="line"><span class="comment">* 形参如下：</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_0: 0bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            4 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_1: 1 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            3 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_2: 2 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            2 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_3: 3 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            1 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @arg NVIC_PriorityGroup_4: 4 bit for抢占优先级</span></span><br><span class="line"><span class="comment">*                            0 bits for 子优先级</span></span><br><span class="line"><span class="comment">* @注意 如果优先级分组为0，则抢占优先级就不存在，优先级就全部由子优先级控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置优先级分组</span></span><br><span class="line">    SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr05.png" alt="优先级分组真值表"></p>
<h2 id="中断编程的步骤"><a href="#中断编程的步骤" class="headerlink" title="中断编程的步骤"></a>中断编程的步骤</h2><ol>
<li>使能中断请求,相当于打开总开关.–中断使能寄存器配置</li>
<li>配置中断优先级分组, 配置SCB_ARCR,—调用NVIC_PriorityGroupConfig();</li>
<li>配置NVIC寄存器, 并初始化NVIC_InitTypeDef 结构体— 1.配置中断源(文件在STM32f10x.h中的IRQ中) 2.抢占优先级的值(根据优先级组配置) 3. 子优先级 4.内部使能.</li>
<li>编写中断服务函数!!! 名称一定不能写错,每个函数的名称在启动文件中,写错了会死循环!</li>
</ol>
<p>为了管理方便将中断全部写到 stm32f10x.it.c的函数中</p>
<hr>
<h1 id="EXTI-外部中断控制器"><a href="#EXTI-外部中断控制器" class="headerlink" title="EXTI- 外部中断控制器"></a>EXTI- 外部中断控制器</h1><p>EXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的20个中断/事件线。 每个中断/事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。EXTI可以实现对每个中断/事件线进行单独配置， 可以单独配置为中断或者事件，以及触发事件的属性。</p>
<h2 id="EXTI的功能框图"><a href="#EXTI的功能框图" class="headerlink" title="EXTI的功能框图"></a>EXTI的功能框图</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI002.png" alt="EXTI功能框图"></p>
<blockquote>
<p>一个斜杠并标注“20”字样，这个表示在控制器内部类似的信号线路有20个.</p>
</blockquote>
<p>EXTI有20个中断/事件线，每个GPIO都可以被设置为输入线，占用EXTI0至EXTI15， 还有另外七根用于特定的外设事件</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI01.png" alt="EXTI中断/事件线"></p>
<p>EXTI0至EXTI15用于GPIO</p>
<h2 id="EXTI初始化结构体"><a href="#EXTI初始化结构体" class="headerlink" title="EXTI初始化结构体"></a>EXTI初始化结构体</h2><p>标准库函数对每个外设都建立了一个初始化结构体，比如EXTI_InitTypeDef，结构体成员用于设置外设工作参数，并由外设初始化配置函数， 比如EXTI_Init()调用，这些设定参数将会设置外设相应的寄存器，达到配置外设工作环境的目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> EXTI_Line;                 <span class="comment">// 中断/事件线</span></span><br><span class="line">    EXTIMode_TypeDef EXTI_Mode;         <span class="comment">// EXTI模式</span></span><br><span class="line">    EXTITrigger_TypeDef EXTI_Trigger;   <span class="comment">// 触发类型</span></span><br><span class="line">    FunctionalState EXTI_LineCmd;       <span class="comment">// EXTI使能</span></span><br><span class="line">&#125; EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h2 id="外部中断控制实验设计"><a href="#外部中断控制实验设计" class="headerlink" title="外部中断控制实验设计"></a>外部中断控制实验设计</h2><p>我们设计使用外接的按键来作为触发源，使得控制器产生中断，并在中断服务函数中实现控制RGB彩灯的任务。</p>
<h3 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI004.png" alt="按键电路设计"></p>
<h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><ol>
<li>初始化用来产生中断的GPIO；</li>
<li>初始化EXTI；</li>
<li>配置NVIC；</li>
<li>编写中断服务函数；</li>
</ol>
<ul>
<li>bsp_exti.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.配置NVIC</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NVIC_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	NVIC_InitTypeDef NVIC_initstruct;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选择中断的位置</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//选择优先级的分组为1</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);</span><br><span class="line">	<span class="comment">// 设置主优先级</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 设置子优先级</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//使能</span></span><br><span class="line">	NVIC_initstruct.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	</span><br><span class="line">	NVIC_Init(&amp;NVIC_initstruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化用来产生中断的GPIO---键盘</span></span><br><span class="line"><span class="comment">//2.初始化EXTI</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_KEY1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	EXTI_InitTypeDef EXTI_initstruct;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_PIN; </span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_PORT, &amp;GPIO_KEY1_initstruct);</span><br><span class="line">	<span class="comment">//初始化NVIC</span></span><br><span class="line">	NVIC_Config();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//时钟打开！！！</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line">	<span class="comment">//选择输入线</span></span><br><span class="line">	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//因为是PA0，所以选择line0</span></span><br><span class="line">	EXTI_initstruct.EXTI_Line = EXTI_Line0;</span><br><span class="line">	<span class="comment">//调节模式为中断模式</span></span><br><span class="line">	EXTI_initstruct.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">	<span class="comment">//触发方式设置为 上升触发</span></span><br><span class="line">	EXTI_initstruct.EXTI_Trigger = EXTI_Trigger_Rising;</span><br><span class="line">	<span class="comment">//使能</span></span><br><span class="line">	EXTI_initstruct.EXTI_LineCmd = ENABLE;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	EXTI_Init(&amp;EXTI_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_exti. h文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_EXTI.H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_EXTI.H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_KEY1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY1 的宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_EXTI.H*/</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>stm32f10x_it.c 中添加</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_G_TOGGLE;</span><br><span class="line">	&#125;</span><br><span class="line">	EXTI_ClearITPendingBit(EXTI_Line0);		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main 函数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_exti.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                     <span class="comment">//初始化LED灯</span></span><br><span class="line">	EXTI_KEY1_Config();                         <span class="comment">//打开中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Systick-系统定时器"><a href="#Systick-系统定时器" class="headerlink" title="Systick-系统定时器"></a>Systick-系统定时器</h1><p>系统定时器：24 位 递减 存在于内核中，systick的寄存器如图所示</p>
<p>![image-20230103164648793](STM32学习- 中级/image-20230103164648793.png)</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic01.png" alt="SysTick寄存器汇总"></p>
<p>其中CTRL寄存器 又有四个位来控制</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic02.png" alt="SysTick控制及状态寄存器"></p>
<p>另外两个常用的寄存器 如下图所示：</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic03.png" alt="SysTick重装载数值寄存器"></p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic04.png" alt="SysTick当前数值寄存器"></p>
<h2 id="定时函数的设计"><a href="#定时函数的设计" class="headerlink" title="定时函数的设计"></a>定时函数的设计</h2><h2 id="硬件设计-1"><a href="#硬件设计-1" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>SysTick属于单片机内部的外设，不需要额外的硬件电路，剩下的只需一个LED灯即可。</p>
<p><strong>notice:</strong> 一般把systick 优先级设置成15(最低), 如果其他中断和systick的中断设置的优先级一样,比较系统默认的优先级.</p>
<h2 id="软件设计-1"><a href="#软件设计-1" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="定时时间的计算"><a href="#定时时间的计算" class="headerlink" title="定时时间的计算"></a>定时时间的计算</h3><ul>
<li>计时的时间只于 RELOAD和CLK 有关</li>
<li>CLK：可以设置成系统时钟(默认72M),或者系统时钟/8(9M), 由CTRL寄存器控制</li>
<li>RELOAD,由我们自己控制</li>
</ul>
<p>$t=reload×(1/CLK)$</p>
<p>常用1us 1ms,将clk设置成72M,reload设置成72,72000即可.</p>
<h3 id="systick的配置"><a href="#systick的配置" class="headerlink" title="systick的配置"></a>systick的配置</h3><p>在core_cm3.h文件中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __INLINE <span class="type">uint32_t</span> <span class="title function_">SysTick_Config</span><span class="params">(<span class="type">uint32_t</span> ticks)</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">//检查 tick是否大于24位</span></span><br><span class="line">  <span class="keyword">if</span> (ticks &gt; SysTick_LOAD_RELOAD_Msk)  <span class="keyword">return</span> (<span class="number">1</span>);            </span><br><span class="line">  <span class="comment">//设置reload的值                                                             </span></span><br><span class="line">  SysTick-&gt;LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//设置优先级,默认为15(最低) </span></span><br><span class="line">  NVIC_SetPriority (SysTick_IRQn, (<span class="number">1</span>&lt;&lt;__NVIC_PRIO_BITS) - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* Load the SysTick Counter Value */</span>  </span><br><span class="line">  SysTick-&gt;VAL   = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">//  配置systick时钟为72M, 使能中断, 使能systick,然后开始计数</span></span><br><span class="line">  SysTick-&gt;CTRL  = SysTick_CTRL_CLKSOURCE_Msk | </span><br><span class="line">                   SysTick_CTRL_TICKINT_Msk   | </span><br><span class="line">                   SysTick_CTRL_ENABLE_Msk;                    </span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);                                                  <span class="comment">/* Function successful */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><ul>
<li>bsp_systick.c文件 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">__IO u32 TimingDelay; <span class="comment">//定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_us</span><span class="params">(__IO u32 nTime)</span> <span class="comment">//us延时</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	SysTick_Config(<span class="number">72</span>); <span class="comment">//1us 延时一次</span></span><br><span class="line">	TimingDelay = nTime; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(TimingDelay != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_ms</span><span class="params">(__IO u32 nTime)</span> <span class="comment">//ms延时</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	SysTick_Config(<span class="number">72000</span>); <span class="comment">//1ms 延时一次</span></span><br><span class="line">	TimingDelay = nTime;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(TimingDelay != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TimingDelay_Decrement</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//定义中段服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TimingDelay != <span class="number">0x00</span>) </span><br><span class="line">	&#123;</span><br><span class="line">        TimingDelay--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_systick.h</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_SYSTICK,H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_SYSTICK,H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_us</span><span class="params">(__IO u32 nTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Systick_dalay_ms</span><span class="params">(__IO u32 nTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TimingDelay_Decrement</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_SYSTICK,H*/</span></span></span><br></pre></td></tr></table></figure>

<p>中断服务函数 stm32f10x_it.c中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TimingDelay_Decrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主函数中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_systick.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();     <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>); <span class="comment">//定时器延时</span></span><br><span class="line">		LED_GREEN;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		Systick_dalay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h1><h2 id="串口通信的概念"><a href="#串口通信的概念" class="headerlink" title="串口通信的概念"></a>串口通信的概念</h2><p>这里和之前的51学习中的串口通信概念差不多</p>
<p>为了巩固这里再写一遍.</p>
<p>串口通信是硬件与硬件的信息传输</p>
<h3 id="串行与并行"><a href="#串行与并行" class="headerlink" title="串行与并行"></a>串行与并行</h3><p>假设传八个数据</p>
<ul>
<li>串行:一根线一位一位传输</li>
<li>并行: 8根线 同时传输八位</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>串行</th>
<th>并行</th>
</tr>
</thead>
<tbody><tr>
<td>通讯距离</td>
<td>远</td>
<td>近</td>
</tr>
<tr>
<td>抗干扰能力</td>
<td>强</td>
<td>弱</td>
</tr>
<tr>
<td>传输速率</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>成本</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="全双工-半双工-单工"><a href="#全双工-半双工-单工" class="headerlink" title="全双工 半双工 单工"></a>全双工 半双工 单工</h3><ul>
<li>全双工: 可以双向同时收发数据</li>
<li>半双工: 可以双向收发数据,但需要分时</li>
<li>单工: 只能单向收发数据</li>
</ul>
<h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步 异步"></a>同步 异步</h3><ul>
<li><p>同步: 有时钟信号都是同步</p>
</li>
<li><p> 异步:  不需要时钟信号</p>
</li>
</ul>
<p><strong>异步有 数据的起始位,主体数据,校验位,通信停止位</strong></p>
<h3 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h3><p>比特率: 每秒传输的<strong>二进制位数</strong>.</p>
<p>波特率: 每秒传输的<strong>码元</strong>个数.</p>
<p>码元-等于一个二进制位数时,比特率等于波特率</p>
<h2 id="串口的通信协议"><a href="#串口的通信协议" class="headerlink" title="串口的通信协议"></a>串口的通信协议</h2><p>不只是针对STM32,对于其他处理器也适用</p>
<p>物理层:硬件部分</p>
<p>协议层:软件部分</p>
<p>三个常用串口协议,主要是电平的区别,STM32的电平为TTL电平</p>
<h3 id="RS-232"><a href="#RS-232" class="headerlink" title="RS-232"></a>RS-232</h3><p>电平高:-15V,低:+15V</p>
<p>一般由于工业设备,静电比较多,粉尘比较多,容错率比较高</p>
<h3 id="USB-转串口"><a href="#USB-转串口" class="headerlink" title="USB 转串口"></a>USB 转串口</h3><p>TTL 电平转USB电平</p>
<p>常用芯片:CH340等.</p>
<h3 id="原生的串口转串口"><a href="#原生的串口转串口" class="headerlink" title="原生的串口转串口"></a>原生的串口转串口</h3><p>都是TTL电平,不需要电平转换芯片</p>
<p>比如一些蓝牙模块,wifi模块</p>
<h3 id="串口的数据包"><a href="#串口的数据包" class="headerlink" title="串口的数据包"></a>串口的数据包</h3><p>起始位: 1个0电位</p>
<p>数据位</p>
<p>检验位: </p>
<p>奇校验(1的个数是奇数),偶校验,0校验(校验位总为0),1校验.</p>
<p>结束位</p>
<h2 id="STM32的串口的功能"><a href="#STM32的串口的功能" class="headerlink" title="STM32的串口的功能"></a>STM32的串口的功能</h2><h3 id="串口功能框图"><a href="#串口功能框图" class="headerlink" title="串口功能框图"></a>串口功能框图</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART008.png" alt="USART功能框图"></p>
<p>TX：数据发送</p>
<p>RX：数据接收</p>
<p>SCLK：同步通讯使用时用的时钟</p>
<p>n：请求, 一般不使用</p>
<p>![STM32F103VET6芯片的USART引脚](STM32学习- 中级/USART03.png)</p>
<p>各个串口的引脚图,如图所示</p>
<p>这里注意串口1和其他串口接的总线位置不一样,如果需要查找详细的串口位置,需要查找官方的数据手册查找串口位置.</p>
<h3 id="各个数据寄存器"><a href="#各个数据寄存器" class="headerlink" title="各个数据寄存器"></a>各个数据寄存器</h3><ul>
<li><p>数据寄存器寄存器: USART_DR: 九位有效,具体多少位由USART_CR1控制</p>
</li>
<li><p>控制寄存器1 USART_CR1: 1. M,1:8位;0:9位 2. PCE,PS 控制校验位, PE看是否出现错误 3.PEIE: 控制中断使能</p>
</li>
</ul>
<p>4.</p>
<ul>
<li><p>控制寄存器2 USART_CR2: STOP</p>
</li>
<li><p>状态寄存器: USART_SR: TEX,TC,观测是否发送完成</p>
</li>
<li><p>波特比率寄存器(USART_BRR) :前面11位是整数部分,后面3位是小数部分</p>
</li>
</ul>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART010.png" alt="波特率计算"></p>
<p>fck要注意是哪个串口,是72M还是36M,</p>
<p>小数部分即为 1/16, 所以只需呀将小数部分*16即可得到小数部分</p>
<h2 id="中断接收和发送的实验设计"><a href="#中断接收和发送的实验设计" class="headerlink" title="中断接收和发送的实验设计"></a>中断接收和发送的实验设计</h2><h3 id="硬件设计-2"><a href="#硬件设计-2" class="headerlink" title="硬件设计"></a>硬件设计</h3><p>usb转串口</p>
<p>电脑是USB,单片机是TTL电平,所以需要这个CH340转电平,这里需要安装CH340的驱动</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART011.png" alt="USB转串口硬件设计"></p>
<p>RX和TX的连接, 开发板上通过跳帽 连接PA9和PA10,</p>
<p>如果需要连接其他串口需要拔掉跳帽通过杜邦线连接到其他串口</p>
<h3 id="软件设计-2"><a href="#软件设计-2" class="headerlink" title="软件设计"></a>软件设计</h3><ul>
<li><strong>USART的结构体介绍</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> USART_BaudRate;            <span class="comment">/*!&lt;用来存放波特率,这里只需要填写115200即可</span></span><br><span class="line"><span class="comment">                                           The baud rate is computed using the following formula:</span></span><br><span class="line"><span class="comment">                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct-&gt;USART_BaudRate)))</span></span><br><span class="line"><span class="comment">                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_WordLength;          <span class="comment">/*!&lt; 用来设置字长是8位还是9位</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Word_Length */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_StopBits;            <span class="comment">/*!&lt;选择结束位是1个停止位还是0.5,1.5,2个.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Stop_Bits */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_Parity;              <span class="comment">/*!&lt; 配置校验位.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Parity</span></span><br><span class="line"><span class="comment">                                           @note When parity is enabled, the computed parity is inserted</span></span><br><span class="line"><span class="comment">                                                 at the MSB position of the transmitted data (9th bit when</span></span><br><span class="line"><span class="comment">                                                 the word length is set to 9 data bits; 8th bit when the</span></span><br><span class="line"><span class="comment">                                                 word length is set to 8 data bits). */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">uint16_t</span> USART_Mode;                <span class="comment">/*!&lt;控制是使能发送模式还是使能接收模式 is enabled or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Mode */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint16_t</span> USART_HardwareFlowControl; <span class="comment">/*!&lt;硬件控制流</span></span><br><span class="line"><span class="comment">                                           or disabled.</span></span><br><span class="line"><span class="comment">                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */</span></span><br><span class="line">&#125; USART_InitTypeDef;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面的结构体和同步通信有关,不需要初始化,如果不需要使用同步通信</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>主要用到的函数</strong></li>
</ul>
<ol>
<li>结构体初始化函数</li>
<li>数据发送函数</li>
<li>数据接收函数</li>
<li>中断状态位获取函数,中断清除等</li>
</ol>
<ul>
<li><strong>编程的要点</strong></li>
</ul>
<ol>
<li>初始化串口用到的GPIO, PA9,PA10</li>
<li>初始化串口</li>
<li>配置中断(接收中断,中断优先级)</li>
<li>使能串口</li>
<li>编写发送和接收函数</li>
<li>编写中断服务函数</li>
</ol>
<ul>
<li>bsp_usart.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PIN     GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PORT    GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_CLK     RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PIN     GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PORT    GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_BT   115200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CLK  RCC_APB2Periph_USART1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_IRQ  USART1_IRQn</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_USART_H*/</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>bsp_usart.c文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化串口用到的GPIO, PA9,PA10,初始化串口,配置中断(接收中断,中断优先级),使能串口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">NVIC_Configuration</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 嵌套向量中断控制器组选择 */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置USART为中断源 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = USART_IRQ;</span><br><span class="line">    <span class="comment">/* 抢断优先级为1 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 子优先级为1 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    <span class="comment">/* 初始化配置NVIC */</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	<span class="comment">//配置Rx GPIO的PA9</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(RX_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = RX_PIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(RX_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配值TX GPIO的PA10</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = TX_PIN;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(TX_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置USART1</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(USART_CLK , ENABLE);</span><br><span class="line">	</span><br><span class="line">	USART_InitStructure.USART_BaudRate = USART_BT;</span><br><span class="line">	</span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;</span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	</span><br><span class="line">	USART_Init(USART1 , &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置中断</span></span><br><span class="line">	</span><br><span class="line">	NVIC_Configuration(); <span class="comment">// 串口中断优先级配置</span></span><br><span class="line">	</span><br><span class="line">	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); <span class="comment">//Receive Data register not empty interrupt</span></span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1, ENABLE);<span class="comment">// 使能串口 配置UE位,相当于打开了总开关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送字符函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送1B函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendByte</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(pUSARTx, data);</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送 2B函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Send2Byte</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint16_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> data_h = (data &amp; <span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span> ;</span><br><span class="line">	<span class="type">uint8_t</span> data_l = (data &amp; <span class="number">0x00ff</span>);</span><br><span class="line">	</span><br><span class="line">	USART_SendByte(pUSARTx, data_h );</span><br><span class="line">	USART_SendByte(pUSARTx, data_l );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 8位数据的数组的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendARRAY</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> *<span class="built_in">array</span>,<span class="type">uint8_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		USART_SendByte(pUSARTx, <span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendSTR</span><span class="params">(USART_TypeDef* pUSARTx, <span class="type">uint8_t</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		USART_SendByte(pUSARTx, *(str+i));</span><br><span class="line">		i++;</span><br><span class="line">	&#125;<span class="keyword">while</span>(*(str+i) != <span class="string">&#x27;\0&#x27;</span> );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向c库函数printf到串口，重定向后可使用printf函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 发送一个字节数据到串口 */</span></span><br><span class="line">    USART_SendData(USART1, (<span class="type">uint8_t</span>) ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待发送完毕 */</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 等待串口输入数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)USART_ReceiveData(USART1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在换串口时要注意"><a href="#在换串口时要注意" class="headerlink" title="在换串口时要注意"></a>在换串口时要注意</h3><ol>
<li>时钟的总线</li>
<li>GPIO的引脚</li>
<li>中断的中断源, 函数名</li>
<li>硬件上: 将USB转串口 用杜邦线连接到新的串口上</li>
</ol>
<h3 id="窗口接收"><a href="#窗口接收" class="headerlink" title="窗口接收"></a>窗口接收</h3><p>在stm32f10x_it.c中,添加中断, 这样有了一个接收文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> ucTemp;</span><br><span class="line">    <span class="keyword">if</span> (USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET) </span><br><span class="line">	&#123;</span><br><span class="line">        ucTemp = USART_ReceiveData( USART1 );</span><br><span class="line">        USART_SendData(USART1,ucTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="串口控制LED的开与关"><a href="#串口控制LED的开与关" class="headerlink" title="串口控制LED的开与关"></a>串口控制LED的开与关</h2><p>只需在main.c文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_usart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> ch;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	USART1_Config();</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LED text\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LED = %c\n&quot;</span>,ch);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;LED = %c\n&quot;</span>,ch);</span><br><span class="line">		<span class="keyword">switch</span>(ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: LED_RED;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;红灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>: LED_GREEN;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;绿灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: LED_BLUE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;蓝灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: LED_YELLOW;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;黄灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>: LED_PURPLE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;紫灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: LED_CYAN;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;青灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: LED_WHITE;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;白灯点亮\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: LED_RGBOFF;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;熄灭\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><h2 id="DMA直接存储器的简介"><a href="#DMA直接存储器的简介" class="headerlink" title="DMA直接存储器的简介"></a>DMA直接存储器的简介</h2><p>DMA(Direct Memory Access)—直接存储器存取</p>
<p>作用: 把数据从一个地方搬到另一个地方, 而且不占用CPU</p>
<p>DMA1:有7个通道,可以实现P-&gt;M, M-&gt;P, M-&gt;M</p>
<p>DMA2(只存在于大容量,或者互联型中):有5个通道,可以实现P-&gt;M, M-&gt;P, M-&gt;M</p>
<h3 id="DMA的功能框图"><a href="#DMA的功能框图" class="headerlink" title="DMA的功能框图"></a>DMA的功能框图</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DMA002.png" alt="DMA框图"></p>
<ol>
<li>DMA请求,由发送端,外设等产生</li>
<li>DMA通道,DMA1有7条,DMA2有5条</li>
<li>当多个通道同时发送请求映射,仲裁器(<strong>第一阶段</strong>: 先由DMA_CCRx的 PL控制优先级决定, <strong>第二阶段</strong>: 优先级相同时再串口通道的编号优先级决定)</li>
</ol>
<p>如果不适用DMA,系统会默认使用CPU</p>
<h3 id="固件库编程"><a href="#固件库编程" class="headerlink" title="固件库编程"></a>固件库编程</h3><ol>
<li>DMA结构体成员</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralBaseAddr;   <span class="comment">// 外设地址 DMA_CPAR寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryBaseAddr;       <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_DIR;                  <span class="comment">// 传输方向 DMA_CCR 的DIR: P-&gt;M, M-&gt;P, </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_BufferSize;           <span class="comment">// 传输数目            </span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralInc;        <span class="comment">// 外设地址增量模式   DMA_CCR 的PINC,由普通和循环2个模式</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryInc;            <span class="comment">// 存储器地址增量模式  DMA_CCR 的MINC</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_PeripheralDataSize;   <span class="comment">// 外设数据宽度    DMA_CCR 的MSIZE和PSIZE确定</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_MemoryDataSize;       <span class="comment">// 存储器数据宽度</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> DMA_Mode;                 <span class="comment">// 模式选择 DMA_ISR </span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_Priority;             <span class="comment">// 通道优先级</span></span><br><span class="line">    <span class="type">uint32_t</span> DMA_M2M;                  <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">&#125; DMA_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>固件库函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="comment">//结构体初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;</span><br><span class="line"><span class="comment">//使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="comment">//中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="M-to-M实验设计"><a href="#M-to-M实验设计" class="headerlink" title="M to M实验设计"></a>M to M实验设计</h2><p>FLASH to SRAM </p>
<h3 id="硬件设计-3"><a href="#硬件设计-3" class="headerlink" title="硬件设计"></a>硬件设计</h3><p>这里不需要其他的外设要求</p>
<h3 id="软件设计-3"><a href="#软件设计-3" class="headerlink" title="软件设计"></a>软件设计</h3><ul>
<li>编程要点: </li>
</ul>
<ol>
<li>定义一个变量存储再FLASH文件中， 再定义存储在SRAM中的变量</li>
<li>初始化DMA结构体</li>
<li>使能DMA时钟；</li>
<li>配置DMA数据参数；</li>
<li>使能DMA，进行传输；</li>
<li>等待传输完成，并对源数据和目标地址数据进行比较。</li>
</ol>
<ol>
<li>定义一个变量存储再FLASH文件中， 再定义存储在SRAM中的变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x01020304</span>,<span class="number">0x05060708</span>,<span class="number">0x090A0B0C</span>,<span class="number">0x0D0E0F10</span>,</span><br><span class="line">    <span class="number">0x11121314</span>,<span class="number">0x15161718</span>,<span class="number">0x191A1B1C</span>,<span class="number">0x1D1E1F20</span>,</span><br><span class="line">    <span class="number">0x21222324</span>,<span class="number">0x25262728</span>,<span class="number">0x292A2B2C</span>,<span class="number">0x2D2E2F30</span>,</span><br><span class="line">    <span class="number">0x31323334</span>,<span class="number">0x35363738</span>,<span class="number">0x393A3B3C</span>,<span class="number">0x3D3E3F40</span>,</span><br><span class="line">    <span class="number">0x41424344</span>,<span class="number">0x45464748</span>,<span class="number">0x494A4B4C</span>,<span class="number">0x4D4E4F50</span>,</span><br><span class="line">    <span class="number">0x51525354</span>,<span class="number">0x55565758</span>,<span class="number">0x595A5B5C</span>,<span class="number">0x5D5E5F60</span>,</span><br><span class="line">    <span class="number">0x61626364</span>,<span class="number">0x65666768</span>,<span class="number">0x696A6B6C</span>,<span class="number">0x6D6E6F70</span>,</span><br><span class="line">    <span class="number">0x71727374</span>,<span class="number">0x75767778</span>,<span class="number">0x797A7B7C</span>,<span class="number">0x7D7E7F80</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义DMA传输目标存储器</span></span><br><span class="line"><span class="comment">* 存储在内部的SRAM中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br></pre></td></tr></table></figure>

<p>2.初始化DMA结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_MTM_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打开DMA的时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(DMA1_CLK, ENABLE);</span><br><span class="line">	<span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)aSRC_Const_Buffer; <span class="comment">// 外设地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)aDST_Buffer;           <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;                      <span class="comment">//从Flash 中 Sourse发出 </span></span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE;                         <span class="comment">//传输数目  </span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;         <span class="comment">// 外设地址增量模式：    使能</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                 <span class="comment">// 存储器地址增量模式：  使能</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; <span class="comment">// 外设数据宽度：   一个字：32位</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;         <span class="comment">// 存储器数据宽度： 一个字：32位</span></span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           <span class="comment">// 模式选择 普通模式</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     <span class="comment">// 通道优先级 这里只有一个通道随意配置</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;                             <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结构体初始化以及使能</span></span><br><span class="line">	DMA_Init(DMA1_Channel, &amp;DMA_InitStructure);</span><br><span class="line">    DMA_ClearFlag(DMA1_FLAG);<span class="comment">// 给一个完成标志位</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.头文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DSP_DMA_MTM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DSP_DMA_MTM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE     32</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_CLK        RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_Channel    DMA1_Channel6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_FLAG       DMA1_FLAG_HT6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint32_t</span> aSRC_Const_Buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> aDST_Buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_MTM_Config</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Buffercmp</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span>* pBuffer,<span class="type">uint32_t</span>* pBuffer1, <span class="type">uint16_t</span> BufferLength)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__DSP_DMA_MTM_H*/</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>数据比较函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">Buffercmp</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span>* pBuffer,</span></span><br><span class="line"><span class="params">                <span class="type">uint32_t</span>* pBuffer1, <span class="type">uint16_t</span> BufferLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 数据长度递减 */</span></span><br><span class="line">    <span class="keyword">while</span> (BufferLength--) &#123;</span><br><span class="line">        <span class="comment">/* 判断两个数据源是否对应相等 */</span></span><br><span class="line">        <span class="keyword">if</span> (*pBuffer != *pBuffer1) &#123;</span><br><span class="line">            <span class="comment">/* 对应数据源不相等马上退出函数，并返回0 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 递增两个数据源的地址指针 */</span></span><br><span class="line">        pBuffer++;</span><br><span class="line">        pBuffer1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 完成判断并且对应数据相对 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.主函数中显示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_dma_mtm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint8_t</span> s = <span class="number">0</span>;</span><br><span class="line">	LED_GPIO_G_Config();</span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;</span><br><span class="line">	</span><br><span class="line">	DMA_MTM_Config();</span><br><span class="line">	<span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG)== RESET);</span><br><span class="line">	</span><br><span class="line">	s = Buffercmp(aSRC_Const_Buffer,aDST_Buffer, BUFFER_SIZE);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(s == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_GREEN; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="M-to-P-实验设计"><a href="#M-to-P-实验设计" class="headerlink" title="M to P 实验设计"></a>M to P 实验设计</h2><p><strong>编程要点</strong></p>
<ol>
<li>初始化串口</li>
<li>配置DMA初始化结构体</li>
<li>编写主函数 开启串口,发送DMA请求</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.初始化串口只需要拷贝之前的初始化串口内容即可这里就不多写了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.配置DMA初始化结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_DMA_MTP_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打开DMA的时钟</span></span><br><span class="line">	RCC_AHBPeriphClockCmd(DMA1_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//数据从哪里来, 数据到哪里去</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;            <span class="comment">// 外设地址  DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)SendBuff;              <span class="comment">// 存储器地址 DMA_CPAR寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;                      <span class="comment">//从Flash 中 Sourse发出 </span></span><br><span class="line">	</span><br><span class="line">	 <span class="comment">//要传多少,单位是什么</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;                        <span class="comment">//传输数目  </span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;         <span class="comment">// 外设地址增量模式：    使能</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;                  <span class="comment">// 存储器地址增量模式：  使能</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;  <span class="comment">// 外设数据宽度：   一个字节：8位</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;      <span class="comment">// 存储器数据宽度： 一个字节：8位</span></span><br><span class="line">	</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;                           <span class="comment">// 模式选择 普通模式</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;                     <span class="comment">// 通道优先级 这里只有一个通道随意配置</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable ;                           <span class="comment">// 存储器到存储器模式 M-&gt;M</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结构体初始化以及使能</span></span><br><span class="line">	</span><br><span class="line">	DMA_Init(USART_DMA1_Channel, &amp;DMA_InitStructure);</span><br><span class="line">	DMA_ClearFlag(USART_DMA1_FLAG);</span><br><span class="line">	DMA_Cmd(USART_DMA1_Channel, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面再加一个printf的使用</span></span><br></pre></td></tr></table></figure>

<p>2.头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_DMA_MTP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_DMA_MTP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DMA1_CLK                 RCC_AHBPeriph_DMA1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_DMA1_Channel       DMA1_Channel4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_DMA1_FLAG          DMA1_FLAG_HT4</span></span><br><span class="line"><span class="comment">// 外设寄存器地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  USART_DR_ADDRESS        (USART1_BASE+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENDBUFF_SIZE            5000</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> SendBuff[SENDBUFF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面是配置串口使用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PIN     GPIO_Pin_9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_PORT    GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RX_CLK     RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PIN     GPIO_Pin_10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_PORT    GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_BT   115200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CLK  RCC_APB2Periph_USART1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_IRQ  USART1_IRQn</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Config</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_DMA_MTP_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/*__BSP_DMA_MTP_H*/</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.主函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_dma_mtp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;</span><br><span class="line">	</span><br><span class="line">	USART1_Config(); <span class="comment">//初始化串口</span></span><br><span class="line">	</span><br><span class="line">    USART1_DMA_MTP_Config(); <span class="comment">//初始化DMA</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;SENDBUFF_SIZE ; i++) <span class="comment">//把M 填满</span></span><br><span class="line">	&#123;</span><br><span class="line">		SendBuff[i]=<span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE); <span class="comment">//发送请求</span></span><br><span class="line">	<span class="comment">//现象可以边闪烁边发送数据</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_GREEN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="常用的存储器"><a href="#常用的存储器" class="headerlink" title="常用的存储器"></a>常用的存储器</h1><h2 id="存储器的种类"><a href="#存储器的种类" class="headerlink" title="存储器的种类"></a>存储器的种类</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag002.jpeg" alt="基本存储器种类"></p>
<p>易失性: 掉电数据是否容易丢失</p>
<p>易失性存储器:相对来说读写速度较快</p>
<ul>
<li>内存条</li>
</ul>
<p>不易失性存储器:</p>
<ul>
<li>硬盘</li>
</ul>
<h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>random access memory, 随意存储, 存储位置和读取速度没有关系</p>
<ul>
<li>DRAM: 动态的RAM (电容构成 )会通过不断充电放电,保持0/1的稳定</li>
<li>SRAM : 静态的RAM (锁存器构成)</li>
</ul>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag01.png" alt="DRAM与SRAM对比"></p>
<h3 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag02.png" alt="NOR_FLASH与NAND_FLASH特性对比"></p>
<p>FLASH存储器又称为闪存，它也是可重复擦写的储器</p>
<p>坏块：</p>
<p>XIP： 以字节的方式读写 直接读取数据</p>
<hr>
<h1 id="读写EEPROM"><a href="#读写EEPROM" class="headerlink" title="读写EEPROM"></a>读写EEPROM</h1><h2 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h2><h3 id="I2C的物理层"><a href="#I2C的物理层" class="headerlink" title="I2C的物理层"></a>I2C的物理层</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C002.png" alt="常见的I2C通讯系统"></p>
<ul>
<li>“总线”指多个设备共用的信号线。在一个I2C通讯总线中， 可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机。</li>
</ul>
<p>注意:iic在同一时间只能和一个设备通信</p>
<p>SCL：串行时钟线， </p>
<p>SDA： 双线串行数据线</p>
<p>每个连接到总线的数据都有一个独立地址，主机可以通过这个地址来实现不同地址的访问</p>
<p>总线通过接一个上拉店主街道电源. 使得处于不和主机通讯的空闲状态时,会输出高阻态. 方便实现线与 以及防止数据冲突 </p>
<blockquote>
<p>高阻态，目的是为了阻抗匹配，高阻态的时候获取外部信号的能力非常强，这样不会错过外部的电平变化</p>
</blockquote>
<blockquote>
<blockquote>
<p>需要高阻态。即：有一个设备输出高阻态时，总线就被拉成0V，若空闲为0，工作为1，则空闲设备相当于接地。后果是把总线上的电压拉成了0V，其他设备的电压会流入该设备，造成设备短路.主机由此知道总线正在被占用。而只有当所有设备都空闲，都输出高阻态时，总线才能检测到高电平（上拉电阻的作用）</p>
</blockquote>
</blockquote>
<p>I2C的传输速度: 标准模式传输速率为100kbit/s ，快速模式为400kbit/s ， 高速模式下可达 3.4Mbit/s，</p>
<h3 id="I2C的协议层"><a href="#I2C的协议层" class="headerlink" title="I2C的协议层"></a>I2C的协议层</h3><p>I2C的协议定义了 通讯的<strong>起始和停止信号</strong>、<strong>数据有效性</strong>、<strong>响应</strong>、<strong>仲裁</strong>、<strong>时钟同步</strong>和<strong>地址广播</strong>等环节。</p>
<h4 id="I2C的基本读写过程"><a href="#I2C的基本读写过程" class="headerlink" title="I2C的基本读写过程"></a>I2C的基本读写过程</h4><ol>
<li><strong>主机写数据到从机</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C003.jpg" alt="主机写数据到从机"></p>
<p>数据方向: 主机到从机</p>
<p>主机每传输一个字节, 从机会返回一个A的应答信号, 从机接收不了时会发送一个A非信号告诉中止</p>
<ol start="2">
<li><strong>主机从从机读数据</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C004.jpg" alt="主机由从机中读数据"></p>
<p>数据方向: 从机到总机</p>
<p>灰色部分由主机产生</p>
<ol start="3">
<li><strong>通讯复合格式</strong></li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C005.jpeg" alt="I2C通讯复合格式"></p>
<p>在第一次传输中， 主机通过SLAVE_ADDRESS寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与SLAVE_ADDRESS的区别)； 在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。</p>
<h4 id="通讯的起始和停止信号"><a href="#通讯的起始和停止信号" class="headerlink" title="通讯的起始和停止信号"></a>通讯的起始和停止信号</h4><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C008.jpg" alt="起始和停止信号"></p>
<p>起始信号: 在SCL为高电平时,SDA一个下降沿</p>
<p>停止信号: 在SCL为高电平时,SDA一个上升沿</p>
<h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C009.jpg" alt="数据有效性"></p>
<ul>
<li>一个时钟传输一个数据位, </li>
</ul>
<p>SCL位高电平时,表示读入SDA的数据</p>
<p>SCL为低电平时, 可以让SDA进行数据切换(有效防止数据传输的延时问题)</p>
<h4 id="地址及数据方向"><a href="#地址及数据方向" class="headerlink" title="地址及数据方向"></a>地址及数据方向</h4><p>I2C协议规定设备地址可以是7位或10位，实际中<strong>7位</strong>的地址应用比较广泛</p>
<p>紧跟设备地址的<strong>一个数据位</strong>用来表示数据传输方向, 确认是读还是写—0(读),1(写)</p>
<p>这里就构成了一个字节</p>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>I2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C011.jpg" alt="响应与非响应信号"></p>
<h2 id="STM32的I2C特性及架构"><a href="#STM32的I2C特性及架构" class="headerlink" title="STM32的I2C特性及架构"></a>STM32的I2C特性及架构</h2><ul>
<li>“软件模拟协议” </li>
</ul>
<p>直接控制STM32的两个GPIO引脚，分别用作SCL及SDA，按照上述信号的时序要求， 直接像控制LED灯那样控制引脚的输出(若是接收数据时则读取SDA电平)，就可以实现I2C通讯。</p>
<ul>
<li>“硬件协议” </li>
</ul>
<p>STM32的I2C片上外设专门负责实现I2C通讯协议， 只要配置好该外设，它就会自动根据协议要求产生通讯信号，收发数据并缓存起来， CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。</p>
<ul>
<li>STM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。</li>
</ul>
<h3 id="STM32的I2C架构剖析"><a href="#STM32的I2C架构剖析" class="headerlink" title="STM32的I2C架构剖析"></a>STM32的I2C架构剖析</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C012.jpg" alt="I2C架构图"></p>
<ol>
<li>通信引脚</li>
</ol>
<p>STM32F10x的I2C引脚,根据数据手册查出</p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>I2C1</th>
<th>I2C2</th>
</tr>
</thead>
<tbody><tr>
<td>SCL</td>
<td>PB6 / PB8(重映射)</td>
<td>PB10</td>
</tr>
<tr>
<td>SDA</td>
<td>PB7 / PB9(重映射)</td>
<td>PB11</td>
</tr>
</tbody></table>
<p>SMBA用的比较少这里不多做说明</p>
<ol start="2">
<li>时钟控制逻辑</li>
</ol>
<p>SCL线的时钟信号，由I2C接口根据时钟控制寄存器(CCR)控制， 控制的参数主要为时钟频率。配置I2C的CCR寄存器可修改通讯速率相关的参数：</p>
<p>此处计算只需要了解即可,后面计算时钟频率时有响应的库函数</p>
<p><strong>标准模式：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = CCR</em>T_{PCLK1}$</p>
<p><strong>快速模式中</strong> DUTY:  $T_{low}/T_{high}=2$  <strong>时：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = 2</em> CCR*T_{PCLK1}$</p>
<p><strong>快速模式中</strong> DUTY: $T_{low}/T_{high}=16/9$ <strong>时：</strong></p>
<p>$T_{high}=CCR<em>T_{PCKL1} T_{low} = 16</em>CCR*T_{PCLK1}$</p>
<p>PCLK1 表示 APB1上挂的时钟</p>
<ol start="3">
<li>数据控制逻辑</li>
</ol>
<p>数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC寄存器以及SDA数据线</p>
<p>比较器通过比较传来的地址和自身地址寄存器的内容进行比较,从而知道是不是叫自己</p>
<h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C013.jpg" alt="主发送器通讯过程"></p>
<p>这里是使用状态寄存器 I2C_SR1</p>
<p>响应的信号发送成功后, 数据状态寄存器会发生响应的状态</p>
<p>动作寄存器做一个内容之后, 下面的状态寄存器会做出响应的响应,确保工作的状态</p>
<p>因为STM32的传输速度比I2C速度快很多</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C014.jpg" alt="主接收器过程"></p>
<p>主接收器和主发送器的内容几乎一样</p>
<p>$A^{(1)}$是表示STM32接收到了数据做出的响应</p>
<p>EV7_1,要比EV7多设置一点步骤</p>
<p>NA: 非应答响应</p>
<h2 id="I2C的库函数"><a href="#I2C的库函数" class="headerlink" title="I2C的库函数"></a>I2C的库函数</h2><ol>
<li>I2C的初始化结构体</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> I2C_ClockSpeed;       <span class="comment">/*!&lt; 设置SCL时钟频率，此值要低于400000*/</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_Mode;             <span class="comment">/*!&lt; 指定工作模式，可选I2C模式及SMBUS模式 */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_DutyCycle;        <span class="comment">/*指定时钟占空比，可选low/high = 2:1及16:9模式*/</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_OwnAddress1;      <span class="comment">/*!&lt; 指定自身的I2C设备地址 */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_Ack;                 <span class="comment">/*!&lt; 使能或关闭响应(一般都要使能) */</span></span><br><span class="line">    <span class="type">uint16_t</span> I2C_AcknowledgedAddress; <span class="comment">/*!&lt; 指定地址的长度，可为7位及10位 */</span></span><br><span class="line">&#125; I2C_InitTypeDef;</span><br></pre></td></tr></table></figure>

<h2 id="I2C—读写EEPROM实验"><a href="#I2C—读写EEPROM实验" class="headerlink" title="I2C—读写EEPROM实验"></a>I2C—读写EEPROM实验</h2><h3 id="硬件设计-4"><a href="#硬件设计-4" class="headerlink" title="硬件设计"></a>硬件设计</h3><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C015.png" alt="EEPROM硬件连接图"></p>
<h3 id="软件设计-4"><a href="#软件设计-4" class="headerlink" title="软件设计"></a>软件设计</h3><p>编程要点:</p>
<ol>
<li><p>初始化IIC相关的GPIO – PB6， PB7</p>
</li>
<li><p>配置IIC外设的工作模式</p>
</li>
<li><p>编写IIC写入EEPROM Byte write        的函数</p>
</li>
<li><p>编写IIC读入EEPROM RANDOM read的函数</p>
</li>
<li><p>使用read函数以及write函数进行校验</p>
</li>
<li><p>编写初始化结构体</p>
</li>
</ol>
<p><code>.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_i2c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Config</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置SCL GPIO的PA9</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(SCL_CLK , ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = SCL_PIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed =GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(SCL_PORT , &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配值SAD GPIO的PA10</span></span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = SAD_PIN;</span><br><span class="line">	GPIO_Init(SAD_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置I2C1</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(I2C_CLK , ENABLE);</span><br><span class="line"></span><br><span class="line">	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit ;</span><br><span class="line">	I2C_InitStructure.I2C_ClockSpeed = I2C_BT;</span><br><span class="line">	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class="line">	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">	I2C_InitStructure.I2C_OwnAddress1 = I2Cx_OWN_ADDRESS7;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化与使能</span></span><br><span class="line">	I2C_Init(I2C1, &amp;I2C_InitStructure );</span><br><span class="line">	I2C_Cmd(I2C1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>.h</code>文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BSP_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BSP_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//PB6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_PIN     GPIO_Pin_6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_PORT    GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_CLK     RCC_APB2Periph_GPIOB</span></span><br><span class="line"><span class="comment">//PB7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAD_PIN     GPIO_Pin_7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAD_PORT    GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//I2C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_BT   400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLK  RCC_APB1Periph_I2C1</span></span><br><span class="line"><span class="comment">/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2Cx_OWN_ADDRESS7      0X0A</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Config</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BSP_USART_H*/</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写 字节发送函数</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C013.jpg" alt="主发送器通讯过程"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//关于这函数的编写由于有点复杂，所以先不放在这了，仔细看给的工程文件代码</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>由于后面是关于数据存储FLASH，和数据的发送</p>
<p>关于这块内容，数电还没有跟上，而且和EEPROM有比较强的相似性</p>
<p>打算后面用到了再回过头学习，接下来先学习高级篇</p>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电赛准备</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习（入门篇）</title>
    <url>/2022/12/29/STM32%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<p>本文使用的是野火生产的[STM32-指南针]([关于本项目 — <a href="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/README.html">野火]STM32库开发实战指南——基于野火指南者开发板 文档 (embedfire.com)</a>)，观看野火教程的<a href="%5B3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8DAP%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Xs411g7Aj?p=1&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">学习视频</a>的学习笔记</p>
<h1 id="DAP仿真软件的配置"><a href="#DAP仿真软件的配置" class="headerlink" title="DAP仿真软件的配置"></a>DAP仿真软件的配置</h1><p>这里观看这里的教程：[DAP仿真器与串口下载程序 — <a href="https://doc.embedfire.com/stm32_products/must_read/zh/latest/doc/quickstart/DAP/DAP.html">野火]STM32开发板必读说明 文档 (embedfire.com)</a></p>
<p><img src="https://doc.embedfire.com/stm32_products/must_read/zh/latest/_images/DAP_0.png" alt="../../../_images/DAP_0.png"></p>
<p>左侧不出现，注意换一个USB口。右侧不出现，DAP插入开发板时，换成SWD</p>
<p>普通DAP注意connect：under Reset 。Reset 选择HW RESET或者 VECTRESTET </p>
<p>注意配置，配置好后，DAP仿真器应该亮绿灯。</p>
<p>编译完成后点击LOAD即可下载程序。</p>
<hr>
<h1 id="什么是STM32"><a href="#什么是STM32" class="headerlink" title="什么是STM32"></a>什么是STM32</h1><h2 id="STM32的引脚说明"><a href="#STM32的引脚说明" class="headerlink" title="STM32的引脚说明"></a>STM32的引脚说明</h2><table>
<thead>
<tr>
<th>引脚分类</th>
<th>引脚说明说明</th>
</tr>
</thead>
<tbody><tr>
<td>电源</td>
<td>(VBAT)、(VDD Vss)、(VDDA VSSA)、(VREF+VREF-)等</td>
</tr>
<tr>
<td>晶振IO</td>
<td>主晶振IO，RTC晶振IO</td>
</tr>
<tr>
<td>下载IO</td>
<td>用于JTAG下载的IO:JTMS、JTCK、JTDI、JTDO、NJTRST</td>
</tr>
<tr>
<td>BOOT IO</td>
<td>BOOTo、BOOT1，用于设置系统的启动方式</td>
</tr>
<tr>
<td>复位IO</td>
<td>NRST，用于外部复位</td>
</tr>
<tr>
<td></td>
<td>上面5部分IO组成的系统我们也叫做最小系统</td>
</tr>
<tr>
<td>GPIO</td>
<td>专用器件接到专用的总线，比如I2C，SPI，SDIO，FSMC，DCMI这些总线的器件需要接到专用的IO</td>
</tr>
<tr>
<td>GPIO</td>
<td>普通的元器件接到GPIO，比如蜂鸣器，LED，按键等元器件用普通的GPIO即</td>
</tr>
<tr>
<td>GPIO</td>
<td>如果还有剩下的IO，可根据项目需要引出或者不引出</td>
</tr>
</tbody></table>
<p>具体引脚的功能说明见 数据手册(最好读英文)</p>
<hr>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h2><p>意义： 给有特殊意义的地址取了一个别名</p>
<p>STM32中的 头文件 <code>#include &quot;stm32f10x.h&quot;</code></p>
<p>以及51单片机中的 头文件<code>#inclde &quot;reg51.h&quot;</code></p>
<p>中都是存放着寄存器映射</p>
<h2 id="以GPIOB口为例子"><a href="#以GPIOB口为例子" class="headerlink" title="以GPIOB口为例子"></a>以GPIOB口为例子</h2><p>我们找到GPIOB端口的输出数据寄存器ODR的地址是0x40010C0C</p>
<blockquote>
<p>(在官方参考手册的 2.3存储器映像中找到起始位置)</p>
</blockquote>
<p>ODR寄存器是32bit，低16bit有效，对应着16个外部IO，写0/1对应的的IO则输出低/高电平。</p>
<p>通过下面语句将其全部置为一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0x4001</span> <span class="number">0</span>C0C) = <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">// 我们对位操作时通常使用位操作符 |,&amp;的形式 在之后会介绍</span></span><br></pre></td></tr></table></figure>

<p>我们给<code>*(unsigned int*)(0x4001 0C0C)</code>定义一个别名,就是寄存器映射</p>
<p>上面所讲的头文件实际上就是对 各个特殊意义的地址取了别名后进行封装</p>
<hr>
<hr>
<h1 id="新建工程模板"><a href="#新建工程模板" class="headerlink" title="新建工程模板"></a>新建工程模板</h1><h2 id="点亮一盏灯-简易版"><a href="#点亮一盏灯-简易版" class="headerlink" title="点亮一盏灯(简易版)"></a>点亮一盏灯(简易版)</h2><ol>
<li>首先看电路原理图</li>
</ol>
<p>通过PB0端口来控制绿灯的点亮</p>
<p>![img](STM32 学习/SVF7QMT2%$O`06832X``8EQ.png)</p>
<p>PB0 由GPIOB_ODR(output data register) 端口输出寄存器控制</p>
<ul>
<li><p>找到 GPIOB的地址为 <code>0X4001 0C00 </code></p>
</li>
<li><p>ODR的地址偏移：0C h</p>
</li>
<li><p>点亮灯-让最低位输出零</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X4001</span> <span class="number">0</span>C0C) &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"><span class="comment">//这步骤是 让最后一位置零,并且不影响其他位的取值</span></span><br><span class="line"><span class="comment">//注意ODR的复位值：0x0000 0000,不进行这步,灯也会亮,但是为了可读一定要加上这一句</span></span><br></pre></td></tr></table></figure>

<p>但是STM32比51单片机高级的地方在于PB0口既可以当作输入 又可以当作输出,而且默认为输入</p>
<p>这里我们要将它 <strong>配置IO口为输出</strong></p>
<p>![image-20221226223404869](STM32 学习/image-20221226223404869.png)</p>
<p>PB0是0 所以是最后四位</p>
<p>使用 通用推挽输出模式[0,0]</p>
<p>模式控制速度这里选择10MHZ</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X4001</span> <span class="number">0</span>C00) &amp;= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>然后我们发现要控制GPIOB打开 还得控制时钟打开</p>
<p>![](STM32 学习/image-20221226223936675.png)</p>
<p>由寄存器组起始地址表中,查到RCC的地址是 0x4002 1000</p>
<p>然后再APB2 外设时钟使能寄存器(RCC_APB2ENR)中看到</p>
<p>![image-20221226224355093](STM32 学习/image-20221226224355093.png)</p>
<p>![image-20221226224416328](STM32 学习/image-20221226224416328.png)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">0X0</span>x4002 <span class="number">1018</span>) &amp;= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//亮绿灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40021018</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C00</span>) |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));<span class="comment">//4*1-蓝灯 4*5红灯</span></span><br><span class="line">	<span class="comment">// 控制ODR寄存器 让灯亮</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) &amp;= ~(<span class="number">0</span>&lt;&lt;<span class="number">0</span>)<span class="comment">//&lt;&lt;1-蓝灯,&lt;&lt;5红灯	</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> SystemInit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//闪烁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">400</span>;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">400</span>;j++);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40021018</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C00</span>) |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 控制ODR寄存器 让灯亮</span></span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		delay();</span><br><span class="line">		<span class="comment">// 控制ODR寄存器 让灯灭</span></span><br><span class="line">		*(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0X40010C0C</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		delay();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="使用寄存器点亮一盏灯"><a href="#使用寄存器点亮一盏灯" class="headerlink" title="使用寄存器点亮一盏灯"></a>使用寄存器点亮一盏灯</h1><h2 id="读GPIO的系统框图"><a href="#读GPIO的系统框图" class="headerlink" title="读GPIO的系统框图"></a>读GPIO的系统框图</h2><p>![7](STM32 学习/7.png)</p>
<ul>
<li><p>上半部分是输入部分</p>
</li>
<li><p>下半部分是输出部分</p>
</li>
</ul>
<p>圈2这个位置是选择工作模式</p>
<p>通常选择推挽工作模式</p>
<p>开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中，或者是电平不匹配的场合</p>
<p>圈3这个位置就是我们的ODR控制输出，也可以通过BSRR 位设置、清除寄存器控制</p>
<p>输入部分</p>
<p>首先是一个上拉下拉 在端口配置低寄存器中选择上拉/下拉模式</p>
<p>然后是TTL 也称为0/1转换器来实现数模转换</p>
<p>圈5是IDR</p>
<p>圈6读取数字信号</p>
<p>圈7读取模拟信号</p>
<h2 id="自己写寄存器映射到头文件中"><a href="#自己写寄存器映射到头文件中" class="headerlink" title="自己写寄存器映射到头文件中"></a>自己写寄存器映射到头文件中</h2><p>打开头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义总线的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2 (unsigned int)0x40010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABH  (unsigned int)0x40020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB1 (unsigned int)0x40000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据寄存器偏移确定外设的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB (APB2+0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSS   (ABH +0x1000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制特定的寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRL  *(unsigned int*)(GPIOB+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRH  *(unsigned int*)(GPIOB+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR  *(unsigned int*)(GPIOB+0x0C)</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR *(unsigned int*)(RSS+0x18)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*片上外设基地址  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE         ((unsigned int)0x40000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*总线基地址，GPIO都挂载到APB2上 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/* AHB总线基地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AHBPERIPH_BASE      (PERIPH_BASE + 0x20000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*GPIOB外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE          (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIOB寄存器地址,强制转换成指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRL           *(unsigned int*)(GPIOB_BASE+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_CRH           *(unsigned int*)(GPIOB_BASE+0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_IDR           *(unsigned int*)(GPIOB_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR           *(unsigned int*)(GPIOB_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BSRR          *(unsigned int*)(GPIOB_BASE+0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BRR           *(unsigned int*)(GPIOB_BASE+0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_LCKR          *(unsigned int*)(GPIOB_BASE+0x18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*RCC外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE           (AHBPERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="comment">/*RCC的AHB1时钟使能寄存器地址,强制转换成指针*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_APB2ENR        *(unsigned int*)(RCC_BASE+0x18)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//打开GPIOB 的时钟 </span></span><br><span class="line">	RCC_APB2ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 配置IO口为输出</span></span><br><span class="line">	GPIOB_CRL |= ((<span class="number">1</span>)&lt;&lt;(<span class="number">4</span>*<span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 控制GPIOB_BSRR, GPIOB_BRR寄存器 让灯亮</span></span><br><span class="line">	GPIOB_BRR  |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	GPIOB_BSRR |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 函数体为空，骗过编译器不报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="构建STM32库函数的雏形"><a href="#构建STM32库函数的雏形" class="headerlink" title="构建STM32库函数的雏形"></a>构建STM32库函数的雏形</h1><h2 id="通过结构体来访问地址"><a href="#通过结构体来访问地址" class="headerlink" title="通过结构体来访问地址"></a>通过结构体来访问地址</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*片上外设基地址  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIPH_BASE         ((unsigned int)0x40000000)</span></span><br><span class="line"><span class="comment">/*总线基地址，GPIO都挂载到APB2上 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)</span></span><br><span class="line"><span class="comment">/*GPIOB外设基地址*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE          (APB2PERIPH_BASE + 0x0C00)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO 寄存器结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">uint32_t</span> CRL;       <span class="comment">// 端口配置低寄存器，     地址偏移0X00</span></span><br><span class="line">   <span class="type">uint32_t</span> CRH;       <span class="comment">// 端口配置高寄存器，     地址偏移0X04</span></span><br><span class="line">   <span class="type">uint32_t</span> IDR;       <span class="comment">// 端口数据输入寄存器，   地址偏移0X08</span></span><br><span class="line">   <span class="type">uint32_t</span> ODR;       <span class="comment">// 端口数据输出寄存器，   地址偏移0X0C</span></span><br><span class="line">   <span class="type">uint32_t</span> BSRR;      <span class="comment">// 端口位设置/清除寄存器，地址偏移0X10</span></span><br><span class="line">   <span class="type">uint32_t</span> BRR;       <span class="comment">// 端口位清除寄存器，     地址偏移0X14</span></span><br><span class="line">   <span class="type">uint32_t</span> LCKR;      <span class="comment">// 端口配置锁定寄存器，   地址偏移0X18</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GBIO ((GPIO_TypeDef*)GPIOB_BASE)</span></span><br><span class="line"><span class="comment">//之后就可以用 GBIO-&gt;CRL来访问CRL</span></span><br></pre></td></tr></table></figure>

<h2 id="通过建立库函数来控制GPIO"><a href="#通过建立库函数来控制GPIO" class="headerlink" title="通过建立库函数来控制GPIO"></a>通过建立库函数来控制GPIO</h2><ol>
<li>在工程文件下 新建一个<code>.h</code>的头文件和同名的<code>.c</code>文件 并加到工程文件中</li>
<li>在新建的<code>.c</code>文件中调用<code>.h</code>文件</li>
<li><code>.h</code>文件中要采取固定方式书写,防止重复调用</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F10X_GPIO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F10X_GPIO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分别定义每个引脚 置1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_0              (uint16_t)0x0001)  <span class="comment">/*!&lt; 选择Pin0 (1&lt;&lt;0) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_1              ((uint16_t)0x0002)  <span class="comment">/*!&lt; 选择Pin1 (1&lt;&lt;1)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_2              ((uint16_t)0x0004)  <span class="comment">/*!&lt; 选择Pin2 (1&lt;&lt;2)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_3              ((uint16_t)0x0008)  <span class="comment">/*!&lt; 选择Pin3 (1&lt;&lt;3)*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_4              ((uint16_t)0x0010)  <span class="comment">/*!&lt; 选择Pin4 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_5              ((uint16_t)0x0020)  <span class="comment">/*!&lt; 选择Pin5 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6              ((uint16_t)0x0040)  <span class="comment">/*!&lt; 选择Pin6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7              ((uint16_t)0x0080)  <span class="comment">/*!&lt; 选择Pin7 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8              ((uint16_t)0x0100)  <span class="comment">/*!&lt; 选择Pin8 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_9              ((uint16_t)0x0200)  <span class="comment">/*!&lt; 选择Pin9 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_10             ((uint16_t)0x0400)  <span class="comment">/*!&lt; 选择Pin10 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_11             ((uint16_t)0x0800)  <span class="comment">/*!&lt; 选择Pin11 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_12             ((uint16_t)0x1000)  <span class="comment">/*!&lt; 选择Pin12 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_13             ((uint16_t)0x2000)  <span class="comment">/*!&lt; 选择Pin13 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_14             ((uint16_t)0x4000)  <span class="comment">/*!&lt; 选择Pin14 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_15             ((uint16_t)0x8000)  <span class="comment">/*!&lt; 选择Pin15 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_All            ((uint16_t)0xFFFF)  <span class="comment">/*!&lt; 选择全部引脚 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后面可以加函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*__STM32F10X_GPIO_H*/</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>.c</code>文件中写函数</p>
<ol start="4">
<li>最后只需在<code>main.c</code>声明 <code>#include XX.h</code>即可使用函数</li>
</ol>
<h2 id="构建初始化函数"><a href="#构建初始化函数" class="headerlink" title="构建初始化函数"></a>构建初始化函数</h2><ol>
<li>定义结构体存放初始化的配置</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;      <span class="comment">/*!&lt; 选择要配置的GPIO引脚 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Speed;    <span class="comment">/*!&lt; 选择GPIO引脚的速率 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Mode;     <span class="comment">/*!&lt; 选择GPIO引脚的工作模式 */</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义枚举类型 对每一个模式进行赋值</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel004.png" alt="端口配置低寄存器"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* GPIO输出速率枚举定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Speed_10MHz = <span class="number">1</span>,         <span class="comment">// 10MHZ        (01)b</span></span><br><span class="line">    GPIO_Speed_2MHz,              <span class="comment">// 2MHZ         (10)b</span></span><br><span class="line">    GPIO_Speed_50MHz              <span class="comment">// 50MHZ        (11)b</span></span><br><span class="line">&#125; GPIOSpeed_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* GPIO工作模式枚举定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Mode_AIN = <span class="number">0x0</span>,           <span class="comment">// 模拟输入     (0000 0000)b</span></span><br><span class="line">    GPIO_Mode_IN_FLOATING = <span class="number">0x04</span>,  <span class="comment">// 浮空输入     (0000 0100)b</span></span><br><span class="line">    GPIO_Mode_IPD = <span class="number">0x28</span>,          <span class="comment">// 下拉输入     (0010 1000)b</span></span><br><span class="line">    GPIO_Mode_IPU = <span class="number">0x48</span>,          <span class="comment">// 上拉输入     (0100 1000)b</span></span><br><span class="line"></span><br><span class="line">    GPIO_Mode_Out_OD = <span class="number">0x14</span>,       <span class="comment">// 开漏输出     (0001 0100)b</span></span><br><span class="line">    GPIO_Mode_Out_PP = <span class="number">0x10</span>,       <span class="comment">// 推挽输出     (0001 0000)b</span></span><br><span class="line">    GPIO_Mode_AF_OD = <span class="number">0x1C</span>,        <span class="comment">// 复用开漏输出  (0001 1100)b</span></span><br><span class="line">    GPIO_Mode_AF_PP = <span class="number">0x18</span>         <span class="comment">// 复用推挽输出  (0001 1000)b</span></span><br><span class="line">&#125; GPIOMode_TypeDef;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义GPIO初始化函数,来实现寄存器配置</li>
</ol>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel006.png" alt="GPIO引脚工作模式真值表分析"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*函数功能：初始化引脚模式</span></span><br><span class="line"><span class="comment">*参数说明：GPIOx，该参数为GPIO_TypeDef类型的指针，指向GPIO端口的地址</span></span><br><span class="line"><span class="comment">*         GPIO_InitTypeDef:GPIO_InitTypeDef结构体指针，指向初始化变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> currentmode =<span class="number">0x00</span>,currentpin = <span class="number">0x00</span>,pinpos = <span class="number">0x00</span>,pos = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">uint32_t</span> tmpreg = <span class="number">0x00</span>, pinmask = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*---------------- GPIO 模式配置 -------------------*/</span></span><br><span class="line">    <span class="comment">// 把输入参数GPIO_Mode的低四位暂存在currentmode</span></span><br><span class="line">    currentmode = ((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp;</span><br><span class="line">                ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bit4是1表示输出，bit4是0则是输入</span></span><br><span class="line">    <span class="comment">// 判断bit4是1还是0，即首选判断是输入还是输出模式</span></span><br><span class="line">    <span class="keyword">if</span> ((((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Mode) &amp;</span><br><span class="line">            ((<span class="type">uint32_t</span>)<span class="number">0x10</span>)) != <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出模式则要设置输出速度</span></span><br><span class="line">        currentmode |= (<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*-----GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- ----*/</span></span><br><span class="line">    <span class="comment">// 配置端口低8位，即Pin0~Pin7</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">uint32_t</span>)GPIO_InitStruct-&gt;GPIO_Pin &amp;</span><br><span class="line">            ((<span class="type">uint32_t</span>)<span class="number">0x00FF</span>)) != <span class="number">0x00</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先备份CRL寄存器的值</span></span><br><span class="line">        tmpreg = GPIOx-&gt;CRL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环，从Pin0开始配对，找出具体的Pin</span></span><br><span class="line">        <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pos的值为1左移pinpos位</span></span><br><span class="line">            pos = ((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 令pos与输入参数GPIO_PIN作位与运算</span></span><br><span class="line">            currentpin = (GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">            <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚</span></span><br><span class="line">                pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">                pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">                tmpreg &amp;= ~pinmask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">                tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 下拉输入模式,引脚默认置0,对BRR寄存器写1对引脚置0</span></span><br><span class="line">                    GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">                    <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 上拉输入模式,引脚默认值为1,对BSRR寄存器写1对引脚置1</span></span><br><span class="line">                        GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; pinpos);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前面处理后的暂存值写入到CRL寄存器之中</span></span><br><span class="line">        GPIOx-&gt;CRL = tmpreg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*--------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----*/</span></span><br><span class="line">    <span class="comment">// 配置端口高8位，即Pin8~Pin15</span></span><br><span class="line">    <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Pin &gt; <span class="number">0x00FF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// // 先备份CRH寄存器的值</span></span><br><span class="line">        tmpreg = GPIOx-&gt;CRH;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环，从Pin8开始配对，找出具体的Pin</span></span><br><span class="line">        <span class="keyword">for</span> (pinpos = <span class="number">0x00</span>; pinpos &lt; <span class="number">0x08</span>; pinpos++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pos与输入参数GPIO_PIN作位与运算</span></span><br><span class="line">            currentpin = ((GPIO_InitStruct-&gt;GPIO_Pin) &amp; pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若currentpin=pos,则找到使用的引脚</span></span><br><span class="line">            <span class="keyword">if</span> (currentpin == pos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚</span></span><br><span class="line">                pos = pinpos &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//把控制这个引脚的4个寄存器位清零，其它寄存器位不变</span></span><br><span class="line">                pinmask = ((<span class="type">uint32_t</span>)<span class="number">0x0F</span>) &lt;&lt; pos;</span><br><span class="line">                tmpreg &amp;= ~pinmask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向寄存器写入将要配置的引脚的模式</span></span><br><span class="line">                tmpreg |= (currentmode &lt;&lt; pos);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否为下拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPD)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 下拉输入模式,引脚默认置0,对BRR寄存器写1可对引脚置0</span></span><br><span class="line">                    GPIOx-&gt;BRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是否为上拉输入模式</span></span><br><span class="line">                <span class="keyword">if</span> (GPIO_InitStruct-&gt;GPIO_Mode == GPIO_Mode_IPU)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 上拉输入模式,引脚默认值为1,对BSRR寄存器写1可对引脚置1</span></span><br><span class="line">                    GPIOx-&gt;BSRR = (((<span class="type">uint32_t</span>)<span class="number">0x01</span>) &lt;&lt; (pinpos + <span class="number">0x08</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前面处理后的暂存值写入到CRH寄存器之中</span></span><br><span class="line">        GPIOx-&gt;CRH = tmpreg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提高代码的可移植性"><a href="#提高代码的可移植性" class="headerlink" title="提高代码的可移植性"></a>提高代码的可移植性</h2><p>涉及到GPIO端口时候利用 宏来进行替换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_GPIO_PORT GPIOB <span class="comment">//将点亮的端口用宏替代</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK_ENABLE (RCC-&gt;APB2ENR |=((1)&lt;&lt;3)) <span class="comment">//点亮对应端口的时钟</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_GPIO_PIN GPIO_pin_0 <span class="comment">//LED_G对应PB0是第一个引脚</span></span></span><br></pre></td></tr></table></figure>

<p>将后面的代码用宏来替代</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>直接操作内存-&gt;寄存器映射-&gt;利用寄存器结构体方便访问结构体成员-&gt;加强可读性(编写函数)-&gt;定义初始化结构体(将所有要配置的参数枚举出来)-&gt;利用宏定义增强可移植性</p>
<hr>
<h1 id="固件库编程"><a href="#固件库编程" class="headerlink" title="固件库编程"></a>固件库编程</h1><h2 id="分析固件库内容"><a href="#分析固件库内容" class="headerlink" title="分析固件库内容"></a>分析固件库内容</h2><ol>
<li>汇编语言编写的启动文件(简单)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">startup_stm32f10x_hd.c: 设置堆栈指针,设置PC指针,初始化中断向量表,配置系统时钟,对用C库函数,进入C语言的环境</span><br><span class="line">hd,表示大小</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer01.png" alt="详细说明见表"></p>
<ol start="2">
<li>时钟配置文件(简单)</li>
</ol>
<p>system_stm32f10zx.c: 把系统时钟HSE=8M, 经过PLL 倍频为PLL=72M</p>
<ol start="3">
<li><strong>stm32f10x.h</strong> </li>
</ol>
<p>ST生产的外设相关的: 实现寄存器映射</p>
<p>XXX: GPIO,USRAT,I2C,SPI,FSMC</p>
<p>stm32f10x_XX.h :存放外设初始化结构体,外设初始化结构体成员的参数列表,外设固件库函数声明</p>
<p>stm32f10x_XX.c :外设驱动函数库文件</p>
<ol start="4">
<li><strong>core_cm.h</strong></li>
</ol>
<p>内核映射: 内核相关的寄存器映射</p>
<p>core_cm.c: 内核外设的驱动固件库</p>
<p>NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器)</p>
<p>misc.h</p>
<p>misc.c</p>
<ol start="5">
<li>在main函数里面定义使用的<strong>头文件</strong></li>
</ol>
<p>为了方便定义了 头文件配置文件: 实现外设所以的文件的声明</p>
<p><strong>stm32f10x_conf.h</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">使用什么外设 就取消什么注释</span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line"><span class="comment">//stm32f10x_XX.h</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>专门存放中断服务函数的C文件</li>
</ol>
<p>stm32f10x_it.h</p>
<p>stm32f10x_it.c</p>
<p>这个函数可以随意放在其他的地方,并不一定要放到stm32f10x_it.c 中</p>
<h2 id="固件库的内容"><a href="#固件库的内容" class="headerlink" title="固件库的内容"></a>固件库的内容</h2><p>看固件库的头文件来分析函数的作用</p>
<hr>
<h1 id="建立带固件库的工程模板"><a href="#建立带固件库的工程模板" class="headerlink" title="建立带固件库的工程模板"></a>建立带固件库的工程模板</h1><p>基本上看着视频操作，或者书本就可</p>
<p>但是有一点特别注意</p>
<p>![8](STM32 学习/8.png)</p>
<p>将这个版本设置成5，不然不仅编译慢还疯狂报错</p>
<hr>
<h1 id="利用固件库编程点亮LED"><a href="#利用固件库编程点亮LED" class="headerlink" title="利用固件库编程点亮LED"></a>利用固件库编程点亮LED</h1><h2 id="点灯"><a href="#点灯" class="headerlink" title="点灯"></a>点灯</h2><p>1.主函数内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	</span><br><span class="line">	GPIO_SetBits(LED_G_PORT, LED_G_PIN);    <span class="comment">//set函数将引脚上的 置为1</span></span><br><span class="line">	GPIO_ResetBits(LED_G_PORT, LED_G_PIN);  <span class="comment">//reset函数将引脚上的 置为1</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.bsp_led.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_initstruct; <span class="comment">//定义一个结构体初始化绿灯的内容</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_G_CLK, ENABLE); <span class="comment">//打开绿灯的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;  <span class="comment">//定义绿灯为推挽输出</span></span><br><span class="line">	GPIO_initstruct.GPIO_Pin = LED_G_PIN;          <span class="comment">//将引脚对应为绿灯的引脚</span></span><br><span class="line">	GPIO_initstruct.GPIO_Speed = GPIO_Speed_50MHz; <span class="comment">//定义速度为50M</span></span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_initstruct);            <span class="comment">//使用初始化函数配置到GPIO_CLR</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.bsp_led.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PIN  GPIO_Pin_0                    <span class="comment">// 宏定义绿灯的管脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PORT GPIOB                         <span class="comment">// 宏定义绿灯的端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK  RCC_APB2Periph_GPIOB          <span class="comment">//宏定义绿灯的时钟</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BEP_LED_H*/</span></span></span><br></pre></td></tr></table></figure>

<h2 id="实现流水灯"><a href="#实现流水灯" class="headerlink" title="实现流水灯"></a>实现流水灯</h2><ol>
<li>主函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化函数</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED_RED;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_GREEN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_BLUE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_YELLOW;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_PURPLE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_CYAN;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_WHITE;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">		LED_RGBOFF;</span><br><span class="line">		delay(<span class="number">0x2FFFFF</span>);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bsp_led.c</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_G_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_G_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_G_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_G_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_G_initstruct.GPIO_Pin = LED_G_PIN; </span><br><span class="line">	GPIO_G_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_G_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_B_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_B_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_B_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_B_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_B_initstruct.GPIO_Pin = LED_B_PIN; </span><br><span class="line">	GPIO_B_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_B_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GPIO_R_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_R_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_R_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_R_initstruct.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_R_initstruct.GPIO_Pin = LED_R_PIN; </span><br><span class="line">	GPIO_R_initstruct.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_R_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>bsp_led.h</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_PIN  GPIO_Pin_1 <span class="comment">//只有端口不同的区别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//红灯定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_PIN  GPIO_Pin_5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_PORT GPIOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R_CLK  RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开绿灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_G_PORT, LED_G_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_G_PORT, LED_G_PIN); </span></span><br><span class="line"><span class="comment">//开蓝灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_B(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_B_PORT, LED_B_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_B_PORT, LED_B_PIN); </span></span><br><span class="line"><span class="comment">//开蓝灯</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_R(a) <span class="keyword">if</span>(a) GPIO_ResetBits(LED_R_PORT, LED_R_PIN); <span class="keyword">else</span> GPIO_SetBits(LED_R_PORT, LED_R_PIN); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示红色</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RED  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绿</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_GREEN       \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_BLUE    \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//黄(红+绿)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_YELLOW  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"><span class="comment">//紫(红+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PURPLE  \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//青(绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_CYAN \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//白(红+绿+蓝)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WHITE   \</span></span><br><span class="line"><span class="meta">                    LED_R(ON);\</span></span><br><span class="line"><span class="meta">                    LED_G(ON);\</span></span><br><span class="line"><span class="meta">                    LED_B(ON);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//黑(全部关闭)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_RGBOFF  \</span></span><br><span class="line"><span class="meta">                    LED_R(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_G(OFF);\</span></span><br><span class="line"><span class="meta">                    LED_B(OFF);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__BEP_LED_H*/</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="GPIO输入-按键检测"><a href="#GPIO输入-按键检测" class="headerlink" title="GPIO输入- 按键检测"></a>GPIO输入- 按键检测</h1><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIOin003.png" alt="按键原理图"></p>
<p>这里采用了连接<strong>电容</strong>的方式来<strong>物理消抖</strong></p>
<p>R57和R15的作用都是保护电路</p>
<p>如果按键按下就会 读到高电平 按键不按下的时候会得到低电平</p>
<h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><ol>
<li>对引脚进行初始化</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在.h文件中</span></span><br><span class="line"><span class="comment">//KEY1宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_G_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="comment">//在.c文件中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_G_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct; <span class="comment">//定义KEY1的结构体</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_G_CLK, ENABLE); <span class="comment">//打开KEY1对应的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//设置模式为浮空输入模式</span></span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_G_PIN;   <span class="comment">//设置KEY1对应的引脚</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_G_PORT, &amp;GPIO_KEY1_initstruct); <span class="comment">//调用初始化函数配置到寄存器中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写按键检测函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span> <span class="comment">//传入对应的端口和引脚</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON ) <span class="comment">//是否按下 按下为1</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON);<span class="comment">//松手检测</span></span><br><span class="line">		<span class="keyword">return</span> KEY_ON;  <span class="comment">//返回按下</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> KEY_OFF; <span class="comment">//返回没有按下</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>灯状态变化函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LED_G_TOGGLE; <span class="comment">//宏定义函数 相当于对 对应位取反</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_G_TOGGLE &#123;LED_G_PORT-&gt;ODR ^= LED_G_PIN ;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写好的文件"><a href="#编写好的文件" class="headerlink" title="编写好的文件"></a>编写好的文件</h2><ol>
<li>main 函数中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;keyscan.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(;count!= <span class="number">0</span>; count--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	LED_GPIO_G_Config();                      <span class="comment">//初始化LED灯</span></span><br><span class="line">	LED_GPIO_B_Config();</span><br><span class="line">	LED_GPIO_R_Config();</span><br><span class="line">	LED_RGBOFF;        <span class="comment">//亮黑灯,相当于把所有灯关上</span></span><br><span class="line">	</span><br><span class="line">	KEY1_GPIO_Config();                     <span class="comment">//初始化按键1</span></span><br><span class="line">	KEY2_GPIO_Config();                     <span class="comment">//初始化按键2</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(KEY_Scan( KEY1_PORT, KEY1_PIN) == KEY_ON) <span class="comment">//检测按键1是否按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			LED_G_TOGGLE; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(KEY_Scan( KEY2_PORT, KEY2_PIN) == KEY_ON)<span class="comment">//检测按键2是否按下</span></span><br><span class="line">		&#123;</span><br><span class="line">			LED_B_TOGGLE; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>bsp_key.h  文件中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BEP_KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BEP_KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="comment">//KEY1定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PIN  GPIO_Pin_0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PORT GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_CLK  RCC_APB2Periph_GPIOA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY2定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PIN  GPIO_Pin_13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PORT GPIOC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_CLK  RCC_APB2Periph_GPIOC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ON  1 <span class="comment">//把按下宏定义为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_OFF 0 <span class="comment">//把未按下宏定义为0</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的声明</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY2_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/*__BEP_KEY_H */</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>bsp_key.c 文件中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;keyscan.h&quot;</span></span></span><br><span class="line"><span class="comment">//按键1初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY1_initstruct; <span class="comment">//定义按键1对应的结构体</span></span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY1_CLK, ENABLE); <span class="comment">//打开按键1对应的时钟</span></span><br><span class="line">	</span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//将模式设置为浮空输入模式</span></span><br><span class="line">	GPIO_KEY1_initstruct.GPIO_Pin = KEY1_PIN; <span class="comment">//设置按键1对应管脚</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY1_PORT, &amp;GPIO_KEY1_initstruct); <span class="comment">//调用初始化函数,穿入对应的端口中</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按键2初始化函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY2_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_KEY2_initstruct;</span><br><span class="line">	</span><br><span class="line">	RCC_APB2PeriphClockCmd(KEY2_CLK, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_KEY2_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line">	GPIO_KEY2_initstruct.GPIO_Pin = KEY2_PIN; </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	GPIO_Init(KEY2_PORT, &amp;GPIO_KEY2_initstruct);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span> <span class="comment">//按键检测函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON ) <span class="comment">//判断按键是否按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOx, GPIO_Pin) == KEY_ON);<span class="comment">//松手检测</span></span><br><span class="line">		<span class="keyword">return</span> KEY_ON;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> KEY_OFF;</span><br><span class="line">&#125;+-</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="GPIO的输入与输出"><a href="#GPIO的输入与输出" class="headerlink" title="GPIO的输入与输出"></a>GPIO的输入与输出</h1><h2 id="类比51-总线操作和位操作"><a href="#类比51-总线操作和位操作" class="headerlink" title="类比51 总线操作和位操作"></a>类比51 总线操作和位操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在51单片机中,让LED1输出低电平有两个操作</span><br><span class="line">P0=0xFE; //这是总线操作,直接操作P0端口</span><br><span class="line">P0^0=0;  //这是位操作,控制LED1对应的端口</span><br></pre></td></tr></table></figure>

<p>在STM32中 <code>GPIOB-&gt;ODR $= (0&lt;&lt;0) </code> 就类似于51单片机中的总线操作</p>
<p>51单片机中通过关键字sbit来实现位定义， STM32没有这样的关键字，而是通过访问位带别名区来实现.</p>
<h2 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h2><p>STM32中，有两个位置可以实现此操作，分别是部分片上外设和部分片上SRAM.</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIObi002.png" alt="STM32位带示意图"></p>
<ol>
<li>外设外带区的地址为：0X40000000~0X40100000，大小为1MB</li>
</ol>
<p>这1MB的大小在103系列大/中/小容量型号的单片机中包含了片上外设的全部寄存器， </p>
<p>这些寄存器的地址为：0X40000000-0X40029FFF。</p>
<p>外设位带区经过膨胀后的位带别名区地址为：0X42000000-0X43FFFFFF， </p>
<p>这个地址仍然在CM3 片上外设的地址空间中</p>
<ol start="2">
<li>SRAM的位带区的地址为：0X2000 0000<del>X2010 0000，大小为1MB，经过膨胀后的位带别名区地址为：0X2200 0000</del>0X23FF FFFF， 大小为32MB。这个位操作用得比较少</li>
</ol>
<h2 id="位带地区和外设别名取的转换："><a href="#位带地区和外设别名取的转换：" class="headerlink" title="位带地区和外设别名取的转换："></a>位带地区和外设别名取的转换：</h2><p>关键：1个位膨胀成32个位</p>
<h4 id="外设位带别名区地址"><a href="#外设位带别名区地址" class="headerlink" title="外设位带别名区地址"></a>外设位带别名区地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x42000000</span>+ (A<span class="number">-0x40000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>0X42000000是外设位带别名区的起始地址，0x40000000是外设位带区的起始地址，（A-0x40000000）表示该比特前面有多少个字节， 一个字节有8位，所以<em>8，一个位膨胀后是4个字节，所以</em>4，n表示该比特在A地址的序号，因为一个位经过膨胀后是四个字节，所以也*4。</p>
<h4 id="SRAM位带别名区地址"><a href="#SRAM位带别名区地址" class="headerlink" title="SRAM位带别名区地址"></a>SRAM位带别名区地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AliasAddr= =<span class="number">0x22000000</span>+ (A<span class="number">-0x20000000</span>)*<span class="number">8</span>*<span class="number">4</span> +n*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>统一公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把“位带地址+位序号”转换成别名地址的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x00FFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br></pre></td></tr></table></figure>

<h2 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h2><p>LED的电亮</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置好环境后,即时钟打开,模式调整好后</span></span><br><span class="line"><span class="comment">//只需要将最后一步,点灯改为位操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_ODR (GPIO_BASE + 0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PBout(n) ((GPIOB_ODR &amp; 0xF0000000)+0x02000000+(( GPIOB_ODR &amp; 0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class="line"></span><br><span class="line">PBout(<span class="number">0</span>)=<span class="number">0</span>; <span class="comment">//开灯</span></span><br><span class="line">PBout(<span class="number">0</span>)=<span class="number">1</span>; <span class="comment">//关灯</span></span><br><span class="line"><span class="comment">//这里是绿灯,改为其他灯只需改成其他灯的初始化文件,如何将n改为1-&gt;蓝灯,n=5-&gt;红灯</span></span><br></pre></td></tr></table></figure>

<p>KEY 的检测</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在配置好环境后,即时钟打开,模式调整好后</span></span><br><span class="line"><span class="comment">//只需要将最后一步,检测改为位操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_IDR (GPIOA_BASE + 0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAin(n) ((GPIOA_IDR &amp; 0xF0000000)+0x02000000+(( GPIOA_IDR &amp; 0x00FFFFFF)&lt;&lt;5)+(n&lt;&lt;2))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(PAin(n) == KEY_ON)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(PAin(n) == KEY_ON);</span><br><span class="line">	LED_G_TEDDLE;<span class="comment">//此处写控制灯的电位发生反转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="启动文件-了解"><a href="#启动文件-了解" class="headerlink" title="启动文件(了解)"></a>启动文件(了解)</h1><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer01.png" alt="详细说明见表"></p>
<p>此处以最常用的hd为例,讲解启动文件</p>
<p>参考资料 中文手册 第九章, 开发手册(英文)</p>
<p>启动文件是上电之后第一个执行的文件</p>
<h2 id="启动文件的作用"><a href="#启动文件的作用" class="headerlink" title="启动文件的作用"></a>启动文件的作用</h2><ol>
<li>初始化堆栈指针()</li>
<li>设置PC指针(程序每执行一步,PC指针加一)</li>
</ol>
<p>让PC指针 = Reset handler</p>
<ol start="3">
<li>初始化中断向量表</li>
<li>配置系统时钟</li>
<li>调用C库函数_main,最终到C的世界</li>
</ol>
<h2 id="启动文件的内容"><a href="#启动文件的内容" class="headerlink" title="启动文件的内容"></a>启动文件的内容</h2><p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu01.png" alt="启动文件使用的ARM汇编指令汇总"></p>
<ol>
<li>配置栈 - 放变量(局部变量) 函数调用的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400                         ;1k</span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3 ;分配1KB空间 不初始化 可读可写 8字节对齐 </span><br><span class="line">Stack_Mem       SPACE   Stack_Size                        </span><br><span class="line">__initial_sp    ;紧跟着SPCE语句,表示出栈</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置堆 - 主要用于动态内存的分配, malloc()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap_Size     EQU     0x00000200 ;512Byte</span><br><span class="line"></span><br><span class="line">            AREA    HEAP, NOINIT, READWRITE, ALIGN=3 </span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem      SPACE   Heap_Size ;分配空间</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">PRESERVE 8 ;表示当前堆栈以8字节对齐</span><br><span class="line">TUHUMB     ;兼容老版本?</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化中断向量表</li>
</ol>
<p>当内核响应了一个发生的异常,对应的异常服务例程(ESR)执行. 根据每个向量(数字)对应一个异常,每个向量表对应一个地址,通过这个地址来访问中断服务程序.</p>
<p>数字越小,中断优先级越高</p>
<p>灰色代表内核,白色代表外设</p>
<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu02.png" alt="F103向量表"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA    RESET, DATA, READONLY</span><br><span class="line">EXPORT  __Vectors       ; </span><br><span class="line">EXPORT  __Vectors_End  </span><br><span class="line">EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">; 函数名对应的就是地址</span><br><span class="line">__Vectors  DCD   __initial_sp        ;栈顶地址</span><br><span class="line">        DCD   Reset_Handler       ;复位程序地址</span><br><span class="line">        DCD   NMI_Handler         ;不可屏蔽中断 和上面的表一致</span><br><span class="line">        DCD   HardFault_Handler</span><br><span class="line">        DCD   MemManage_Handler</span><br><span class="line">        DCD   BusFault_Handler</span><br><span class="line">        DCD   UsageFault_Handler</span><br><span class="line">        DCD   0                    ; 0 表示保留</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   SVC_Handler</span><br><span class="line">        DCD   DebugMon_Handler</span><br><span class="line">        DCD   0</span><br><span class="line">        DCD   PendSV_Handler</span><br><span class="line">        DCD   SysTick_Handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;外部中断开始</span><br><span class="line">        DCD   WWDG_IRQHandler</span><br><span class="line">        DCD   PVD_IRQHandler</span><br><span class="line">        DCD   TAMPER_IRQHandler</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">        DCD   DMA2_Channel2_IRQHandler</span><br><span class="line">        DCD   DMA2_Channel3_IRQHandler</span><br><span class="line">        DCD   DMA2_Channel4_5_IRQHandler</span><br><span class="line">__Vectors_End</span><br><span class="line">__Vectors_Size EQU __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>复位程序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AREA |.text|, CODE, READONLY</span><br></pre></td></tr></table></figure>

<p>定义一个名称为.text的代码段，可读。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reset_Handler PROC ;定义子程序</span><br><span class="line">            EXPORT  Reset_Handler    [WEAK] ;弱定义, 这个可以由C语言实现,如果用户没定义</span><br><span class="line">            IMPORT  SystemInit       ;插入 相对于C中的extern </span><br><span class="line">            IMPORT  __main           ;插入 C库函数- 初始化堆栈 最终调用我们写的main函数 实现从汇编到C语言的世界</span><br><span class="line"></span><br><span class="line">            LDR     R0, =SystemInit  ;系统时钟配置函数,用户配置</span><br><span class="line">            BLX     R0               ;BX执行完返回</span><br><span class="line">            LDR     R0, =__main</span><br><span class="line">            BX      R0               ;BX执行完不用返回</span><br><span class="line">            ENDP    ;结束子程序,于PROC一起使用</span><br></pre></td></tr></table></figure>

<p><img src="https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu03.png" alt="CM4内核的指令"></p>
<ol start="5">
<li>中断服务函数</li>
</ol>
<p>都是可以自己修改的,因为是[weak]弱定义,如果我们自己写了会执行我们自己写的,如果没有的写的话就会执行汇编语言自己写的,这里注意 如果我们自己写的话 函数名一定要写对!!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NMI_Handler     PROC    ;系统异常</span><br><span class="line">                EXPORT  NMI_Handler           [WEAK]</span><br><span class="line">                B       .  ;这个表示可以无限循环,可以被其他函数调用 这函数可以在C语言中实现</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">SysTick_Handler PROC</span><br><span class="line">                EXPORT  SysTick_Handler       [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line"></span><br><span class="line">Default_Handler PROC    ;外部中断</span><br><span class="line">                EXPORT  WWDG_IRQHandler       [WEAK]</span><br><span class="line">                EXPORT  PVD_IRQHandler        [WEAK]</span><br><span class="line">                EXPORT  TAMP_STAMP_IRQHandler [WEAK]</span><br><span class="line"></span><br><span class="line">;限于篇幅，中间代码省略</span><br><span class="line">LTDC_IRQHandler</span><br><span class="line">LTDC_ER_IRQHandler</span><br><span class="line">DMA2D_IRQHandler</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>堆栈的初始化</li>
</ol>
<p>程序的开头我们分配了堆和栈的大小,以及起始地址和结束地址</p>
<p>这里是用C语言来实现初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ALIGN</span><br><span class="line"></span><br><span class="line">ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示4字节对齐。</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;用户栈和堆初始化,由C库函数_main来完成</span><br><span class="line">IF      :DEF:__MICROLIB  ;这个宏在KEIL里面开启,开发环境ide;TARGET-MICROLIB 这个勾勾上</span><br><span class="line"></span><br><span class="line">EXPORT  __initial_sp ;知道栈和堆的地址</span><br><span class="line">EXPORT  __heap_base </span><br><span class="line">EXPORT  __heap_limit</span><br><span class="line"> </span><br><span class="line">ELSE ;如果</span><br><span class="line"></span><br><span class="line">IMPORT  __use_two_region_memory  ; 这个函数由用户自己实现</span><br><span class="line">EXPORT  __user_initial_stackheap </span><br><span class="line"></span><br><span class="line">__user_initial_stackheap</span><br><span class="line"></span><br><span class="line">LDR     R0, =  Heap_Mem                   ;这是CPU的暂存寄存器,CPU执行程序用的</span><br><span class="line">LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">LDR     R3, = Stack_Mem</span><br><span class="line">BX      LR</span><br><span class="line"></span><br><span class="line">ALIGN</span><br><span class="line"></span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>分配栈,堆的空间</p>
</li>
<li><p>中断向量表 </p>
</li>
<li><p>复位程序- 系统上电执行的第一个程序</p>
</li>
<li><p>中断服务程序,防止用户中断服务程序编写错误,进入无限循环</p>
</li>
<li><p>用户堆和栈的初始化</p>
</li>
<li><p>最后就进入到c的世界                    </p>
</li>
</ul>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电赛准备</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言进阶</title>
    <url>/2023/01/13/Python%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ul>
<li>首先我们要理解什么叫做**”异常”**？<ul>
<li>在程序运行过程中，总会遇到各种各样的问题和错误。</li>
<li>有些错误是我们编写代码时自己造成的：<ul>
<li>比如语法错误、调用错误，甚至逻辑错误。</li>
</ul>
</li>
<li>还有一些错误，则是不可预料的错误，但是完全有可能发生的：<ul>
<li>比如文件不存在、磁盘空间不足、网络堵塞、系统错误等等。</li>
</ul>
</li>
<li>这些导致程序在运行过程中出现异常中断和退出的错误，我们统称为异常。大多数的异常都不会被程序处理，而是以错误信息的形式展现出来。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0不能被作为除数</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span></span><br><span class="line">异常信息为：ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>

<ul>
<li><p>异常的分类：</p>
<ul>
<li>异常有很多种类型，Python内置了几十种常见的异常，无需特别导入，直接就可使用。</li>
<li>需要注意的是，所有的异常都是异常类，首字母是大写的！</li>
</ul>
</li>
<li><p>异常的危害：</p>
<ul>
<li>如果程序中一旦出现了异常的语句代码，则该异常就会立即中断程序的运行！</li>
</ul>
</li>
<li><p>因此：</p>
<ul>
<li>为了保证程序的正常运行，提高程序健壮性和可用性。我们应当尽量考虑全面，将可能出现的异常进行处理，而不是留在那里，任由其发生。</li>
</ul>
</li>
<li><p>python处理异常的机制：</p>
<ul>
<li>Python内置了一套try…except…finally（else）…的异常处理机制，来帮助我们进行异常处理。其基本语法是：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>机制说明：</p>
<ul>
<li><p>首先，执行try子句（在关键字try和关键字except之间的语句）</p>
</li>
<li><p>如果没有异常发生，忽略except子句，try子句执行后结束。</p>
</li>
<li><p>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之前的语句正常执行&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之后的语句不会被执行&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果程序发生的异常不在你的捕获列表中，那么依然会抛出别的异常:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 未捕获到异常，程序直接报错</span></span><br><span class="line">s1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>(s1)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> ex:    <span class="comment"># 本例为非法值异常，而你只捕获索引异常</span></span><br><span class="line">    <span class="built_in">print</span>(ex)</span><br></pre></td></tr></table></figure>

<ul>
<li>Exception是什么？<ul>
<li>在Python的异常中，有一个通用异常：<code>Exception</code>，它可以捕获任意异常。</li>
<li>思考：那么既然有这个什么都能管的异常，其他诸如OSError、ZeroDivisionError的异常是不是就可以不需要了？<ul>
<li>当然不是！很多时候程序只会弹出那么几个异常，没有必要针对所有的异常进行捕获，那样的效率会很低。另外，根据不同的异常种类，制定不同的处理措施，用于准确判断错误类型，存储错误日志，都是非常有必要甚至强制的。</li>
</ul>
</li>
<li>常见的异常类型：</li>
</ul>
<table>
<thead>
<tr>
<th>异常名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>AttributeError</td>
<td>试图访问一个对象没有的属性</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出异常</td>
</tr>
<tr>
<td>ImportError</td>
<td>无法引入模块或包；多是路径问题或名称错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>IndexError</td>
<td>下标索引错误</td>
</tr>
<tr>
<td>KeyError</td>
<td>试图访问不存在的键</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>Ctrl+C被按下，键盘终止输入</td>
</tr>
<tr>
<td>NameError</td>
<td>使用未定义的变量</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>语法错误</td>
</tr>
<tr>
<td>TypeError</td>
<td>传入对象的类型与要求的不符合</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>试图访问一个还未被设置的局部变量</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入一个调用者不期望的值，即使值的类型是正确的</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统执行错误</td>
</tr>
</tbody></table>
<ul>
<li>异常的基本使用：</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    1/0</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line">print(&#x27;我是异常代码后序的操作代码！&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python的异常机制具有嵌套处理的能力:</p>
<ul>
<li>比如在函数f3()调用f2()，f2()调用f1()，虽然是在f1()出错了，但只需要在f3()进行异常捕获，不需要每一层都捕获异常</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#函数嵌套出现异常</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line">f3()</span><br></pre></td></tr></table></figure>

<ul>
<li>函数嵌套处理异常：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    f1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f3()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>try…excetion的嵌套</p>
<ul>
<li><p>之前我们说过，不是只使用通用的异常类Exception就万事大吉了，为了效率问题，我们需要对常见的异常信息进行精准的捕获，那么如果异常出现在用户层的话，则就需要对用户操作可能会出现的异常进行判断然后精准捕获了，如何操作呢？</p>
<ul>
<li>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。也就是前面说的嵌套处理能力。直到程序最顶端如果还没有被捕获，那么将弹出异常。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发生异常之前的语句正常执行&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发生异常之后的语句不会被执行&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;里层没有抓好，只能辛苦我外层了&quot;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- 或者使用一个try和多个except的形式：
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之前的语句正常执行&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发生异常之后的语句不会被执行&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是第一个抓取到除零异常的&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> (ValueError,ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是备胎&quot;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- 或者在except后面跟一个元组，元组中包含多个异常类
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>finally和else子句</p>
<ul>
<li><p><code>try except</code>语法还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行：</p>
</li>
<li><p>同样的，还有一个可选的finally子句。无论try执行情况和except异常触发情况如何，finally子句都会被执行！</p>
</li>
<li><p>当然，else和finally同时存在时：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;else&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finally&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主动抛出异常：raise</p>
<ul>
<li><p>很多时候，我们需要主动抛出一个异常。Python内置了一个关键字<code>raise</code>，可以主动触发异常。</p>
</li>
<li><p>疑问：</p>
<ul>
<li>为什么要自己主动抛出异常？不嫌多事么？因为有的时候，你需要记录错误信息，然后将异常继续往上层传递，让上层去处理异常，如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    divNum = <span class="built_in">input</span>(<span class="string">&#x27;enter a divNum:&#x27;</span>)</span><br><span class="line">    divNum = <span class="built_in">int</span>(divNum)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="number">1</span>/divNum</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;记录异常日志： &quot;</span>, ex)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;但是我自己无法处理，只能继续抛出，看看上层能否处理（甩锅）&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;非法录入&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;用户录入非法数据，请重新输入！&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- 有时候，你需要主动弹出异常，作为警告或特殊处理：
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用户录入自己的性别：1表示男，2表示女</span></span><br><span class="line">sex = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please input a number: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> sex == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是个男人！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> sex == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这是个女人！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;好像有什么不符合常理的事情发生了！！&quot;</span>)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;非法的输入&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是个人妖！&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>在介绍迭代器之前，先说明下迭代的概念：</p>
<ul>
<li><p>迭代：</p>
<ul>
<li>通过for循环遍历”对象”的每一个元素的过程。</li>
<li>这里的对象指的就是可迭代对象。因此记住：for循环遍历的只能是可迭代的对象。</li>
</ul>
</li>
<li><p>可迭代类型的对象：</p>
<ul>
<li>在Python中，list/tuple/string/dict/set/bytes都是可以迭代的数据类型/可迭代对象！</li>
</ul>
</li>
<li><p>如何判定一个对象是否为可迭代对象呢？</p>
<ul>
<li>可以通过collections模块的Iterable类型作用在isinstance中来判断一个对象是否可迭代</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>,Iterable))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>迭代器</p>
<ul>
<li><p>迭代器是一种可以被遍历的对象(可迭代类型对象)，并且能作用于next()函数。</p>
</li>
<li><p>性质：</p>
<ul>
<li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往后遍历不能回溯，不像列表，你随时可以取后面的数据，也可以返回头取前面的数据。</li>
</ul>
</li>
<li><p>迭代器通常要实现两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</p>
</li>
<li><p>注意：</p>
<ul>
<li>可迭代对象并不一定是迭代器！</li>
<li>常见的数据结构，字符串、列表、元组都属于可迭代对象，并不是迭代器！</li>
</ul>
</li>
<li><p>如何创建一个迭代器呢？</p>
<ul>
<li>字符串，列表或元组对象，甚至自定义对象都可用于创建迭代器：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用Python内置的iter()方法创建迭代器对象</span></span><br><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)</span><br></pre></td></tr></table></figure>

<pre><code>- 可以使用type查看列表和迭代器类型的不同：
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(lis),<span class="built_in">type</span>(it))</span><br></pre></td></tr></table></figure>

<pre><code>- 使用next()方法获取迭代器的下一个元素：
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br></pre></td></tr></table></figure>

<pre><code>- 使用for循环遍历迭代器：
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(lis)          <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:            <span class="comment"># 使用for循环遍历迭代对象</span></span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思考：迭代器的作用是什么？</p>
<ul>
<li>可迭代对象的优缺点：<ul>
<li>可迭代对象的优点：可以直观查看里面的对象，如直接查看列表的内容</li>
<li>可迭代对象缺点：全部内容要加载至内存中，故占用内存</li>
</ul>
</li>
<li>迭代器的优缺点：<ul>
<li>优点：<ul>
<li>提供了一种通用不依赖索引的迭代取值方式；</li>
<li>节省内存，迭代器在内存中相当于只占一个数据的空间：因为每次取值都上一条数据会在内存释放，加载当前的此条数据。</li>
</ul>
</li>
<li>缺点：<ul>
<li>因为有next方法，即只能往后取值,不能往前，取值不如按照索引的方式灵活，不能取指定的某一个值</li>
<li>无法预测迭代器的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：迭代器和可迭代的区别？</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.凡是可作用于for循环的对象都是可迭代类型；</span><br><span class="line"></span><br><span class="line">2.凡是可作用于next()函数的对象都是迭代器类型；</span><br><span class="line"></span><br><span class="line">3.list、dict、str等是可迭代的但不是迭代器，因为next()函数无法调用它们。可以通过iter()函数将它们转换成迭代器。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义迭代器</p>
<ul>
<li><p>很多时候，为了让我们自己写的类成为一个迭代器，需要在类里实现<code>__iter__()</code>和<code>__next__()</code>方法</p>
<ul>
<li>实际上，在使用next()函数的时候，调用的就是迭代器对象的<code>__next__</code>方法</li>
<li>python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现<code>__iter__</code>方法，而<code>__iter__</code>方法要返回一个迭代器。<ul>
<li>迭代器自身正是一个迭代器，所以迭代器的<code>__iter__</code>方法返回自身即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#迭代生成指定范围数列的平方值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Squares</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, stop</span>):  <span class="comment"># 迭代起始、终止位</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.stop = stop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):     <span class="comment"># 返回自身的迭代器, 就是返回自己</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):     <span class="comment"># 调用next()函数 重写父类方法: 返回下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> self.start &gt; self.stop:   <span class="comment"># 结尾时抛出异常</span></span><br><span class="line">            <span class="keyword">raise</span> (StopIteration)</span><br><span class="line">        item = self.start**<span class="number">2</span></span><br><span class="line">        self.start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> Squares(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>菲波那切数列实现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#菲波那切数列实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FbnList</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,num</span>):</span><br><span class="line">        self.num = num</span><br><span class="line">        </span><br><span class="line">        self.index = <span class="number">0</span> <span class="comment">#当前生成了第几位数</span></span><br><span class="line">        <span class="comment">#初始化前三位值</span></span><br><span class="line">        self.num1 = <span class="number">0</span></span><br><span class="line">        self.num2 = <span class="number">1</span></span><br><span class="line">        self.num3 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &gt;= self.num:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        value = self.num1</span><br><span class="line">        self.num1,self.num2,self.num3 = self.num2,self.num3,self.num2+self.num3</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment">#参数为要生成多少位菲波那切数列的值</span></span><br><span class="line">fbn = FbnList(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fbn:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>实现类似iter功能的类：可以使得将列表转换成迭代器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List_A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,alist</span>):</span><br><span class="line">        self.alist = alist</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index &lt; <span class="built_in">len</span>(self.alist):</span><br><span class="line">            value = self.alist[self.index]</span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">a = List_A([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><ul>
<li><p>Python语言有一种独特的语法，相当于语法糖的存在，可以帮你在某些场合写出比较精简酷炫的代码。但没有它，也不会有太多的影响。Python语言有几种不同类型的推导式</p>
<ul>
<li>列表推导式</li>
<li>字典推导式</li>
<li>集合推导式</li>
<li>元组推导式?</li>
</ul>
</li>
<li><p>列表推导式</p>
<ul>
<li>列表推导式是一种快速生成列表的方式。其形式是用方括号括起来的一段语句，如下例子所示：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"><span class="comment">############上下两组代码是等效</span></span><br><span class="line">alist = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    alist.append(x*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li>列表推导式要这么理解，首先执行for循环，对于遍历的每一个x，代入x*x表达式中进行运算，将运算结果逐一添加到一个新列表内，循环结束，得到最终列表。它相当于下面的代码：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    alist.append(x*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：<ul>
<li>列表推导式为我们提供了一种在一行内实现较为复杂逻辑的生成列表的方法。其核心语法是用中括号[]将生成逻辑封装起来。当然列表推导式也有多样用法</li>
</ul>
</li>
<li>增加条件语句</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br><span class="line"></span><br><span class="line"><span class="comment">##############相当于如下代码</span></span><br><span class="line">alist_1 = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        alist_1.append(x*x)</span><br><span class="line"><span class="built_in">print</span>(alist_1)</span><br></pre></td></tr></table></figure>

<ul>
<li>多重循环</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re = [a+b <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(re)</span><br><span class="line"></span><br><span class="line"><span class="comment">#############</span></span><br><span class="line">alist = []</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>:</span><br><span class="line">        alist.append(a+b)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字典推导式</p>
<ul>
<li>既然使用中括号[]可以编写列表推导式，那么使用大括号呢？你猜对了！使用大括号{}可以制造字典推导式！</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;x:x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">dic = &#123;&#125;</span></span><br><span class="line"><span class="string">for x in [2,4,6]:</span></span><br><span class="line"><span class="string">    dic[x] = x**2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意x: x**2的写法，中间的冒号，表示左边的是key右边的是value。</p>
</li>
<li><p>集合推导式</p>
<ul>
<li>大括号除了能用作字典推导式，还可以用作集合推导式，两者仅仅在细微处有差别。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>元组推导式</p>
<ul>
<li>使用了中括号和大括号，那么使用圆括号，是不是元组推导式？想法不错，但事实却没有。圆括号在Python中被用作生成器的语法了，很快我们就会讲到，没有元组推导式。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#&lt;generator object &lt;genexpr&gt; at 0x102f45970&gt;</span></span><br><span class="line"><span class="comment">#返回的是一个生成器对象</span></span><br></pre></td></tr></table></figure>


<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul>
<li><p>在Python这门语言中，生成器毫无疑问是最有用的特性之一。</p>
</li>
<li><p>与此同时，也是使用的最不广泛的Python特性之一</p>
</li>
<li><p>究其原因，主要是因为，在其他主流语言里面没有生成器的概念。正是由于生成器是一个“新”的东西，所以，它一方面没有引起广大工程师的重视，另一方面，也增加了工程师的学习成本，最终导致大家错过了Python中如此有用的一个特性。那到底什么是生成器呢？</p>
</li>
<li><p>有时候，序列或集合内的元素的个数非常巨大，如果全制造出来并放入内存，对计算机的压力是非常大的。</p>
<ul>
<li>比如，假设需要获取一个10**20次方如此巨大的数据序列，把每一个数都生成出来，并放在一个内存的列表内，如果使用这种粗暴的方式，你能确保你的计算机会有如此大的内存么？</li>
<li>那么如果元素可以按照某种算法推算出来，需要该元素的话那就计算到哪个元素，那么就可以在循环的过程中不断推算出后续的元素，而不必创建完整的元素集合，从而节省大量的空间。在Python中，这种一边循环一边计算出元素的机制，称为生成器：generator。</li>
<li>因此：<strong>生成器是一种特殊的迭代器，生成器自动实现了“迭代器协议”（即__iter__和next方法）</strong>，不需要再手动实现两方法。</li>
</ul>
</li>
<li><p><strong>下面，我们一起来看看如何创建一个生成器！2种方式</strong></p>
<ul>
<li>生成器推导式(忽略)</li>
<li>for循环,yield关键字</li>
</ul>
</li>
<li><p>生成器推导式：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#生成器对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过next()函数获得generator的下一个返回值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;aabbccddeeff&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br></pre></td></tr></table></figure>

<ul>
<li>但更多情况下，我们使用for循环创建生成器：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>yield关键字创建生成器(重点)</p>
<ul>
<li><p>在 Python中，使用yield返回的函数会变成一个生成器（generator）。 在调用生成器的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行next()方法时从当前位置继续运行。下面重点理解yield关键字的使用：</p>
<ul>
<li>yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器</li>
<li>当你调用这个函数的时候，函数内部的代码并不立马执行 ，这个函数只是返回一个生成器对象</li>
<li>当你使用for进行遍历的时候或者调用next函数后，函数中的代码才会执行</li>
</ul>
</li>
<li><p>简单示例代码：函数体通过for循环结合yield返回一个生成器</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">createGenerator</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是循环体！&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> i*i <span class="comment">#使用了yield返回的结果而不是用return</span></span><br><span class="line">g = createGenerator()</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment">#&lt;generator object createGenerator at 0x104bc5970&gt;</span></span><br><span class="line">v1 = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="built_in">print</span>(v1)</span><br><span class="line"><span class="comment">#我是循环体！</span></span><br><span class="line"><span class="comment">#0</span></span><br><span class="line">v2 = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="built_in">print</span>(v2)</span><br><span class="line"><span class="comment">#我是循环体！</span></span><br><span class="line"><span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>思考：下述函数的执行结果是什么？</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">yieldTest</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        temp = <span class="keyword">yield</span> i <span class="comment">#赋值语句一定是先执行等号右侧的，在执行等号左侧</span></span><br><span class="line">        <span class="built_in">print</span>(temp)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">     <span class="comment">#在生成器函数实现内部是可以向yield后面写代码</span></span><br><span class="line">        </span><br><span class="line">obj = yieldTest()<span class="comment">#创建一个生成器对象</span></span><br><span class="line">v1 = <span class="built_in">next</span>(obj)</span><br><span class="line"><span class="built_in">print</span>(v1) <span class="comment">#执行结果：0</span></span><br><span class="line"></span><br><span class="line">v2 = <span class="built_in">next</span>(obj)</span><br><span class="line"><span class="built_in">print</span>(v2) <span class="comment">#执行结果：None 1</span></span><br></pre></td></tr></table></figure>


<p>​<br>    - 思考None是如何产生的第一次取值：yield 返回了 i 值 0，停在yield i，temp没赋到值。第二次取值，开始在print，temp没被赋值，故打印None，i加1，继续while判断，yield 返回了 i 值 1，停在yield i）</p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><ul>
<li><p>装饰器（Decorator）：</p>
<ul>
<li><p>从字面上理解，就是装饰对象的器件。</p>
</li>
<li><p>就是可以在不修改原有代码的情况下，为被装饰的对象增加新的功能或者附加限制条件。</p>
</li>
<li><p>装饰器有很多种，有函数的装饰器，也有类的装饰器。装饰器在很多语言中的名字也不尽相同，它体现的是设计模式中的装饰模式。</p>
</li>
<li><p>装饰器的语法是将@装饰器名，放在被装饰对象上面。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在进行装饰器的介绍之前，我们必须先明确几个概念和原则：</p>
<ul>
<li>首先，Python程序是从上往下顺序执行的,而且碰到函数的定义代码块是不会立即执行的，只有等到该函数被调用时，才会执行其内部的代码块</li>
<li>其次，由于顺序执行的原因，如果你真的对同一个函数定义了两次，那么，后面的定义会覆盖前面的定义。因此，在Python中代码的放置位置是有区别的，不能随意摆放，通常函数体要放在调用的语句之前。</li>
</ul>
</li>
<li><p>虚拟场景</p>
<ul>
<li>有一个大公司，下属的基础平台部负责内部应用程序及API的开发。另外还有上百个业务部门负责不同的业务，这些业务部门各自调用基础平台部提供的不同函数，也就是API处理自己的业务，情况如下：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>公司还在创业初期时，基础平台部就开发了这些函数。由于各种原因，比如时间紧，比如人手不足，比如架构缺陷，比如考虑不周等等，没有为函数的调用进行安全认证。现在，公司发展壮大了，不能再像初创时期的“草台班子”一样将就下去了，基础平台部主管决定弥补这个缺陷，于是：</p>
<ul>
<li><p>第一天：主管叫来了一个运维工程师，工程师跑上跑下逐个部门进行通知，让他们在代码里加上认证功能，然后，当天他被开除了。</p>
</li>
<li><p>第二天：主管叫来了一个python自动化开发工程师。哥们是这么干的，只对基础平台的代码进行重构，让N个业务部门无需做任何修改。这哥们很快也被开了，连运维也没得做。　　</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">  <span class="comment">#加入认证程序代码</span></span><br><span class="line">  xxx</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<pre><code>- 第三天：主管又换了个开发工程师。他是这么干的：定义个认证函数，在原来其他的函数中调用它，代码如下:
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cheak</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">  cheak()</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<pre><code>- 但是主管依然不满意，不过这一次他解释了为什么。

  - 主管说：写代码要遵循开放封闭原则，简单来说，已经实现的功能代码内部不允许被修改，但外部可以被扩展。如果将开放封闭原则应用在上面的需求中，那么就是不允许在函数f1 、f2、f3......f100的内部进行代码修改，但是可以在外部对它们进行扩展。

- 第四天：已经没有时间让主管找别人来干这活了，他决定亲自上阵，使用装饰器完成这一任务，并且打算在函数执行后再增加个日志功能。主管的代码如下：
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">func</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;认证功能操作&#x27;</span>)</span><br><span class="line">    result = func()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment">#基础平台部门开发了上百个函数的API</span></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="meta">@outer  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门2的数据接口......&#x27;</span>)</span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门3的数据接口......&#x27;</span>)</span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f100</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门100的数据接口......&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">#各部分分别调用自己部分的API</span></span><br><span class="line">f1()</span><br><span class="line">f2()</span><br><span class="line">f3()</span><br><span class="line">f100()</span><br></pre></td></tr></table></figure>

<pre><code>- 使用装饰器@outer，也是仅需对基础平台的代码进行拓展，就可以实现在其他部门调用函数API之前都进行认证操作，并且其他业务部门无需对他们自己的代码做任何修改，调用方式也不用变。
</code></pre>
<ul>
<li><p>装饰器机制分析</p>
<ul>
<li>下面以f1函数为例，对装饰器的运行机制进行分析：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.定义一个装饰器</span></span><br><span class="line"><span class="comment">#装饰器outer是有特殊要求的：</span></span><br><span class="line"><span class="comment">#要求1：装饰器函数必须要有一个参数（表示的是被装饰函数的函数名）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">func</span>): <span class="comment">#step2.func == f1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;给f1函数增添的安全认证功能&#x27;</span>)</span><br><span class="line">        func() <span class="comment">#step3:等同于在调用f1()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;给f1函数增加了数据检测的功能&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner<span class="comment">#step4：inner表示的是内部函数的名字，该函数名就会替换被装饰的函数名</span></span><br><span class="line"><span class="comment">#2.使用定义好的装饰器，去装饰某一个函数（在不修改函数原有代码的基础上给其增添新的功能）</span></span><br><span class="line"><span class="comment">#如果装饰器装饰了一个函数，则装饰器函数就会被自动调用</span></span><br><span class="line"><span class="meta">@outer </span><span class="comment"># step1.调用装饰器函数，且将被装饰的函数名传递给装饰器函数的参数</span></span><br><span class="line"><span class="comment">#使用outer装饰器装饰f1函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(): <span class="comment">#step5：f1 == inner; inner()函数调用就是在调用f1()</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;业务部门1的数据接口......&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(): <span class="comment">#f2是没有被outer装饰的</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f2函数的原有实现&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f1() <span class="comment">#实际上就是在调用inner()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 1.程序开始运行，从上往下解释，读到def outer(func):的时候，发现这是个函数定义，于是把函数体加载到内存里。</span><br><span class="line"></span><br><span class="line">- 2.读到@outer的时候，程序被@这个语法吸引住了，解释器知道这是个装饰器，按规矩要立即执行的，于是程序开始运行@后面那个名字outer所定义的函数。</span><br><span class="line"></span><br><span class="line">- 3.程序返回到outer函数，开始执行装饰器的语法规则。规则是：</span><br><span class="line">  - 被装饰的函数的名字会被当作参数传递给装饰函数。装饰函数执行它自己内部的代码后，会将它的返回值赋值给被装饰的函数。原来的f1函数被当做参数传递给了func，而f1这个函数名之后会指向inner函数。</span><br><span class="line"></span><br><span class="line">- 注意：</span><br><span class="line">  - @outer和@outer()有区别，没有括号时，outer函数依然会被执行，这和传统的用括号才能调用函数不同，需要特别注意！</span><br><span class="line">  - f1这个函数名当做参数传递给装饰函数outer，也就是：func = f1，@outer等于outer(f1),实际上传递了f1的函数体，而不是执行f1后的返回值。</span><br><span class="line">  - outer函数return的是inner这个函数名，而不是inner()这样被调用后的返回值</span><br><span class="line"></span><br><span class="line">- 4.程序开始执行outer函数内部的内容，一开始它又碰到了一个函数inner，inner函数定义块被程序观察到后不会立刻执行，而是读入内存中（这是默认规则）。</span><br><span class="line"></span><br><span class="line">- 5.再往下，碰到return inner，返回值是个函数名，并且这个函数名会被赋值给f1这个被装饰的函数，也就是f1 = inner。根据前面的知识，我们知道，此时f1函数被新的函数inner覆盖了（实际上是f1这个函数名更改成指向inner这个函数名指向的函数体内存地址，f1不再指向它原来的函数体的内存地址），再往后调用f1的时候将执行inner函数内的代码，而不是先前的函数体。那么先前的函数体去哪了？还记得我们将f1当做参数传递给func这个形参么？func这个变量保存了老的函数在内存中的地址，通过它就可以执行老的函数体，你能在inner函数里看到result = func()这句代码，它就是这么干的！</span><br><span class="line"></span><br><span class="line">- 6.接下来，还没有结束。当业务部门，依然通过f1()的方式调用f1函数时，执行的就不再是旧的f1函数的代码，而是inner函数的代码。</span><br><span class="line"></span><br><span class="line">- 7.以上流程走完后，你应该看出来了，在没有对业务部门的代码和接口调用方式做任何修改的同时，也没有对基础平台部原有的代码做内部修改，仅仅是添加了一个装饰函数，就实现了我们的需求，在函数调用前进行认证，调用后写入日志。这就是装饰器的最大作用。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>思考：为什么我们要搞一个outer函数一个inner函数这么复杂呢？一层函数不行吗？</p>
<ul>
<li>请注意，@outer这句代码在程序执行到这里的时候就会自动执行outer函数内部的代码，如果不封装一下，在业务部门还未进行调用的时候，就执行了，这和初衷不符。当然，如果你对这个有需求也不是不行。</li>
</ul>
</li>
<li><p>带参装饰器</p>
<ul>
<li><p>上面的例子中，f1函数没有参数，在实际情况中肯定会需要参数的，函数的参数怎么传递的呢？</p>
</li>
<li><p>在inner函数的定义部分也加上一个参数，调用func函数的时候传递这个参数：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">func</span>):<span class="comment">#2.func == f1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">n</span>): <span class="comment">#3.n == name,n就是被装饰函数的参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;新功能！&#x27;</span>)</span><br><span class="line">        func(n) <span class="comment">#4.func(n) == f1(n)</span></span><br><span class="line">    <span class="keyword">return</span> inner <span class="comment">#5.inner就会覆盖原先的被装饰函数名f1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer </span><span class="comment">#1.调用装饰器函数，将被装饰的函数名f1作为实参，传递给outer的形参</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">name</span>): <span class="comment">#6.f1 == inner</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f1的原有功能，f1的参数值为：&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line">f1(<span class="string">&#x27;bobo&#x27;</span>) <span class="comment">#7.inner(&#x27;bobo&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数模准备</tag>
        <tag>语言基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网站搭建以及优化改造</title>
    <url>/2022/12/17/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E5%B9%B6%E4%BB%A5Next%E4%B8%BB%E9%A2%98%E4%B8%BA%E4%BE%8B%E6%9D%A5%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%E6%94%B9%E9%80%A0/</url>
    <content><![CDATA[<h1 id="为什么我想搭建一个博客"><a href="#为什么我想搭建一个博客" class="headerlink" title="为什么我想搭建一个博客"></a>为什么我想搭建一个博客</h1><p>这里可以看这个视频:<a href="%5B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2?%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%86%99?%E5%8D%9A%E5%AE%A2%E5%9C%A8%E9%9D%A2%E8%AF%95%E6%97%B6%E7%9A%84%E5%8A%A0%E5%88%86%E5%8F%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E7%82%B9%E7%82%B9,%E5%88%AB%E5%86%8D%E7%8A%B9%E8%B1%AB%E4%BA%86,%E5%BF%AB%E8%A1%8C%E5%8A%A8%E8%B5%B7%E6%9D%A5!_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1Px411d74c/?spm_id_from=333.880.my_history.page.click&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">为什么程序员必须写技术博客?以及如何写?博客在面试时的加分可不是一点点,别再犹豫了,快行动起来!</a> 建议配套视频同步搭建博客</p>
<h1 id="如何用hexo搭建一个网站"><a href="#如何用hexo搭建一个网站" class="headerlink" title="如何用hexo搭建一个网站"></a>如何用hexo搭建一个网站</h1><h2 id="需要下载的工具"><a href="#需要下载的工具" class="headerlink" title="需要下载的工具"></a>需要下载的工具</h2><p>node：javascript运行环境</p>
<p>vscode：代码编辑器</p>
<p>git：版本控制工具</p>
<h2 id="hexo的安装"><a href="#hexo的安装" class="headerlink" title="hexo的安装"></a>hexo的安装</h2><p>按下 win+R，输入cmd，打开系统的终端，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=http://registry.npm.taobao.org	#安装淘宝的cnpm 管理器</span><br><span class="line">cnpm -v	#查看cnpm版本</span><br><span class="line">cnpm install -g hexo-cli    #安装hexo框架</span><br><span class="line">hexo -v	#查看hexo版本</span><br></pre></td></tr></table></figure>

<h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><p>按下 win+R，输入cmd，打开系统的终端，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir blog	#创建blog目录</span><br><span class="line">cd blog	 #进入blog目录</span><br><span class="line">hexo init 	#生成博客 初始化博客</span><br></pre></td></tr></table></figure>

<h4 id="预览博客"><a href="#预览博客" class="headerlink" title="预览博客"></a>预览博客</h4><p>在终端处输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>此时 可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 本地访问地址,这里面会生成一个默认的文章</p>
<h4 id="创建一篇新的文章"><a href="#创建一篇新的文章" class="headerlink" title="创建一篇新的文章"></a>创建一篇新的文章</h4><p>一般用终端 在blog目录下输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot; #创建新的文章 &quot;里面是文章名称&quot;</span><br></pre></td></tr></table></figure>

<h4 id="将blog远程部署到GitHub上"><a href="#将blog远程部署到GitHub上" class="headerlink" title="将blog远程部署到GitHub上"></a>将blog远程部署到GitHub上</h4><p>这样可以使别人在别人的电脑上就可以浏览你的博客</p>
<ul>
<li>创建一个GitHub账号</li>
<li>Github创建一个新的仓库: 此时的仓库名必须是:YourGithubName.github.io</li>
<li>按下 win+R，输入cmd，打开系统的终端，输入<code>cd blog</code>进入blog文件下</li>
<li>输入<code>cnpm install --save hexo-deployer-git #在blog目录下安装git部署插件</code></li>
<li>输入<code>_config.yml </code>#配置_config.yml ,一般使用记事本或者VSCODE打开 这里推荐VScode</li>
</ul>
<p>找到最后的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line"> 		type: git</span><br><span class="line">		repo: https://github.com/YourGithubName/YourGithubName.github.io.git</span><br><span class="line"> 		branch: main </span><br></pre></td></tr></table></figure>

<p>划重点!!!!!注意缩进 并且:后面有一个空格!!!!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在部署博客前,win10用户注意!先输入</span><br><span class="line">git config --global user.email &quot;xxx&quot; #GitHub上的邮箱账号</span><br><span class="line">git config --global user.name &quot;xxx&quot;	#GitHub的名字</span><br><span class="line"># 然后再</span><br><span class="line">hexo d	#部署到Github仓库里</span><br><span class="line">https://YourGithubName.github.io/  #访问这个地址可以查看博客</span><br></pre></td></tr></table></figure>

<p>之后更改了_config.yml的内容,需要重新部署到远程,只需要执行下面的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c	#清理一下</span><br><span class="line">hexo g	#生成</span><br><span class="line">hexo d	#部署到远程Github仓库</span><br><span class="line">https://YourGithubName.github.io/  #查看博客</span><br></pre></td></tr></table></figure>

<p>一般部署成功后会收到一个邮件,然后等一会儿刷新就可以看到了!</p>
<hr>
<h1 id="如何美化博客"><a href="#如何美化博客" class="headerlink" title="如何美化博客"></a>如何美化博客</h1><ul>
<li>本文使用的美化主题是butterfly,真的很好看!狠狠地安利了!!!!</li>
</ul>
<p>安装教程直接看官方教程就行,还会实时更新!!!</p>
<p>这里是链接: <a href="https://butterfly.js.org/posts/21cfbf15/">官方教程</a></p>
<p>这里也有: <a href="%5B%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E5%AD%A6(7)%7C%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1d64y1q7KS/?spm_id_from=333.788&vd_source=1e56c5282fb34ebc3bc5d2b2b4c8d5a7)">配套视频</a></p>
<p><strong>真的很详细!!!</strong></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Markdown+ Typora</title>
    <url>/2022/12/18/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Markdown-Typora/</url>
    <content><![CDATA[<h1 id="如何使用Markdown-Typora"><a href="#如何使用Markdown-Typora" class="headerlink" title="如何使用Markdown+ Typora"></a>如何使用Markdown+ Typora</h1><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以 <code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 $\LaTeX$, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势. </p>
<p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 <strong>Markdown</strong> 语法. 如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).</p>
<hr>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p>
<p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰, 层次分明.</p>
<p>用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告, 代码的 <code>README.md</code> … 包括本教程文档.</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Markdown 只是一种语法. </p>
<p>那么用来写 Markdown 文本编辑器: <strong>Typora</strong> , <strong>VS Code</strong></p>
<p>本文是用typora来写的.链接的地址是我朋友给的不知道为什么不收钱哈哈哈</p>
<h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown 语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将 <code>.md</code> 导出成多种文件, 如 <code>.pdf</code>, <code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p>
<h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VS Code 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All in One</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载 Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>大部分IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法, 在此不多赘述.</p>
<p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora 所包含的扩展语法.</p>
<hr>
<h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p>当有多种标记方法时我会倾向其中一种. </p>
<p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code <strong>本地生效</strong>, 在大多数平台上<strong>并不认可</strong>.</p>
<h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 <code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的, 也是无法转义的. </p>
<p>所以写 Markdown 的时候都用半角标点, 即英文标点, 如 <code>,.?!()[]:;&quot;&quot;</code>. 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.</p>
<p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> + <code>.(这是个句号)</code>, 切换标点的全角与半角. 这样即可中文输入+半角标点.</p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>[数个 “#” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>标题会在目录与大纲分级显示, 可以跳转. </p>
<p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为 <code>#标题</code>, 应为 <code># 标题</code>. </p>
<p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容. </p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>[用 “**” 或 “__” 包围]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**欢迎报考海南大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考海南大学!__</span><br></pre></td></tr></table></figure>

<p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>. </p>
<p>例子:</p>
<p>欢迎报考海南大学! </p>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>[用 “*” 或 “_” 包围]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*老师菜菜捞捞* (我喜欢用这种)</span><br><span class="line">_老师菜菜捞捞_</span><br></pre></td></tr></table></figure>

<p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>. </p>
<p>例子:</p>
<p><em>老师菜菜捞捞</em></p>
<p>(P.S. <em><strong>斜体并强调</strong></em> [用 “***” 或 “___” 包围])</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>[用 “~~” 包围]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~牛~~</span><br></pre></td></tr></table></figure>

<p>E.G. </p>
<p><del>牛</del></p>
<h3 id="高亮"><a href="#高亮" class="headerlink" title="*高亮"></a>*高亮</h3><p>[用 “==” 包围]</p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==牛==</span><br></pre></td></tr></table></figure>

<p>E.G.</p>
<p>==牛== </p>
<p>???为什么这里无高亮????</p>
<p>我不理解</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>[用 “`” 包围]</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">`print(hello world);`</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<p><code>print(hello world);</code></p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>[按三个 “`” 并敲回车]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">​``` //这里先敲三个`</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int mian() </span><br><span class="line">&#123;</span><br><span class="line">    printf（“Hello, world!\n&quot;）;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 这里就可以开始输入你要的代码了</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> //在右下角可以选择语言</span></span><br></pre></td></tr></table></figure>

<p><code>或者用这样c </code></p>
<p> // (这三个”`”文本编辑器会帮你自动补全 一般不用手动输)</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>[“&gt;” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引用是可以嵌套的!</span><br><span class="line"></span><br><span class="line">&gt; 我是个小孩</span><br><span class="line">&gt; &gt; 我才18岁</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<blockquote>
<p>我是个小孩</p>
<blockquote>
<p>我才18岁</p>
</blockquote>
</blockquote>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>[“-“ 或  “+” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 明天回家了 (我喜欢用这种)</span><br><span class="line"></span><br><span class="line">+ 坐飞机回家</span><br><span class="line"></span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br><span class="line"></span><br><span class="line">三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 `Tab` 会缩进一级. </span><br></pre></td></tr></table></figure>
<p>例子:</p>
<ul>
<li>明天回家了 (我喜欢用这种)</li>
</ul>
<ul>
<li>坐飞机回家</li>
</ul>
<ul>
<li>(其实这种也可以, 不过由于在 Typora 中很难单个输入,就是懒!!!!!)</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>[数字 + “.” + 空格 前置]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">敲回车会自动补全, 敲回车后按下 `Tab` 会缩进一级.在 数字＋. 后按下回车会取消空格</span><br><span class="line">1. 第一点</span><br><span class="line">2. 第二点</span><br><span class="line">3. 这是第三点</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<ol>
<li>第一点</li>
<li>第二点</li>
<li>这是第三点</li>
</ol>
<h3 id="上标"><a href="#上标" class="headerlink" title="*上标"></a>*上标</h3><p>[用 “^” 包围]</p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C语言中 `int` 的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure>
<p>好尴尬啊为什么没有? 难道是我的设置问题???</p>
<p>C语言中 <code>int</code> 的上限是 2^31^ - 1 = 2147483647</p>
<h3 id="下标"><a href="#下标" class="headerlink" title="*下标"></a>*下标</h3><p><strong>[用 “~” 包围]</strong></p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E.G. </span><br><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure>
<p>H<del>2</del>O 是剧毒的!</p>
<p>???这里我也显示不出来? 我明明点了扩展语法了!!!!</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="*注释"></a>*注释</h3><p><strong>[“[^]” 后置]</strong></p>
<p><strong>(注意: 此为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要在文末写上注释对应的内容</span><br><span class="line">&gt; 今天你到这,是为了学习 Markdown 的使用, 它的教程对于你而言, 值得金钱的支持鼓励!![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure>
<p>[今天你到这,是为了学习 Markdown 的使用, 它的教程对于你而言, 值得金钱的支持鼓励![^1]</p>
<p>[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>[常用 “[ ]” + “( )” 分别包围文本与链接]</strong></p>
<p><strong>(注意: 文内跳转为扩展用法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">支持网页链接与文内跳转, 按住 `Ctrl` 并 `单击鼠标左键` 即可跳转.</span><br><span class="line"></span><br><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sugarchen7)</span><br><span class="line"></span><br><span class="line">[基础教程: 12. 下标](#12. *下标 )</span><br><span class="line"></span><br><span class="line">只需要在#后面加上该行的内容即可</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Sugarchen7">来看看我贫瘠的仓库罢</a></p>
<p>[基础教程: 12. 下标](#12. *下标 )</p>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p> <strong>[“- [ ]” + 空格 前置]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用 `x` 代替 `[ ]` 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.</span><br><span class="line">这个功能对喜欢写todolist的人比如我!很好!!!!</span><br><span class="line"></span><br><span class="line">TodoList:</span><br><span class="line"></span><br><span class="line">- [ ] 吃饭</span><br><span class="line">- [ ] 上厕所</span><br><span class="line">- [x] 早起</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<p>TodoList:</p>
<ul>
<li><input disabled="" type="checkbox"> 吃饭</li>
<li><input disabled="" type="checkbox"> 上厕所</li>
<li><input checked="" disabled="" type="checkbox"> 早起</li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p> <strong>[用 “|” 绘制表格边框]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据</span><br><span class="line">可以直接右键插入表格,十分方便,也可以手敲!和latex有点类似.</span><br><span class="line"></span><br><span class="line">| 学号 | 姓名 | 年龄 |</span><br><span class="line">| :--: | :--- | ---: |</span><br><span class="line">|  1   | 小陈 |   18 |</span><br><span class="line">|  2   | 老陈 |   30 |</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">学号</th>
<th align="left">姓名</th>
<th align="right">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">小陈</td>
<td align="right">18</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">老陈</td>
<td align="right">30</td>
</tr>
</tbody></table>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p> <strong>[直接拖进来或者复制粘贴]</strong></p>
<p>注意偏好设置,不然别人不好观看!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">或者会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式. </span><br><span class="line">![](图片的位置)</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<p><img src="E:\markdown\图像.png" alt="图像该如何设置"></p>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p><strong>[按三个 “*” 或 “-“ 或 “_” 并敲回车]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">由于 `*` 与 `_` 均会自动补全, 所以我觉得 `-` 最为方便.</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">___</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<p>效果就是上面所示啦</p>
<h3 id="😁Emoji表情"><a href="#😁Emoji表情" class="headerlink" title="😁Emoji表情"></a>😁Emoji表情</h3><h4 id="“-”-前置"><a href="#“-”-前置" class="headerlink" title="[“:” 前置]"></a>[“:” 前置]</h4><p><strong>(注意: 英文输入为扩展语法)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji 的英文名. </span><br><span class="line"></span><br><span class="line">当然 window用户可以 win+. 直接打开emo库插入</span><br><span class="line"></span><br><span class="line">:sweat_smile: </span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line"></span><br><span class="line">对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里分享一个可以复制[全Emoji的网站](https://emojipedia.org/apple/)</span><br></pre></td></tr></table></figure>
<p>这里分享一个可以复制<a href="https://emojipedia.org/apple/">全Emoji的网站</a></p>
<p>E.G. </p>
<p>😅🤤🤡</p>
<hr>
<h2 id="进阶教程"><a href="#进阶教程" class="headerlink" title="进阶教程"></a>进阶教程</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><strong>[自动生成]</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br><span class="line"></span><br><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure>
<h3 id="内联-HTML-代码"><a href="#内联-HTML-代码" class="headerlink" title="内联 HTML 代码"></a>内联 HTML 代码</h3><p> [用 “&lt;&gt; &lt;/&gt;” 包围] 可以用一些快捷键</p>
<div style="text-align:center">
  <font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font>
</div>


<center>简单的文字居中也可以这样</center>

<p><u>我差点忘了还有下划线这东西…</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">只要你会写, 你完全可以把 Markdown 当作 **HTML** 来写.</span><br><span class="line"></span><br><span class="line">同时, `.md` 文件可以直接导出成一个网页.</span><br><span class="line"></span><br><span class="line">下划线可以选中想要下划的文字按下 `Ctrl` + `U`. </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>E.G. </p>
<div style="text-align:center">
  <font style="color:red">我不会 HTML 呜呜呜...</font>
</div>



<center>简单的文字居中也可以这样</center>

<p><u>我差点忘了还有下划线这东西…</u></p>
<h3 id="Typora-的常用快捷键"><a href="#Typora-的常用快捷键" class="headerlink" title="*Typora 的常用快捷键"></a>*Typora 的常用快捷键</h3><table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">效果</th>
<th align="center">按键</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Ctrl</code> + <code>D</code></td>
<td align="center">选中当前词</td>
<td align="center"><code>Ctrl</code> + <code>L</code></td>
<td align="center">选中当前句/行</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>E</code></td>
<td align="center">选中当前区块</td>
<td align="center"><code>Ctrl</code> + <code>F</code></td>
<td align="center">搜索当前选中</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>B</code></td>
<td align="center">加粗当前选中</td>
<td align="center"><code>Ctrl</code> + <code>H</code></td>
<td align="center">替换当前选中</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>I</code></td>
<td align="center">倾斜当前选中</td>
<td align="center"><code>Ctrl</code> + <code>U</code></td>
<td align="center">下划当前选中</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>K</code></td>
<td align="center">将当前选中生成链接</td>
<td align="center"><code>Ctrl</code> + <code>J</code></td>
<td align="center">滚动屏幕将选中滚至顶部</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>W</code></td>
<td align="center">关闭当前窗口</td>
<td align="center"><code>Ctrl</code> + <code>N</code></td>
<td align="center">打开新窗口</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>O</code></td>
<td align="center">打开文件</td>
<td align="center"><code>Ctrl</code> + <code>P</code></td>
<td align="center">搜索文件并打开</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>回车</code></td>
<td align="center">表格下方插入行</td>
<td align="center"><code>Ctrl</code> + <code>,</code></td>
<td align="center">打开偏好设置</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>.</code></td>
<td align="center">切换全角/半角标点</td>
<td align="center"><code>Ctrl</code> + <code>/</code></td>
<td align="center">切换正常/源代码视图</td>
</tr>
<tr>
<td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td>
<td align="center">缩小视图缩放</td>
<td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td>
<td align="center">放大视图缩放</td>
</tr>
</tbody></table>
<h3 id="Typora-的主题样式与检查元素"><a href="#Typora-的主题样式与检查元素" class="headerlink" title="*Typora 的主题样式与检查元素"></a>*Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故Typora的主题样式本质就是 CSS 文件.</p>
<p>可以下载各种好看的主题给 Typora换上, 同时也可以自己调整对应的 CSS 文件, 或者自己手搓. </p>
<p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开 <code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML 来编辑.</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此, <strong>Markdown + Typora / VSCode</strong> 的手册教程也告一段落. </p>
<p>不知你看完这么长的教程/手册, 是否能体会到 Markdown 的精妙简洁之处呢? </p>
<p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown 之后对于理解 HTML 也有帮助, 对于用 $\LaTeX$ 来写论文也有帮助. 标记语言正是为了摆脱 Word 那种虽然”所见即所得”, 但又过于花哨浮华, 很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的”所写即所得”时, 你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p>
]]></content>
      <tags>
        <tag>Tyraro</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2022/12/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="这是我的第一篇博客-2022-12-18"><a href="#这是我的第一篇博客-2022-12-18" class="headerlink" title="这是我的第一篇博客 2022-12-18"></a>这是我的第一篇博客 2022-12-18</h1><h2 id="我创建博客的初衷"><a href="#我创建博客的初衷" class="headerlink" title="我创建博客的初衷"></a><strong>我创建博客的初衷</strong></h2><p>​    markdown的写电子笔记来加深自己对于学习各门课程的建议。建立起自己的知识清单。</p>
<h2 id="第二点是为了记录走过的坑"><a href="#第二点是为了记录走过的坑" class="headerlink" title="第二点是为了记录走过的坑"></a><strong>第二点是为了记录走过的坑</strong></h2><p>​    是作为一个电子的学生，学习很多东西都会才不少坑，我会通过博客的形式记录下来。让自己更加生科认识到自己犯的错误！如果有人犯了和我一样的错误时，也可以通过博客的形式找到解决方法。</p>
<h2 id="第三点是提高自己的写作水平，结交认识的朋友"><a href="#第三点是提高自己的写作水平，结交认识的朋友" class="headerlink" title="第三点是提高自己的写作水平，结交认识的朋友"></a><strong>第三点是提高自己的写作水平，结交认识的朋友</strong></h2><p>​    把自己学会的东西写下来，让别人能够看懂，然后做出同样的结果。才是真正的学会了。    </p>
<p>​    一个人可以走多远关键在于与谁同行。希望在网上学习的过程中可以碰到很多志同道合的朋友一起学习。这一直是我所期盼的。</p>
<h2 id="寄语"><a href="#寄语" class="headerlink" title="寄语"></a><strong>寄语</strong></h2><p>​    我是一位纯小白，可能有地方会出现问题，还希望大家发现之后多多指正。也希望大家可以给我指出一些建议，让我的博客做得更好！</p>
]]></content>
  </entry>
</search>
